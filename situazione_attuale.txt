<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class AdminMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        $user = auth()->user();

        // Check if user is admin (zone admin or national admin)
    if (!in_array($user->user_type, ['admin', 'national_admin', 'super_admin'])) {
        abort(403, 'Accesso non autorizzato. Solo gli amministratori possono accedere a questa sezione.');
    }

        // Additional check: ensure admin has access to their zone
        if ($user->user_type === 'admin' && !$user->zone_id) {
            abort(403, 'Il tuo account amministratore non ha una zona assegnata. Contatta il supporto tecnico.');
        }

        return $next($request);
    }
}
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class AdminOrSuperAdmin
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        $user = auth()->user();

        // Allow super_admin, national_admin, and zone_admin
        $allowedTypes = ['super_admin', 'national_admin', 'admin'];

        if (!in_array($user->user_type, $allowedTypes)) {
            abort(403, 'Accesso negato. Solo gli amministratori possono accedere a questa sezione.');
        }

        // Store user context for views
        view()->share('isSuperAdmin', $user->user_type === 'super_admin');
        view()->share('isNationalAdmin', $user->user_type === 'national_admin');
        view()->share('currentUserType', $user->user_type);

        return $next($request);
    }
}
<?php

namespace App\Http\Middleware;

use Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull as Middleware;

class ConvertEmptyStringsToNull extends Middleware
{
    /**
     * The names of the attributes that should not be converted to null.
     *
     * @var array<int, string>
     */
    protected $except = [
        //
    ];
}
<?php

namespace App\Http\Middleware;

use Illuminate\Foundation\Http\Middleware\PreventRequestsDuringMaintenance as Middleware;

class PreventRequestsDuringMaintenance extends Middleware
{
    /**
     * The URIs that should be reachable while maintenance mode is enabled.
     *
     * @var array<int, string>
     */
    protected $except = [
        //
    ];
}
<?php

namespace App\Http\Middleware;

use App\Providers\RouteServiceProvider;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Symfony\Component\HttpFoundation\Response;

class RedirectIfAuthenticated
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next, string ...$guards): Response
    {
        $guards = empty($guards) ? [null] : $guards;

        foreach ($guards as $guard) {
            if (Auth::guard($guard)->check()) {
                return redirect('/dashboard');
            }
        }

        return $next($request);
    }
}
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class RefereeMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        $user = auth()->user();

        // Check if user is a referee
        if ($user->user_type !== 'referee') {
            abort(403, 'Accesso non autorizzato. Solo gli arbitri possono accedere a questa sezione.');
        }

        // Check if referee account is active
        if (!$user->is_active) {
            abort(403, 'Il tuo account arbitro non è attivo. Contatta l\'amministratore della tua zona.');
        }

// Check if referee has completed profile
if (!$user->hasCompletedProfile()) {
    // NON reindirizzare se siamo già sulla pagina profilo
    if (!$request->routeIs('referee.profile.*')) {
        return redirect()->route('referee.profile.edit')
            ->with('warning', 'Devi completare il tuo profilo prima di poter accedere alle altre sezioni.');
    }
}

        return $next($request);
    }
}
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class RefereeOrAdmin
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        $user = auth()->user();

        // Allow all user types (referee, zone_admin, national_admin, super_admin)
        $allowedTypes = ['referee', 'zone_admin', 'national_admin', 'super_admin'];

        if (!in_array($user->user_type, $allowedTypes)) {
            abort(403, 'Accesso negato.');
        }

        // Store user context for views
        view()->share('isReferee', $user->user_type === 'referee');
        view()->share('isAdmin', in_array($user->user_type, ['zone_admin', 'national_admin', 'super_admin']));
        view()->share('isSuperAdmin', $user->user_type === 'super_admin');
        view()->share('currentUserType', $user->user_type);

        return $next($request);
    }
}
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class SuperAdmin
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        $user = auth()->user();

        // Check if user is super admin
        if ($user->user_type !== 'super_admin') {
            abort(403, 'Accesso negato. Solo i Super Admin possono accedere a questa sezione.');
        }

        return $next($request);
    }
}
<?php

namespace App\Http\Middleware;

use Illuminate\Foundation\Http\Middleware\TrimStrings as Middleware;

class TrimStrings extends Middleware
{
    /**
     * The names of the attributes that should not be trimmed.
     *
     * @var array<int, string>
     */
    protected $except = [
        'current_password',
        'password',
        'password_confirmation',
    ];
}
<?php

namespace App\Http\Middleware;

use Illuminate\Http\Middleware\TrustProxies as Middleware;
use Illuminate\Http\Request;

class TrustProxies extends Middleware
{
    /**
     * The trusted proxies for this application.
     *
     * @var array<int, string>|string|null
     */
    protected $proxies;

    /**
     * The headers that should be used to detect proxies.
     *
     * @var int
     */
    protected $headers =
        Request::HEADER_X_FORWARDED_FOR |
        Request::HEADER_X_FORWARDED_HOST |
        Request::HEADER_X_FORWARDED_PORT |
        Request::HEADER_X_FORWARDED_PROTO |
        Request::HEADER_X_FORWARDED_AWS_ELB;
}
<?php

namespace App\Http\Middleware;

use Illuminate\Routing\Middleware\ValidateSignature as Middleware;

class ValidateSignature extends Middleware
{
    /**
     * The names of the query string parameters that should be ignored.
     *
     * @var array<int, string>
     */
    protected $except = [
        // 'fbclid',
        // 'utm_campaign',
        // 'utm_content',
        // 'utm_medium',
        // 'utm_source',
        // 'utm_term',
    ];
}
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class ZoneAccessMiddleware
{
    /**
     * Handle an incoming request.
     * Verifies that the user has access to resources of a specific zone.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     * @param  string|null  $parameterName  The name of the route parameter containing the zone ID (default: 'zone')
     */
    public function handle(Request $request, Closure $next, ?string $parameterName = 'zone'): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        $user = auth()->user();

        // Super admins and national admins have access to all zones
        if (in_array($user->user_type, ['super_admin', 'national_admin'])) {
            return $next($request);
        }

        // Get zone ID from route parameter
        $zoneId = $request->route($parameterName);

        // If zone parameter is a model instance, get its ID
        if (is_object($zoneId) && method_exists($zoneId, 'getKey')) {
            $zoneId = $zoneId->getKey();
        }

        // Check if zone ID is provided
        if (!$zoneId) {
            abort(404, 'Zona non specificata.');
        }

        // Zone admins can only access their own zone
        if ($user->user_type === 'admin') {
            if ($user->zone_id != $zoneId) {
                abort(403, 'Non sei autorizzato ad accedere alle risorse di questa zona.');
            }
        }

        // Referees can only access resources from their zone (for zone-specific content)
        if ($user->user_type === 'referee') {
            if ($user->zone_id != $zoneId) {
                abort(403, 'Non puoi accedere alle risorse di altre zone.');
            }
        }

        return $next($request);
    }
}
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

class ZoneAdminMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        $user = auth()->user();

        // Allow access for zone admins and higher roles
        if (!in_array($user->user_type, ['admin', 'national_admin', 'super_admin'])) {
            abort(403, 'Accesso non autorizzato. Solo gli amministratori di zona possono accedere a questa sezione.');
        }

        return $next($request);
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Assignment;
use App\Models\Tournament;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;
use Carbon\Carbon;

class AssignmentController extends Controller
{
    /**
     * Display a listing of assignments.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin';

        $query = Assignment::with([
            'user:id,name,email,level,referee_code,zone_id',
            'tournament:id,name,start_date,end_date,club_id,tournament_type_id',
            'tournament.club:id,name',
            'tournament.tournamentType:id,name',
            'assignedBy:id,name'
        ]);

        // Filter by zone for non-national admins
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->whereHas('tournament', function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        // Apply filters
        if ($request->filled('tournament_id')) {
            $query->where('tournament_id', $request->tournament_id);
        }

        if ($request->filled('user_id')) {
            $query->where('user_id', $request->user_id);
        }

        if ($request->filled('status')) {
            if ($request->status === 'confirmed') {
                $query->where('is_confirmed', true);
            } elseif ($request->status === 'unconfirmed') {
                $query->where('is_confirmed', false);
            }
        }

        $assignments = $query
            ->join('tournaments', 'assignments.tournament_id', '=', 'tournaments.id')
            ->select('assignments.*')  // IMPORTANTE: seleziona solo da assignments
            ->orderBy('tournaments.start_date', 'desc')
            ->orderBy('assignments.created_at', 'desc')
            ->paginate(20);

        // Get data for filters
        $tournaments = Tournament::with('club')
            ->when(!$isNationalAdmin && $user->user_type !== 'super_admin', function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->orderBy('start_date', 'desc')
            ->get();

        $referees = User::where('user_type', 'referee')
            ->where('is_active', true)
            ->when(!$isNationalAdmin && $user->user_type !== 'super_admin', function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->orderBy('name')
            ->get();

        return view('admin.assignments.index', compact(
            'assignments',
            'tournaments',
            'referees',
            'isNationalAdmin'
        ));
    }

    /**
     * Show the form for creating a new assignment.
     */
    public function create(Request $request): View
    {
        $tournamentId = $request->get('tournament_id');
        $tournament = null;

        if ($tournamentId) {
            $tournament = Tournament::findOrFail($tournamentId);
            $this->checkTournamentAccess($tournament);
        }

        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';


        $query = Tournament::with(['club', 'tournamentType'])
            ->whereIn('status', ['open', 'closed', 'draft'])
            ->where('start_date', '>=', Carbon::today()->subDays(30));

        // FILTRO ZONA - versione corretta
        if (!$isNationalAdmin) {
            $query->where('zone_id', $user->zone_id);
        }

        $tournaments = $query->orderBy('start_date')->get();

        // ARBITRI SEPARATI PER DISPONIBILITÀ
        $tournamentId = $request->get('tournament_id');

        // Se un torneo è selezionato, separa arbitri per disponibilità
        // Nel metodo create(), modifica le query degli arbitri:
        if ($tournamentId) {
            $tournament = Tournament::with(['assignments.user'])->findOrFail($tournamentId);
            $this->checkTournamentAccess($tournament);

            $assignedRefereeIds = $tournament->assignments->pluck('user_id')->toArray();

            // CORRETTO ✅ - use only necessary relations
            $availableReferees = User::with(['zone'])
                ->whereHas('availabilities', function ($q) use ($tournamentId) {
                    $q->where('tournament_id', $tournamentId);
                })
                ->whereNotIn('id', $assignedRefereeIds)
                ->where('user_type', 'referee')
                ->where('is_active', true)
                ->orderBy('name')
                ->get();

            // Altri arbitri della zona NON già assegnati
            $otherReferees = User::with(['zone'])
                ->where('user_type', 'referee')
                ->where('is_active', true)
                ->where('zone_id', $user->zone_id)
                ->whereDoesntHave('availabilities', function ($q) use ($tournamentId) {
                    $q->where('tournament_id', $tournamentId);
                })
                ->whereNotIn('id', $assignedRefereeIds) // ESCLUDI già assegnati
                ->orderBy('name')
                ->get();
        } else {
            // Se nessun torneo selezionato, tutti gli arbitri della zona
            $availableReferees = collect();
            $otherReferees = User::with(['zone'])
                ->where('user_type', 'referee')
                ->where('is_active', true)
                ->where('zone_id', $user->zone_id)
                ->orderBy('name')
                ->get();
        }

        return view('admin.assignments.create', compact(
            'tournament',
            'tournaments',
            'availableReferees',
            'otherReferees'
        ));
    }

    /**
     * Store a newly created assignment.
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'tournament_id' => 'required|exists:tournaments,id',
            'user_id' => 'required|exists:users,id',
            'role' => 'required|in:Arbitro,Direttore di Torneo,Osservatore',
            'notes' => 'nullable|string|max:500',
        ]);

        $tournament = Tournament::findOrFail($request->tournament_id);
        $this->checkTournamentAccess($tournament);

        $referee = User::findOrFail($request->user_id);

        // NUOVO: Controlla se arbitro già assegnato
        if ($tournament->assignments()->where('user_id', $referee->id)->exists()) {
            return redirect()->back()
                ->with('error', "L'arbitro {$referee->name} è già assegnato a questo torneo con un altro ruolo.");
        }

        // Create assignment
        $assignment = Assignment::create([
            'tournament_id' => $tournament->id,
            'user_id' => $referee->id,
            'role' => $request->role,
            'notes' => $request->notes,
            'assigned_at' => now(),
            'assigned_by' => auth()->id(),
            'is_confirmed' => true, // SEMPRE confermato
        ]);

        return redirect()
            ->route('admin.assignments.create', ['tournament_id' => $tournament->id])
            ->with('success', "Arbitro {$referee->name} assegnato con successo come {$request->role}!");
    }

    /**
     * Display the specified assignment.
     */
    public function show(Assignment $assignment): View
    {
        $this->checkAssignmentAccess($assignment);

        $assignment->load([
            'user',
            'tournament.club',
            'tournament.zone',
            'tournament.tournamentType',
            'assignedBy'
        ]);

        return view('admin.assignments.show', compact('assignment'));
    }

    /**
     * Update the specified assignment.
     */
    public function update(Request $request, Assignment $assignment): RedirectResponse
    {
        $this->checkAssignmentAccess($assignment);

        $request->validate([
            'role' => 'required|in:Arbitro,Direttore di Torneo,Osservatore',
            'notes' => 'nullable|string|max:500',
        ]);

        $assignment->update([
            'role' => $request->role,
            'notes' => $request->notes,
        ]);

        return redirect()
            ->route('admin.assignments.show', $assignment)
            ->with('success', 'Assegnazione aggiornata con successo.');
    }

    /**
     * Confirm assignment.
     */
    public function confirm(Assignment $assignment): RedirectResponse
    {
        $this->checkAssignmentAccess($assignment);

        $assignment->update(['is_confirmed' => true]);

        return redirect()->back()
            ->with('success', 'Assegnazione confermata con successo.');
    }

    /**
     * Update destroy method to redirect back to tournament assignment if coming from there.
     */
    public function destroy(Assignment $assignment): RedirectResponse
    {
        $this->checkAssignmentAccess($assignment);

        $tournamentId = $assignment->tournament_id;
        $tournamentName = $assignment->tournament->name;
        $refereeName = $assignment->user->name;

        $assignment->delete();

        // Check if we came from tournament assignment page
        $referer = request()->headers->get('referer');
        if ($referer && str_contains($referer, '/assign')) {
            return redirect()
                ->route('admin.assignments.assign-referees', $tournamentId)
                ->with('success', "{$refereeName} rimosso dal comitato di gara di {$tournamentName}.");
        }

        // Default redirect to assignments list
        return redirect()
            ->route('admin.assignments.index')
            ->with('success', "Assegnazione di {$refereeName} al torneo {$tournamentName} rimossa con successo.");
    }


    /**
     * Check if user can access the tournament.
     */
    private function checkTournamentAccess(Tournament $tournament): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $tournament->zone_id !== $user->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere a questo torneo.');
        }
    }

    /**
     * Check if user can access the assignment.
     */
    private function checkAssignmentAccess(Assignment $assignment): void
    {
        $this->checkTournamentAccess($assignment->tournament);
    }


    /**
     * Get referees who declared availability for this tournament.
     */
    private function getAvailableReferees(Tournament $tournament)
    {
        return User::with(['referee', 'zone'])
            ->whereHas('availabilities', function ($q) use ($tournament) {
                $q->where('tournament_id', $tournament->id);
            })
            ->where('user_type', 'referee')
            ->where('is_active', true)
            ->orderBy('name')
            ->get();
    }

    /**
     * Get zone referees who haven't declared availability.
     */
    private function getPossibleReferees(Tournament $tournament, $excludeIds)
    {
        return User::with(['referee', 'zone'])
            ->where('user_type', 'referee')
            ->where('is_active', true)
            ->where('zone_id', $tournament->zone_id)
            ->whereNotIn('id', $excludeIds)
            ->whereDoesntHave('availabilities', function ($q) use ($tournament) {
                $q->where('tournament_id', $tournament->id);
            })
            ->orderBy('name')
            ->get();
    }

    /**
     * Get national/international referees (for national tournaments).
     */
    private function getNationalReferees(Tournament $tournament, $excludeIds)
    {
        return User::with(['referee', 'zone'])
            ->where('user_type', 'referee')
            ->where('is_active', true)
->whereIn('level', ['nazionale', 'internazionale'])
            ->whereNotIn('id', $excludeIds)
            ->orderBy('name')
            ->get();
    }

    /**
     * Show assignment interface for a specific tournament.
     */
    public function assignReferees(Tournament $tournament): View
    {
        $this->checkTournamentAccess($tournament);

        $user = auth()->user();
        $isNationalAdmin = in_array($user->user_type, ['national_admin', 'super_admin']);

        // Load tournament with relations
        // CORRETTO ✅
        $tournament->load(['club', 'zone', 'tournamentType']);

        // Get currently assigned referees - CORRETTO ✅
        $assignedReferees = $tournament->assignments()->with('user')->get();
        $assignedRefereeIds = $assignedReferees->pluck('user_id')->toArray();

        // Get available referees - CORRETTO ✅
        $availableReferees = User::with('zone')
            ->whereHas('availabilities', function ($q) use ($tournament) {
                $q->where('tournament_id', $tournament->id);
            })
            ->where('user_type', 'referee')
            ->where('is_active', true)
            ->whereNotIn('id', $assignedRefereeIds)
            ->orderBy('name')
            ->get();

        // Get possible referees (zone referees who haven't declared availability) - EXCLUDE already assigned
        $possibleReferees = User::with(['referee', 'zone'])
            ->where('user_type', 'referee')
            ->where('is_active', true)
            ->where('zone_id', $tournament->zone_id)
            ->whereDoesntHave('availabilities', function ($q) use ($tournament) {
                $q->where('tournament_id', $tournament->id);
            })
            ->whereNotIn('id', $assignedRefereeIds)
            ->orderBy('name')
            ->get();

        // Get national referees (for national tournaments) - EXCLUDE already assigned
        $nationalReferees = collect();
        if ($tournament->tournamentType->is_national) {
            $nationalReferees = User::with(['referee', 'zone'])
                ->where('user_type', 'referee')
                ->where('is_active', true)
                ->whereHas('referee', function ($q) {
                    $q->whereIn('level', ['nazionale', 'internazionale']);
                })
                ->whereNotIn('id', $assignedRefereeIds)
                ->whereNotIn('id', $availableReferees->pluck('id')->merge($possibleReferees->pluck('id')))
                ->orderBy('name')
                ->get();
        }

        // Check conflicts for all referees
        $this->checkDateConflicts($availableReferees, $tournament);
        $this->checkDateConflicts($possibleReferees, $tournament);
        $this->checkDateConflicts($nationalReferees, $tournament);

        return view('admin.assignments.assign-referees', compact(
            'tournament',
            'availableReferees',
            'possibleReferees',
            'nationalReferees',
            'assignedReferees',
            'isNationalAdmin'
        ));
    }

    /**
     * Assign multiple referees to tournament.
     */
    public function bulkAssign(Request $request): RedirectResponse
    {
        $request->validate([
            'tournament_id' => 'required|exists:tournaments,id',
            'referees' => 'required|array|min:1',
            'referees.*.user_id' => 'required|exists:users,id',
            'referees.*.role' => 'required|in:Arbitro,Direttore di Torneo,Osservatore',
            'referees.*.notes' => 'nullable|string|max:500',
        ]);

        $tournament = Tournament::findOrFail($request->tournament_id);
        $this->checkTournamentAccess($tournament);

        $assignedCount = 0;
        $errors = [];

        \DB::beginTransaction();
        try {
            // Process the referees array
            foreach ($request->referees as $key => $refereeData) {
                // Skip if not selected or missing data
                if (!isset($refereeData['selected']) || !isset($refereeData['user_id'])) {
                    continue;
                }

                $referee = User::findOrFail($refereeData['user_id']);

                // Check if already assigned
                if ($tournament->assignments()->where('user_id', $referee->id)->exists()) {
                    $errors[] = "{$referee->name} è già assegnato a questo torneo";
                    continue;
                }

                // Create assignment
                Assignment::create([
                    'tournament_id' => $tournament->id,
                    'user_id' => $referee->id,
                    'role' => $refereeData['role'],
                    'notes' => $refereeData['notes'] ?? null,
                    'assigned_at' => now(),
                    'assigned_by' => auth()->id(),
                    'is_confirmed' => true, // Always confirmed
                ]);

                $assignedCount++;
            }

            \DB::commit();

            $message = "{$assignedCount} arbitri assegnati con successo al torneo {$tournament->name}.";
            if (!empty($errors)) {
                $message .= " Errori: " . implode(', ', $errors);
            }

            return redirect()
                ->route('admin.assignments.assign-referees', $tournament)
                ->with('success', $message);
        } catch (\Exception $e) {
            \DB::rollback();

            return redirect()->back()
                ->with('error', 'Errore durante l\'assegnazione degli arbitri. Riprova.');
        }
    }

    /**
     * Check date conflicts for referees.
     */
    private function checkDateConflicts($referees, Tournament $tournament)
    {
        foreach ($referees as $referee) {
            $conflicts = Assignment::where('user_id', $referee->id)
                ->whereHas('tournament', function ($q) use ($tournament) {
                    $q->where('id', '!=', $tournament->id)
                        ->where(function ($q2) use ($tournament) {
                            // Tournament dates overlap
                            $q2->whereBetween('start_date', [$tournament->start_date, $tournament->end_date])
                                ->orWhereBetween('end_date', [$tournament->start_date, $tournament->end_date])
                                ->orWhere(function ($q3) use ($tournament) {
                                    $q3->where('start_date', '<=', $tournament->start_date)
                                        ->where('end_date', '>=', $tournament->end_date);
                                });
                        });
                })
                ->with('tournament:id,name,start_date,end_date')
                ->get();

            $referee->conflicts = $conflicts;
            $referee->has_conflicts = $conflicts->count() > 0;
        }
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use App\Models\Zone;
use App\Models\TournamentType;
use Illuminate\Http\Request;
use Illuminate\View\View;

class CalendarController extends Controller
{
    /**
     * Admin Calendar - Management focus
     */
    /**
     * Admin Calendar with comprehensive error handling
     */
    public function index(Request $request): View
    {
        try {
            $user = auth()->user();
            $isNationalAdmin = $user->user_type === 'national_admin';

            // Validate user permissions
            if (!in_array($user->user_type, ['admin', 'national_admin', 'super_admin'])) {
                \Log::warning('Unauthorized calendar access attempt', [
                    'user_id' => $user->id,
                    'user_type' => $user->user_type,
                    'ip' => $request->ip()
                ]);

                abort(403, 'Non hai i permessi per accedere al calendario amministrativo.');
            }

            // Validate zone for non-national admins
            if (!$isNationalAdmin && !$user->zone_id) {
                \Log::error('Admin user without zone_id trying to access calendar', [
                    'user_id' => $user->id,
                    'user_type' => $user->user_type
                ]);

                return view('admin.calendar', [
                    'calendarData' => $this->getEmptyCalendarData('error'),
                    'isNationalAdmin' => false,
                    'error' => 'Il tuo account non ha una zona assegnata. Contatta l\'amministratore di sistema.'
                ]);
            }

            // Get tournaments with error handling
            $tournaments = $this->getTournamentsWithErrorHandling($user, $isNationalAdmin);

            // Get filter data with error handling
            $zones = $this->getZonesWithErrorHandling($isNationalAdmin);
            $tournamentTypes = $this->getTournamentTypesWithErrorHandling();

            // Build calendar data
            $calendarData = $this->buildCalendarData($tournaments, $zones, $tournamentTypes, $user);

            // \Log successful access
            \Log::info('Admin calendar accessed successfully', [
                'user_id' => $user->id,
                'tournaments_count' => $tournaments->count(),
                'is_national_admin' => $isNationalAdmin
            ]);

            return view('admin.calendar', compact('calendarData', 'isNationalAdmin'));

        } catch (Exception $e) {
            // \Log the error
            \Log::error('Admin calendar error', [
                'user_id' => auth()->id(),
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            // Return error state
            return view('admin.calendar', [
                'calendarData' => $this->getEmptyCalendarData('error'),
                'isNationalAdmin' => false,
                'error' => 'Si è verificato un errore nel caricamento del calendario. Riprova più tardi.'
            ]);
        }
    }

    /**
     * Get tournaments with comprehensive error handling
     */
    private function getTournamentsWithErrorHandling($user, $isNationalAdmin)
    {
        try {
            $query = Tournament::with(['tournamentType', 'zone', 'club', 'assignments', 'availabilities']);

            // Apply zone filter for non-national admins
            if (!$isNationalAdmin) {
                if (!$user->zone_id) {
                    throw new Exception('Admin user missing zone_id');
                }
                $query->where('zone_id', $user->zone_id);
            }

            $tournaments = $query->get();

            // Validate relationships
            foreach ($tournaments as $tournament) {
                if (!$tournament->tournamentCategory) {
                    \Log::warning('Tournament missing category', ['tournament_id' => $tournament->id]);
                }
                if (!$tournament->zone) {
                    \Log::warning('Tournament missing zone', ['tournament_id' => $tournament->id]);
                }
                if (!$tournament->club) {
                    \Log::warning('Tournament missing club', ['tournament_id' => $tournament->id]);
                }
            }

            return $tournaments;

        } catch (Exception $e) {
            \Log::error('Error fetching tournaments for admin calendar', [
                'user_id' => $user->id,
                'error' => $e->getMessage()
            ]);

            // Return empty collection on error
            return collect();
        }
    }

    /**
     * Get zones with error handling
     */
    private function getZonesWithErrorHandling($isNationalAdmin)
    {
        try {
            return $isNationalAdmin ? Zone::orderBy('name')->get() : collect();
        } catch (Exception $e) {
            \Log::error('Error fetching zones for admin calendar', ['error' => $e->getMessage()]);
            return collect();
        }
    }

    /**
     * Get tournament types with error handling
     */
    private function getTournamentTypesWithErrorHandling()
    {
        try {
            return TournamentType::orderBy('name')->get();
        } catch (Exception $e) {
            \Log::error('Error fetching tournament types for admin calendar', ['error' => $e->getMessage()]);
            return collect();
        }
    }

    /**
     * Build calendar data with validation
     */
    private function buildCalendarData($tournaments, $zones, $tournamentTypes, $user)
    {
        try {
            return [
                'tournaments' => $tournaments->map(function ($tournament) {
                    return $this->formatTournamentWithValidation($tournament);
                }),
                'userType' => 'admin',
                'userRoles' => [$user->user_type],
                'canModify' => true,
                'zones' => $zones,
                'types' => $tournamentTypes,
                'clubs' => collect(),
                'availabilities' => [],
                'assignments' => [],
                'totalTournaments' => $tournaments->count(),
                'lastUpdated' => now()->toISOString(),
            ];
        } catch (Exception $e) {
            \Log::error('Error building calendar data', ['error' => $e->getMessage()]);
            return $this->getEmptyCalendarData('error');
        }
    }

    /**
     * Format tournament data with validation
     */
    private function formatTournamentWithValidation($tournament)
    {
        try {
            // Validate required fields
            $title = $tournament->name ?: "Torneo #{$tournament->id}";
            $startDate = $tournament->start_date ?: now();
            $endDate = $tournament->end_date ?: $startDate;

            // Safely get related data
            $club = $tournament->club ? $tournament->club->name : 'Club non specificato';
            $zone = $tournament->zone ? $tournament->zone->name : 'Zona non specificata';
            $category = $tournament->tournamentCategory ? $tournament->tournamentCategory->name : 'Categoria non specificata';

            return [
                'id' => $tournament->id,
                'title' => $title,
                'start' => $startDate->format('Y-m-d'),
                'end' => $endDate->addDay()->format('Y-m-d'),
                'color' => $this->getEventColorSafe($tournament),
                'borderColor' => $this->getAdminBorderColorSafe($tournament),
                'extendedProps' => [
                    'club' => $club,
                    'zone' => $zone,
                    'zone_id' => $tournament->zone_id,
                    'category' => $category,
                    'status' => $tournament->status ?: 'unknown',
                    'tournament_url' => route('admin.tournaments.show', $tournament),
                    'deadline' => $tournament->availability_deadline?->format('d/m/Y') ?? 'Non specificata',
                    'days_until_deadline' => $tournament->days_until_deadline ?? 0,
                    'type_id' => $tournament->tournament_type_id,
                    'type' => $tournament->tournamentCategory,
                    'availabilities_count' => $tournament->availabilities()->count(),
                    'assignments_count' => $tournament->assignments()->count(),
                    'required_referees' => $tournament->required_referees ?? 1,
                    'max_referees' => $tournament->max_referees ?? 4,
                    'management_priority' => $this->getManagementPrioritySafe($tournament),
                ],
            ];

        } catch (Exception $e) {
            \Log::error('Error formatting tournament', [
                'tournament_id' => $tournament->id ?? 'unknown',
                'error' => $e->getMessage()
            ]);

            // Return minimal safe tournament data
            return [
                'id' => $tournament->id ?? 0,
                'title' => 'Torneo (errore dati)',
                'start' => now()->format('Y-m-d'),
                'end' => now()->addDay()->format('Y-m-d'),
                'color' => '#6B7280',
                'borderColor' => '#EF4444',
                'extendedProps' => [
                    'club' => 'Errore dati',
                    'zone' => 'Errore dati',
                    'category' => 'Errore dati',
                    'status' => 'error',
                    'error' => 'Dati torneo incompleti'
                ],
            ];
        }
    }

    /**
     * Safe color methods with fallbacks
     */
    private function getEventColorSafe($tournament): string
    {
        try {
            return $this->getEventColor($tournament);
        } catch (Exception $e) {
            return '#6B7280'; // Default gray
        }
    }

    private function getAdminBorderColorSafe($tournament): string
    {
        try {
            return $this->getAdminBorderColor($tournament);
        } catch (Exception $e) {
            return '#EF4444'; // Default red for errors
        }
    }

    private function getManagementPrioritySafe($tournament): string
    {
        try {
            return $this->getManagementPriority($tournament);
        } catch (Exception $e) {
            return 'unknown';
        }
    }

    /**
     * Get empty calendar data for error states
     */
    private function getEmptyCalendarData($reason = 'empty'): array
    {
        return [
            'tournaments' => collect(),
            'userType' => 'admin',
            'userRoles' => ['admin'],
            'canModify' => false,
            'zones' => collect(),
            'types' => collect(),
            'clubs' => collect(),
            'availabilities' => [],
            'assignments' => [],
            'totalTournaments' => 0,
            'lastUpdated' => now()->toISOString(),
            'error_state' => $reason,
        ];
    }


    /**
     * Get event color based on tournament type
     * TODO: Replace with your actual category color logic
     */
    private function getEventColor($tournament): string
    {
        return match($tournament->tournamentCategory->name ?? 'default') {
            'Categoria A' => '#FF6B6B',
            'Categoria B' => '#4ECDC4',
            'Categoria C' => '#45B7D1',
            'Categoria D' => '#96CEB4',
            default => '#3B82F6'
        };
    }

    /**
     * Admin border color - based on tournament status
     */
    private function getAdminBorderColor($tournament): string
    {
        return match($tournament->status) {
            'published' => '#10B981',   // Green
            'draft' => '#F59E0B',       // Amber
            'closed' => '#6B7280',      // Gray
            'cancelled' => '#EF4444',   // Red
            default => '#6B7280'        // Gray default
        };
    }

    /**
     * Calculate management priority for admin focus
     */
    private function getManagementPriority($tournament): string
    {
        $availabilities = $tournament->availabilities()->count();
        $assignments = $tournament->assignments()->count();
        $required = $tournament->required_referees ?? $tournament->tournamentCategory->min_referees ?? 1;
        $daysUntilDeadline = $tournament->days_until_deadline ?? 999;

        // Urgent: Missing referees or overdue deadline
        if ($daysUntilDeadline < 0 || $assignments < $required) {
            return 'urgent';
        }

        // Complete: Fully staffed
        if ($assignments >= $required) {
            return 'complete';
        }

        // In progress: Has some availability/assignments but not complete
        if ($availabilities > 0 || $assignments > 0) {
            return 'in_progress';
        }

        // Open: Ready for availability submissions
        return 'open';
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Club;
use App\Models\Zone;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;
use App\Http\Traits\CrudActions;

class ClubController extends Controller
{
    use CrudActions;

    /**
     * Display a listing of clubs.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        $query = Club::with(['zone']);

        // Filter by zone for non-national admins
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        // Apply search filter
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('code', 'like', "%{$search}%")
                    ->orWhere('city', 'like', "%{$search}%");
            });
        }

        // Apply zone filter
        if ($request->filled('zone_id')) {
            $query->where('zone_id', $request->zone_id);
        }

        // Apply status filter
        if ($request->filled('status')) {
            $query->where('is_active', $request->status === 'active');
        }

        $clubs = $query
            ->withCount('tournaments')
            ->orderBy('is_active', 'desc')
            ->orderBy('name')
            ->paginate(20)
            ->withQueryString();

        // Get zones for filter
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        return view('admin.clubs.index', compact('clubs', 'zones', 'isNationalAdmin'));
    }

    /**
     * Show the form for creating a new club.
     */
    public function create(): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        return view('admin.clubs.create', compact('zones'));
    }

    /**
     * Store a newly created club in storage.
     */
    public function store(Request $request): RedirectResponse
    {
        $user = auth()->user();

        $request->validate([
            'name' => 'required|string|max:255',
            'code' => 'required|string|max:50|unique:clubs,code',
            'zone_id' => 'required|exists:zones,id',
            'city' => 'required|string|max:100',
            'province' => 'nullable|string|max:2',
            'email' => 'nullable|email|max:255',
            'phone' => 'nullable|string|max:20',
            'address' => 'nullable|string|max:255',
            'contact_person' => 'nullable|string|max:255',
            'notes' => 'nullable|string',
            'is_active' => 'boolean',
        ]);

        // Check zone access for non-national admins
        if ($user->user_type === 'admin' && $request->zone_id != $user->zone_id) {
            abort(403, 'Non puoi creare club in zone diverse dalla tua.');
        }

        $club = Club::create($request->all());

        return redirect()
            ->route('admin.clubs.index')
            ->with('success', "Club \"{$club->name}\" creato con successo!");
    }

    /**
     * Display the specified club.
     */
    public function show(Club $club): View
    {
        $this->checkClubAccess($club);

        $club->load(['zone', 'tournaments.tournamentCategory']);

        // Get statistics
        $stats = [
            'total_tournaments' => $club->tournaments()->count(),
            'upcoming_tournaments' => $club->tournaments()->upcoming()->count(),
            'active_tournaments' => $club->tournaments()->active()->count(),
            'completed_tournaments' => $club->tournaments()->where('status', 'completed')->count(),
        ];

        // Get recent tournaments
        $recentTournaments = $club->tournaments()
            ->with(['tournamentType', 'zone'])
            ->orderBy('start_date', 'desc')
            ->limit(10)
            ->get();

        return view('admin.clubs.show', compact('club', 'stats', 'recentTournaments'));
    }

    /**
     * Show the form for editing the specified club.
     */
    public function edit(Club $club): View
    {
        $this->checkClubAccess($club);

        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        return view('admin.clubs.edit', compact('club', 'zones'));
    }

    /**
     * Update the specified club in storage.
     */
    public function update(Request $request, Club $club): RedirectResponse
    {
        $this->checkClubAccess($club);

        $user = auth()->user();

        $request->validate([
            'name' => 'required|string|max:255',
            'code' => 'required|string|max:50|unique:clubs,code,' . $club->id,
            'zone_id' => 'required|exists:zones,id',
            'city' => 'required|string|max:100',
            'province' => 'nullable|string|max:2',
            'email' => 'nullable|email|max:255',
            'phone' => 'nullable|string|max:20',
            'address' => 'nullable|string|max:255',
            'contact_person' => 'nullable|string|max:255',
            'notes' => 'nullable|string',
            'is_active' => 'boolean',
        ]);

        // Check zone access for non-national admins
        if ($user->user_type === 'admin' && $request->zone_id != $user->zone_id) {
            abort(403, 'Non puoi spostare club in zone diverse dalla tua.');
        }

        $club->update($request->all());

        return redirect()
            ->route('admin.clubs.show', $club)
            ->with('success', "Club \"{$club->name}\" aggiornato con successo!");
    }

    /**
     * Remove the specified club from storage.
     */
    public function destroy(Club $club): RedirectResponse
    {
        $this->checkClubAccess($club);

        if (!$club->canBeDeleted()) {
            return redirect()
                ->route('admin.clubs.index')
                ->with('error', 'Impossibile eliminare un club con tornei associati.');
        }

        $name = $club->name;
        $club->delete();

        return redirect()
            ->route('admin.clubs.index')
            ->with('success', "Club \"{$name}\" eliminato con successo!");
    }

    /**
     * Toggle club active status.
     */
    public function toggleActive(Club $club): RedirectResponse
    {
        $this->checkClubAccess($club);

        $club->update(['is_active' => !$club->is_active]);

        $status = $club->is_active ? 'attivato' : 'disattivato';

        return redirect()->back()
            ->with('success', "Club \"{$club->name}\" {$status} con successo!");
    }

    /**
     * Get clubs for a specific zone (AJAX).
     */
    public function getClubsByZone(Request $request)
    {
        $request->validate([
            'zone_id' => 'required|exists:zones,id',
        ]);

        $user = auth()->user();

        // Check zone access for non-national admins
        if ($user->user_type === 'admin' && $request->zone_id != $user->zone_id) {
            return response()->json([], 403);
        }

        $clubs = Club::active()
            ->where('zone_id', $request->zone_id)
            ->ordered()
            ->get(['id', 'name', 'code']);

        return response()->json($clubs);
    }
    public function deactivate(Club $club)
    {
        $club->update(['is_active' => false]);

        return redirect()
            ->route('admin.clubs.index')
            ->with('success', 'Club disattivato con successo.');
    }
    /**
     * Check if user can access the club.
     */
    private function checkClubAccess(Club $club): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $club->zone_id !== $user->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere a questo club.');
        }
    }
    protected function getEntityName($model): string
    {
        return 'Club';
    }

    protected function getIndexRoute(): string
    {
        return 'admin.clubs.index';
    }

    protected function getDeleteErrorMessage($model): string
    {
        return 'Impossibile eliminare un club con tornei associati.';
    }

    protected function canBeDeleted($club): bool
    {
        return !$club->tournaments()->exists();
    }

    protected function checkAccess($club): void
    {
        $this->checkClubAccess($club);
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class CommunicationController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use App\Models\User;
use App\Models\Assignment;
use Illuminate\View\View;
use Carbon\Carbon;

class DashboardController extends Controller
{
    /**
     * Display the admin dashboard.
     */
    public function index(): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin';

        // Get statistics based on user access
        $stats = $this->getStatistics($user, $isNationalAdmin);

        // Get alerts (unconfirmed assignments, tournaments needing referees, etc.)
        $alerts = $this->getAlerts($user, $isNationalAdmin);

        // Get tournaments that need referees
        $tournamentsNeedingReferees = $this->getTournamentsNeedingReferees($user, $isNationalAdmin);

        // Get recent assignments
        $recentAssignments = $this->getRecentAssignments($user, $isNationalAdmin);

        return view('admin.dashboard', compact(
            'isNationalAdmin',
            'stats',
            'alerts',
            'tournamentsNeedingReferees',
            'recentAssignments'
        ));
    }

    /**
     * Get statistics for the dashboard.
     */
    private function getStatistics($user, $isNationalAdmin): array
    {
        $query = Tournament::query();

        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        $totalTournaments = $query->count();
        $activeTournaments = (clone $query)->whereIn('status', ['open', 'closed', 'assigned'])->count();
        $completedTournaments = (clone $query)->where('status', 'completed')->count();

        $assignmentQuery = Assignment::query();
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $assignmentQuery->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        $totalAssignments = $assignmentQuery->count();
        $pendingConfirmations = (clone $assignmentQuery)->where('is_confirmed', false)->count();

        $refereeQuery = User::where('user_type', 'referee')->where('is_active', true);
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $refereeQuery->where('zone_id', $user->zone_id);
        }

        $activeReferees = $refereeQuery->count();

        return [
            'total_tournaments' => $totalTournaments,
            'active_tournaments' => $activeTournaments,
            'completed_tournaments' => $completedTournaments,
            'total_assignments' => $totalAssignments,
            'pending_confirmations' => $pendingConfirmations,
            'active_referees' => $activeReferees,
            'zones_count' => $isNationalAdmin ? \App\Models\Zone::count() : 1,
            'upcoming_tournaments' => (clone $query)->where('start_date', '>=', Carbon::today())->count(),
        ];
    }

    /**
     * Get alerts for the dashboard.
     */
    private function getAlerts($user, $isNationalAdmin): array
    {
        $alerts = [];

        // Check for tournaments needing referees
        $tournamentsNeedingReferees = $this->getTournamentsNeedingReferees($user, $isNationalAdmin)->count();
        if ($tournamentsNeedingReferees > 0) {
            $alerts[] = [
                'type' => 'warning',
                'message' => "Ci sono {$tournamentsNeedingReferees} tornei che necessitano di arbitri."
            ];
        }

        // Check for unconfirmed assignments
        $assignmentQuery = Assignment::where('is_confirmed', false);
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $assignmentQuery->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }
        $unconfirmedAssignments = $assignmentQuery->count();

        if ($unconfirmedAssignments > 0) {
            $alerts[] = [
                'type' => 'info',
                'message' => "Ci sono {$unconfirmedAssignments} assegnazioni in attesa di conferma."
            ];
        }

        return $alerts;
    }

    /**
     * Get tournaments that need referees.
     */
    private function getTournamentsNeedingReferees($user, $isNationalAdmin)
    {
        $query = Tournament::with(['club', 'tournamentType'])
            ->whereIn('status', ['open', 'closed'])
            ->where('start_date', '>=', Carbon::today());

        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        // Filter tournaments that need more referees
        return $query->get()->filter(function ($tournament) {
            $assignedReferees = $tournament->assignments()->count();
            $requiredReferees = $tournament->tournamentCategory->max_referees ?? 1;
            return $assignedReferees < $requiredReferees;
        })->take(10);
    }

    /**
     * Get recent assignments.
     */
    private function getRecentAssignments($user, $isNationalAdmin)
    {
        $query = Assignment::with(['user', 'tournament.club', 'assignedBy'])
            ->orderBy('created_at', 'desc');

        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        return $query->limit(10)->get();
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class NotificationController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Models\Referee;
use App\Models\Zone;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;

class RefereeController extends Controller
{
    /**
     * Display a listing of referees.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        $query = User::where('user_type', 'referee')
            ->with(['zone'])
            ->withCount(['assignments', 'availabilities']);

        // Filter by zone for non-national admins
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        // Apply search filter
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('email', 'like', "%{$search}%")
                    ->orWhere('referee_code', 'like', "%{$search}%");
            });
        }

        // Apply zone filter
        if ($request->filled('zone_id')) {
            $query->where('zone_id', $request->zone_id);
        }

        // Apply level filter
        if ($request->filled('level')) {
            $query->where('level', $request->level);
        }

        // Apply status filter
        if ($request->filled('status')) {
            $query->where('is_active', $request->status === 'active');
        }

        $referees = $query
            ->orderBy('is_active', 'desc')
            ->orderBy('name')
            ->paginate(20)
            ->withQueryString();

        // Get zones and levels for filters
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        $levels = [
            'aspirante' => 'Aspirante',
            'primo_livello' => 'Primo Livello',
            'regionale' => 'Regionale',
            'nazionale' => 'Nazionale',
            'internazionale' => 'Internazionale',
        ];

        return view('admin.referees.index', compact('referees', 'zones', 'levels', 'isNationalAdmin'));
    }

    /**
     * Show the form for creating a new referee.
     */
    public function create()
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        // Get referee levels from User model
        $levels = User::REFEREE_LEVELS;

        // Get zones based on user permissions
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        return view('admin.referees.create', compact('levels', 'zones'));
    }

    /**
     * Store a newly created referee in storage.
     */
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'phone' => 'nullable|string|max:20',
            'level' => 'required|string',
            'zone_id' => 'required|exists:zones,id',
            'notes' => 'nullable|string',
            'is_active' => 'boolean'
        ]);

        try {
            \DB::beginTransaction();

            $refereeCode = 'REF' . str_pad($user->id, 4, '0', STR_PAD_LEFT);
            // ✅ CREA SOLO L'USER con TUTTI i dati:
            $user = User::create([
                'name' => $request->name,
                'email' => $request->email,
                'password' => bcrypt('password123'),
                'user_type' => 'referee',
                'zone_id' => $request->zone_id,
                'phone' => $request->phone,
                'level' => $request->level,           // ← AGGIUNGI
                'referee_code' => $refereeCode,      // ← AGGIUNGI
                'notes' => $request->notes,          // ← AGGIUNGI
                'is_active' => $request->boolean('is_active', true),
                'email_verified_at' => now(),
            ]);

            \DB::commit();

            return redirect()
                ->route('admin.referees.index')
                ->with('success', "Arbitro {$user->name} creato con successo! Codice: {$refereeCode}");
        } catch (\Exception $e) {
            \DB::rollback();

            return redirect()
                ->back()
                ->withInput()
                ->with('error', 'Errore durante la creazione dell\'arbitro: ' . $e->getMessage());
        }
    }

    /**
     * Display the specified referee.
     */
    public function show(User $referee): View
    {
        if (!$referee->isReferee()) {
            abort(404, 'Arbitro non trovato.');
        }

        $this->checkRefereeAccess($referee);

        $referee->load([
            'zone',
            'assignments.tournament.club',
            'availabilities.tournament.club'
        ]);

        // Get statistics
        $stats = [
            'total_assignments' => $referee->assignments()->count(),
            'confirmed_assignments' => $referee->assignments()->where('is_confirmed', true)->count(),
            'current_year_assignments' => $referee->assignments()->whereYear('created_at', now()->year)->count(),
            'total_availabilities' => $referee->availabilities()->count(),
            'upcoming_assignments' => $referee->assignments()->upcoming()->count(),
        ];

        // Get recent assignments and availabilities
        $recentAssignments = $referee->assignments()
            ->with(['tournament.club'])
            ->orderBy('created_at', 'desc')
            ->limit(10)
            ->get();

        $recentAvailabilities = $referee->availabilities()
            ->with(['tournament.club'])
            ->orderBy('created_at', 'desc')
            ->limit(10)
            ->get();

        return view('admin.referees.show', compact('referee', 'stats', 'recentAssignments', 'recentAvailabilities'));
    }

    /**
     * Show the form for editing the specified referee.
     */
public function edit($id)
{
    // ✅ COME ERA PRIMA - trova User, crea Referee se serve
    $user = User::where('user_type', 'referee')->findOrFail($id);
    $referee = $user->referee;

    if (!$referee) {
        $referee = Referee::create([
            'user_id' => $user->id,
            'zone_id' => $user->zone_id,
            'referee_code' => $user->referee_code ?: 'REF' . str_pad($user->id, 4, '0', STR_PAD_LEFT),
            'level' => $user->level ?: 'primo_livello',
            'category' => 'misto',
            'certified_date' => now(),
        ]);
    }

    // ✅ CARICA LA RELAZIONE USER
    $referee->load('user');

    $levels = [
        'aspirante' => 'Aspirante',
        'primo_livello' => 'Primo Livello',
        'regionale' => 'Regionale',
        'nazionale' => 'Nazionale',
        'internazionale' => 'Internazionale'
    ];

    $zones = Zone::all();

    return view('admin.referees.edit', compact('referee', 'levels', 'zones'));
}

    /**
     * Update the specified referee.
     */
    public function update(Request $request, User $referee): RedirectResponse
    {
        if (!$referee->isReferee()) {
            abort(404, 'Arbitro non trovato.');
        }

        $this->checkRefereeAccess($referee);

        $user = auth()->user();

        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|email|max:255|unique:users,email,' . $referee->id,
            'phone' => 'nullable|string|max:20',
            'city' => 'nullable|string|max:100',
            'zone_id' => 'required|exists:zones,id',
            'level' => 'required|in:aspirante,primo_livello,regionale,nazionale,internazionale',
            'referee_code' => 'nullable|string|max:20', // ✅ CAMBIATO da required
            'is_active' => 'boolean',
        ]);

        // Check zone access for non-national admins
        if ($user->user_type === 'admin' && $request->zone_id != $user->zone_id) {
            abort(403, 'Non puoi spostare arbitri in zone diverse dalla tua.');
        }

        // ✅ AGGIORNA SOLO I CAMPI SPECIFICI invece di $request->all()
        $referee->update([
            'name' => $request->name,
            'email' => $request->email,
            'phone' => $request->phone,
            'city' => $request->city,
            'zone_id' => $request->zone_id,
            'level' => $request->level,
            'referee_code' => $request->referee_code ?: $referee->referee_code,
            'is_active' => $request->boolean('is_active', true),
        ]);

        return redirect()
            ->route('admin.referees.show', $referee)
            ->with('success', "Arbitro \"{$referee->name}\" aggiornato con successo!");
    }

    /**
     * Toggle referee active status.
     */
    public function toggleActive(User $referee): RedirectResponse
    {
        if (!$referee->isReferee()) {
            abort(404, 'Arbitro non trovato.');
        }

        $this->checkRefereeAccess($referee);

        $referee->update(['is_active' => !$referee->is_active]);

        $status = $referee->is_active ? 'attivato' : 'disattivato';

        return redirect()->back()
            ->with('success', "Arbitro \"{$referee->name}\" {$status} con successo!");
    }

    /**
     * Remove the specified referee.
     */
    public function destroy(User $referee): RedirectResponse
    {
        if (!$referee->isReferee()) {
            abort(404, 'Arbitro non trovato.');
        }

        $this->checkRefereeAccess($referee);

        // Check if referee has active assignments
        if ($referee->assignments()->whereHas('tournament', function ($q) {
            $q->whereIn('status', ['open', 'closed', 'assigned']);
        })->exists()) {
            return redirect()
                ->route('admin.referees.index')
                ->with('error', 'Impossibile eliminare un arbitro con assegnazioni attive.');
        }

        $name = $referee->name;
        $referee->delete();

        return redirect()
            ->route('admin.referees.index')
            ->with('success', "Arbitro \"{$name}\" eliminato con successo!");
    }

    /**
     * Check if user can access the referee.
     */
    private function checkRefereeAccess(User $referee): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $referee->zone_id !== $user->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere a questo arbitro.');
        }
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Http\Requests\TournamentRequest;
use App\Models\Tournament;
use App\Models\TournamentType; // ✅ FIXED: Changed from TournamentCategory
use App\Models\club;
use App\Models\Zone;
use Carbon\Carbon;
use Illuminate\Http\Request;
use App\Http\Traits\CrudActions;

class TournamentController extends Controller
{
    use CrudActions;

    /**
     * Display a listing of tournaments.
     */
    public function index(Request $request)
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        // Base query - ✅ FIXED: tournamentType relationship
        $query = Tournament::with(['tournamentType', 'zone', 'club', 'assignments']);

        // Filter by zone for zone admins
        if (!$isNationalAdmin && !in_array($user->user_type, ['super_admin'])) {
            $query->where('zone_id', $user->zone_id);
        }

        // Apply filters
        if ($request->has('status') && $request->status !== '') {
            $query->where('status', $request->status);
        }

        if ($request->has('zone_id') && $request->zone_id !== '') {
            $query->where('zone_id', $request->zone_id);
        }

        // ✅ FIXED: tournament_type_id filter name
        if ($request->has('tournament_type_id') && $request->tournament_type_id !== '') {
            $query->where('tournament_type_id', $request->tournament_type_id);
        }

        if ($request->has('month') && $request->month !== '') {
            $startOfMonth = Carbon::parse($request->month)->startOfMonth();
            $endOfMonth = Carbon::parse($request->month)->endOfMonth();
            $query->where(function ($q) use ($startOfMonth, $endOfMonth) {
                $q->whereBetween('start_date', [$startOfMonth, $endOfMonth])
                    ->orWhereBetween('end_date', [$startOfMonth, $endOfMonth]);
            });
        }

        // Search
        if ($request->has('search') && $request->search !== '') {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhereHas('club', function ($q2) use ($search) {
                        $q2->where('name', 'like', "%{$search}%");
                    });
            });
        }

        // Order by start date descending
        $tournaments = $query->orderBy('start_date', 'desc')->paginate(20);

        // Get data for filters
        $zones = $isNationalAdmin ? Zone::orderBy('name')->get() : collect();

        // ✅ FIXED: Variable name from $categories to $tournamentTypes
        $tournamentTypes = TournamentType::active()->ordered()->get();
        $statuses = Tournament::STATUSES;

        // ✅ FIXED: compact() uses tournamentTypes instead of categories
        return view('admin.tournaments.index', compact(
            'tournaments',
            'zones',
            'tournamentTypes', // ← FIXED: was 'categories'
            'statuses',
            'isNationalAdmin'
        ));
    }

    /**
     * Show tournaments calendar view
     */
    public function calendar(Request $request)
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin' || $user->user_type === 'admin';

        // ✅ FIXED: tournamentType relationship
        $tournaments = Tournament::with(['tournamentType', 'zone', 'club', 'assignments.user'])
            ->when(!$isNationalAdmin && !in_array($user->user_type, ['super_admin']), function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->get();

        // Get zones for filter
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        // Get clubs for filter
        $clubs = \App\Models\Club::active()
            ->when(!$isNationalAdmin && !in_array($user->user_type, ['super_admin']), function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->orderBy('name')
            ->get();

        // ✅ FIXED: Variable name from $types to $tournamentTypes
        $tournamentTypes = TournamentType::active()->ordered()->get();

        // User roles for permissions
        $userRoles = ['Admin'];
        if ($user->user_type === 'super_admin') {
            $userRoles[] = 'SuperAdmin';
        } elseif ($user->user_type === 'national_admin') {
            $userRoles[] = 'NationalAdmin';
        }

        // Format tournaments for calendar
        $calendarTournaments = $tournaments->map(function ($tournament) {
            return [
                'id' => $tournament->id,
                'title' => $tournament->name,
                'start' => $tournament->start_date->format('Y-m-d'),
                'end' => $tournament->end_date->addDay()->format('Y-m-d'),
                'color' => '#3b82f6', // Default color
                'borderColor' => '#1e40af',
                'extendedProps' => [
                    'club' => $tournament->club->name ?? 'N/A',
                    'zone' => $tournament->zone->name ?? 'N/A',
                    'zone_id' => $tournament->zone_id,
                    // ✅ FIXED: tournamentType relationship
                    'category' => $tournament->tournamentType->name ?? 'N/A',
                    'status' => $tournament->status,
                    'tournament_url' => route('admin.tournaments.show', $tournament),
                    'deadline' => $tournament->availability_deadline?->format('d/m/Y') ?? 'N/A',
                    'type_id' => $tournament->tournament_type_id,
                    'availabilities_count' => $tournament->availabilities()->count(),
                    'assignments_count' => $tournament->assignments()->count(),
                    'required_referees' => $tournament->required_referees ?? 1,
                    'max_referees' => $tournament->max_referees ?? 4,
                    'management_priority' => 'open',
                ],
            ];
        });

        // Prepare data for React component
        $calendarData = [
            'tournaments' => $calendarTournaments,
            'zones' => $zones->map(function ($zone) {
                return [
                    'id' => $zone->id,
                    'name' => $zone->name,
                ];
            }),
            'clubs' => $clubs->map(function ($club) {
                return [
                    'id' => $club->id,
                    'name' => $club->name,
                    'zone_id' => $club->zone_id,
                ];
            }),
            // ✅ FIXED: tournamentTypes instead of types
            'tournamentTypes' => $tournamentTypes->map(function ($type) {
                return [
                    'id' => $type->id,
                    'name' => $type->name,
                    'code' => $type->code,
                    'is_national' => $type->is_national,
                ];
            }),
            'userRoles' => $userRoles,
            'userType' => 'admin',
            'canModify' => true,
        ];

        return view('admin.tournaments.calendar', compact('calendarData'));
    }

    /**
     * Show the form for creating a new tournament.
     */
    public function create()
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        // ✅ FIXED: Variable name and model reference
        $tournamentTypes = TournamentType::active()
            ->when(!$isNationalAdmin, function ($q) use ($user) {
                $q->where(function ($q2) use ($user) {
                    $q2->where('is_national', false)
                        ->whereJsonContains('settings->visibility_zones', $user->zone_id);
                })->orWhere('is_national', true);
            })
            ->ordered()
            ->get();

        // Get zones
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        // Get clubs for the selected zone
        $clubs = club::active()
            ->when(!$isNationalAdmin, function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->ordered()
            ->get();

        // ✅ FIXED: compact() uses tournamentTypes
        return view('admin.tournaments.create', compact('tournamentTypes', 'zones', 'clubs'));
    }

    /**
     * Store a newly created tournament in storage.
     */
    public function store(TournamentRequest $request)
    {
        $data = $request->validated();

        // Set zone_id from club if not national admin
        if (auth()->user()->user_type !== 'national_admin') {
            $club = club::findOrFail($data['club_id']);
            $data['zone_id'] = $club->zone_id;
        }

        // Create tournament
        $tournament = Tournament::create($data);

        return redirect()
            ->route('tournaments.show', $tournament)
            ->with('success', 'Torneo creato con successo!');
    }

    /**
     * Display the specified tournament for admin view
     */
    public function show(Tournament $tournament)
    {
        $user = auth()->user();

        // Check permissions (zone admin can only see their zone tournaments)
        if ($user->user_type === 'admin' && $user->zone_id !== $tournament->zone_id) {
            abort(403, 'Non hai i permessi per visualizzare questo torneo.');
        }

        // ✅ FIXED: Load tournamentType relationship
        $tournament->load([
            'tournamentType',
            'zone',
            'club',
            'assignments.referee',
            'availabilities.referee'
        ]);

        // Get statistics
        $stats = [
            'total_assignments' => $tournament->assignments()->count(),
            'total_availabilities' => $tournament->availabilities()->count(),
            'total_referees' => $tournament->availabilities()->count(),
            'assigned_referees' => $tournament->assignments()->count(),
            // ✅ FIXED: Use tournamentType relationship
            'required_referees' => $tournament->required_referees ?? $tournament->tournamentType->min_referees ?? 1,
            'max_referees' => $tournament->max_referees ?? $tournament->tournamentType->max_referees ?? 4,
            'days_until_deadline' => $tournament->days_until_deadline,
            'is_editable' => method_exists($tournament, 'isEditable') ? $tournament->isEditable() : true,
        ];

        $assignedReferees = $tournament->assignments()->with('user')->get();
        $availableReferees = $tournament->availabilities()->with('user')->get();

        return view('admin.tournaments.show', compact(
            'tournament',
            'assignedReferees', // ← AGGIUNGI QUESTO
            'availableReferees',  // ← AGGIUNGI
            'stats'               // ← AGGIUNGI
        ));
    }

    /**
     * Show the form for editing the specified tournament.
     */
    public function edit(Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Check if editable
        if (!$tournament->isEditable()) {
            return redirect()
                ->route('tournaments.show', $tournament)
                ->with('error', 'Questo torneo non può essere modificato nel suo stato attuale.');
        }

        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        // ✅ FIXED: Variable name and model reference
        $tournamentTypes = TournamentType::active()
            ->when(!$isNationalAdmin, function ($q) use ($user) {
                $q->where(function ($q2) use ($user) {
                    $q2->where('is_national', false)
                        ->whereJsonContains('settings->visibility_zones', $user->zone_id);
                })->orWhere('is_national', true);
            })
            ->ordered()
            ->get();

        // Get zones
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        // Get clubs
        $clubs = club::active()
            ->where('zone_id', $tournament->zone_id)
            ->ordered()
            ->get();

        // ✅ FIXED: compact() uses tournamentTypes
        return view('admin.tournaments.edit', compact('tournament', 'tournamentTypes', 'zones', 'clubs'));
    }

    /**
     * Update the specified tournament in storage.
     */
    public function update(TournamentRequest $request, Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Check if editable
        if (!$tournament->isEditable()) {
            return redirect()
                ->route('tournaments.show', $tournament)
                ->with('error', 'Questo torneo non può essere modificato nel suo stato attuale.');
        }

        $data = $request->validated();

        // Update zone_id from club if changed
        if (isset($data['club_id']) && $data['club_id'] != $tournament->club_id) {
            $club = club::findOrFail($data['club_id']);
            $data['zone_id'] = $club->zone_id;
        }

        $tournament->update($data);

        return redirect()
            ->route('tournaments.show', $tournament)
            ->with('success', 'Torneo aggiornato con successo!');
    }

    /**
     * Remove the specified tournament from storage.
     */
    public function destroy(Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Check if can be deleted
        if ($tournament->assignments()->exists()) {
            return redirect()
                ->route('admin.tournaments.index')
                ->with('error', 'Impossibile eliminare un torneo con assegnazioni.');
        }

        if ($tournament->status !== 'draft') {
            return redirect()
                ->route('admin.tournaments.index')
                ->with('error', 'Solo i tornei in bozza possono essere eliminati.');
        }

        $tournament->delete();

        return redirect()
            ->route('admin.tournaments.index')
            ->with('success', 'Torneo eliminato con successo!');
    }

    /**
     * Update tournament status.
     */
    public function updateStatus(Request $request, Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        $request->validate([
            'status' => ['required', 'in:' . implode(',', array_keys(Tournament::STATUSES))],
        ]);

        $newStatus = $request->status;
        $currentStatus = $tournament->status;

        // Validate status transition
        $validTransitions = [
            'draft' => ['open'],
            'open' => ['closed'],
            'closed' => ['open', 'assigned'],
            'assigned' => ['completed'],
            'completed' => [],
        ];

        if (!in_array($newStatus, $validTransitions[$currentStatus] ?? [])) {
            return response()->json([
                'success' => false,
                'message' => 'Transizione di stato non valida.'
            ], 400);
        }

        // Additional checks
        if ($newStatus === 'assigned' && $tournament->assignments()->count() < $tournament->required_referees) {
            return response()->json([
                'success' => false,
                'message' => 'Non ci sono abbastanza arbitri assegnati.'
            ], 400);
        }

        $tournament->update(['status' => $newStatus]);

        return response()->json([
            'success' => true,
            'message' => 'Stato aggiornato con successo.',
            'new_status' => $newStatus,
            'new_status_label' => Tournament::STATUSES[$newStatus],
            'new_status_color' => $tournament->status_color,
        ]);
    }

    /**
     * Show availabilities for a tournament.
     */
    public function availabilities(Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Get available referees with their level and zone
        $availabilities = $tournament->availabilities()
            ->with(['user' => function ($query) {
                $query->with('zone');
            }])
            ->get()
            ->sortBy('user.name');

        // Get all eligible referees who haven't declared availability
        $eligibleReferees = \App\Models\User::where('user_type', 'referee')
            ->where('is_active', true)
            // ✅ FIXED: Use tournamentType relationship
            ->when($tournament->tournamentType->is_national, function ($q) {
                $q->whereIn('level', ['nazionale', 'internazionale']);
            }, function ($q) use ($tournament) {
                $q->where('zone_id', $tournament->zone_id);
            })
            ->whereNotIn('id', $tournament->availabilities()->pluck('user_id'))
            ->whereNotIn('id', $tournament->assignments()->pluck('user_id'))
            ->orderBy('name')
            ->get();

        return view('admin.tournaments.availabilities', compact(
            'tournament',
            'availabilities',
            'eligibleReferees'
        ));
    }

    /**
     * Check if user can access tournament.
     */
    private function checkTournamentAccess(Tournament $tournament)
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $tournament->zone_id !== $user->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere a questo torneo.');
        }
    }

    /**
     * Get clubs for a specific zone (AJAX).
     */
    public function getclubsByZone(Request $request)
    {
        $request->validate([
            'zone_id' => 'required|exists:zones,id',
        ]);

        $clubs = club::active()
            ->where('zone_id', $request->zone_id)
            ->ordered()
            ->get(['id', 'name', 'code']);

        return response()->json($clubs);
    }

    /**
     * Configurazione per il trait
     */
    protected function getEntityName($model): string
    {
        return 'Torneo';
    }

    protected function getIndexRoute(): string
    {
        return 'admin.tournaments.index';
    }

    protected function getDeleteErrorMessage($model): string
    {
        return 'Impossibile eliminare un torneo con assegnazioni.';
    }

    protected function canBeDeleted($tournament): bool
    {
        return !$tournament->assignments()->exists() && $tournament->status === 'draft';
    }

    protected function checkAccess($tournament): void
    {
        $this->checkTournamentAccess($tournament);
    }

    /**
     * Display a public listing of tournaments (for all authenticated users including referees)
     */
    public function publicIndex(Request $request)
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level ?? '', ['nazionale', 'internazionale']);

        // ✅ FIXED: tournamentType relationship
        $query = Tournament::with(['tournamentType', 'zone', 'club'])
            ->where('status', '!=', 'draft'); // Hide drafts from public view

        // Zone filtering logic
        if (!$isNationalReferee && $user->zone_id) {
            $query->where('zone_id', $user->zone_id);
        }

        // Simple search
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhereHas('club', function ($q2) use ($search) {
                        $q2->where('name', 'like', "%{$search}%");
                    });
            });
        }

        $tournaments = $query->orderBy('start_date', 'desc')->paginate(20);

        return view('tournaments.index', compact('tournaments'));
    }

    /**
     * Display public calendar view
     */
    public function publicCalendar(Request $request)
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level ?? '', ['nazionale', 'internazionale']);

        // ✅ FIXED: tournamentType relationship
        $tournaments = Tournament::with(['tournamentType', 'zone', 'club'])
            ->where('status', '!=', 'draft')
            ->when(!$isNationalReferee, function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->get();

        // Get user's availabilities and assignments if referee
        $userAvailabilities = [];
        $userAssignments = [];

        if ($user->user_type === 'referee') {
            $userAvailabilities = $user->availabilities()->pluck('tournament_id')->toArray();
            $userAssignments = $user->assignments()->pluck('tournament_id')->toArray();
        }

        // Format for calendar
        $calendarData = [
            'tournaments' => $tournaments->map(function ($tournament) use ($userAvailabilities, $userAssignments) {
                return [
                    'id' => $tournament->id,
                    'title' => $tournament->name,
                    'start' => $tournament->start_date->format('Y-m-d'),
                    'end' => $tournament->end_date->addDay()->format('Y-m-d'),
                    // ✅ FIXED: tournamentType relationship
                    'color' => $tournament->tournamentType->calendar_color ?? '#3b82f6',
                    'extendedProps' => [
                        'club' => $tournament->club->name,
                        'zone' => $tournament->zone->name,
                        // ✅ FIXED: tournamentType relationship
                        'category' => $tournament->tournamentType->name,
                        'status' => $tournament->status,
                        'available' => in_array($tournament->id, $userAvailabilities),
                        'assigned' => in_array($tournament->id, $userAssignments),
                    ],
                ];
            }),
        ];

        return view('tournaments.calendar', compact('calendarData'));
    }

    /**
     * Display public tournament details
     */
    public function publicShow(Tournament $tournament)
    {
        $user = auth()->user();

        // Check access - hide drafts from public
        if ($tournament->status === 'draft') {
            abort(404);
        }

        // Check zone access for zone-specific users
        if (
            !in_array($user->level ?? '', ['nazionale', 'internazionale']) &&
            $user->zone_id && $tournament->zone_id !== $user->zone_id
        ) {
            abort(403, 'Non hai accesso a questo torneo.');
        }

        // ✅ FIXED: tournamentType relationship
        $tournament->load([
            'tournamentType',
            'zone',
            'club',
            'assignments.user',
            'availabilities.user'
        ]);

        // Check if user has applied/is assigned (for referees)
        $userAvailability = null;
        $userAssignment = null;

        if ($user->user_type === 'referee') {
            $userAvailability = $tournament->availabilities()->where('user_id', $user->id)->first();
            $userAssignment = $tournament->assignments()->where('user_id', $user->id)->first();
        }

        return view('tournaments.show', compact('tournament', 'userAvailability', 'userAssignment'));
    }

    /**
     * ADMIN METHODS - Solo per admin/super admin
     */

    /**
     * Display admin listing of tournaments with full management features
     */
    public function adminIndex(Request $request)
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin';

        // ✅ FIXED: tournamentType relationship
        $query = Tournament::with(['tournamentType', 'zone', 'club', 'assignments']);

        // Filter by zone for zone admins
        if (!$isNationalAdmin && !in_array($user->user_type, ['super_admin'])) {
            $query->where('zone_id', $user->zone_id);
        }

        // Apply filters
        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('zone_id')) {
            $query->where('zone_id', $request->zone_id);
        }

        // ✅ FIXED: tournament_type_id filter
        if ($request->filled('tournament_type_id')) {
            $query->where('tournament_type_id', $request->tournament_type_id);
        }

        if ($request->filled('month')) {
            $startOfMonth = \Carbon\Carbon::parse($request->month)->startOfMonth();
            $endOfMonth = \Carbon\Carbon::parse($request->month)->endOfMonth();
            $query->where(function ($q) use ($startOfMonth, $endOfMonth) {
                $q->whereBetween('start_date', [$startOfMonth, $endOfMonth])
                    ->orWhereBetween('end_date', [$startOfMonth, $endOfMonth]);
            });
        }

        // Search
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhereHas('club', function ($q2) use ($search) {
                        $q2->where('name', 'like', "%{$search}%");
                    });
            });
        }

        $tournaments = $query->orderBy('start_date', 'desc')->paginate(15);

        // Get data for filters
        $zones = $isNationalAdmin ? \App\Models\Zone::orderBy('name')->get() : collect();

        // ✅ FIXED: Variable name from $categories to $tournamentTypes
        $tournamentTypes = \App\Models\TournamentType::where('is_active', true)->orderBy('name')->get();

        // Define statuses
        $statuses = [
            'draft' => 'Bozza',
            'open' => 'Aperto',
            'closed' => 'Chiuso',
            'assigned' => 'Assegnato',
            'completed' => 'Completato'
        ];

        // ✅ FIXED: compact() uses tournamentTypes
        return view('admin.tournaments.index', compact(
            'tournaments',
            'zones',
            'tournamentTypes', // ← FIXED: was 'types'
            'statuses',
            'isNationalAdmin'
        ));
    }

    /**
     * Display admin calendar with management features
     */
    public function adminCalendar(Request $request)
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin';

        // ✅ FIXED: tournamentType relationship
        $tournaments = Tournament::with(['tournamentType', 'zone', 'club', 'assignments', 'availabilities'])
            ->when(!$isNationalAdmin && !in_array($user->user_type, ['super_admin']), function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->get();

        // Format for calendar with admin data
        $calendarData = [
            'tournaments' => $tournaments->map(function ($tournament) {
                return [
                    'id' => $tournament->id,
                    'title' => $tournament->name,
                    'start' => $tournament->start_date->format('Y-m-d'),
                    'end' => $tournament->end_date->addDay()->format('Y-m-d'),
                    // ✅ FIXED: tournamentType relationship
                    'color' => $tournament->tournamentType->calendar_color ?? '#3b82f6',
                    'extendedProps' => [
                        'club' => $tournament->club->name,
                        'zone' => $tournament->zone->name,
                        // ✅ FIXED: tournamentType relationship
                        'category' => $tournament->tournamentType->name,
                        'status' => $tournament->status,
                        'assignments_count' => $tournament->assignments()->count(),
                        'availabilities_count' => $tournament->availabilities()->count(),
                        'required_referees' => $tournament->required_referees ?? 1,
                        'can_edit' => true, // Admin can always edit
                    ],
                ];
            }),
        ];

        return view('admin.tournaments.calendar', compact('calendarData'));
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class ZoneController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        //
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     */
    public function show(string $id)
    {
        //
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(string $id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, string $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(string $id)
    {
        //
    }
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class AvailabilityController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     */
    public function show(string $id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, string $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(string $id)
    {
        //
    }
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class CalendarController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     */
    public function show(string $id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, string $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(string $id)
    {
        //
    }
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class RefereeController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class StatsController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class TournamentController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Http\Requests\Auth\LoginRequest;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\View\View;

class AuthenticatedSessionController extends Controller
{
    /**
     * Display the login view.
     */
    public function create(): View
    {
        return view('auth.login');
    }

    /**
     * Handle an incoming authentication request.
     */
    public function store(LoginRequest $request): RedirectResponse
    {
        $request->authenticate();

        $request->session()->regenerate();

        return redirect()->intended(route('dashboard', absolute: false));
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Validation\ValidationException;
use Illuminate\View\View;

class ConfirmablePasswordController extends Controller
{
    /**
     * Show the confirm password view.
     */
    public function show(): View
    {
        return view('auth.confirm-password');
    }

    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard', absolute: false));
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\View\View;

class EmailVerificationPromptController extends Controller
{
    /**
     * Display the email verification prompt.
     */
    public function __invoke(Request $request): RedirectResponse|View
    {
        return $request->user()->hasVerifiedEmail()
                    ? redirect()->intended(route('dashboard', absolute: false))
                    : view('auth.verify-email');
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
use Illuminate\Validation\Rules;
use Illuminate\View\View;

class NewPasswordController extends Controller
{
    /**
     * Display the password reset view.
     */
    public function create(Request $request): View
    {
        return view('auth.reset-password', ['request' => $request]);
    }

    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => ['required'],
            'email' => ['required', 'email'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function (User $user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        return $status == Password::PASSWORD_RESET
                    ? redirect()->route('login')->with('status', __($status))
                    : back()->withInput($request->only('email'))
                        ->withErrors(['email' => __($status)]);
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules\Password;

class PasswordController extends Controller
{
    /**
     * Update the user's password.
     */
    public function update(Request $request): RedirectResponse
    {
        $validated = $request->validateWithBag('updatePassword', [
            'current_password' => ['required', 'current_password'],
            'password' => ['required', Password::defaults(), 'confirmed'],
        ]);

        $request->user()->update([
            'password' => Hash::make($validated['password']),
        ]);

        return back()->with('status', 'password-updated');
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
use Illuminate\View\View;

class PasswordResetLinkController extends Controller
{
    /**
     * Display the password reset link request view.
     */
    public function create(): View
    {
        return view('auth.forgot-password');
    }

    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status == Password::RESET_LINK_SENT
                    ? back()->with('status', __($status))
                    : back()->withInput($request->only('email'))
                        ->withErrors(['email' => __($status)]);
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use Illuminate\View\View;

class RegisteredUserController extends Controller
{
    /**
     * Display the registration view.
     */
    public function create(): View
    {
        return view('auth.register');
    }

    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'lowercase', 'email', 'max:255', 'unique:'.User::class],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        Auth::login($user);

        return redirect(route('dashboard', absolute: false));
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\Verified;
use Illuminate\Foundation\Auth\EmailVerificationRequest;
use Illuminate\Http\RedirectResponse;

class VerifyEmailController extends Controller
{
    /**
     * Mark the authenticated user's email address as verified.
     */
    public function __invoke(EmailVerificationRequest $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false).'?verified=1');
        }

        if ($request->user()->markEmailAsVerified()) {
            event(new Verified($request->user()));
        }

        return redirect()->intended(route('dashboard', absolute: false).'?verified=1');
    }
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class ApplicationController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use App\Models\Assignment;
use Illuminate\Http\Request;
use Illuminate\View\View;

class AssignmentController extends Controller
{
    /**
     * Display the referee's assignments.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();

        // Anno di default: corrente
        $year = $request->get('year', now()->year);

        // Query base per le assegnazioni dell'arbitro
        $query = Assignment::where('user_id', $user->id)
            ->with(['tournament.club', 'tournament.zone'])
            ->whereHas('tournament', function($q) use ($year) {
                $q->whereYear('start_date', $year);
            });

        // Filtro per stato
        if ($request->filled('status')) {
            $status = $request->status;
            if ($status === 'upcoming') {
                $query->whereHas('tournament', function($q) {
                    $q->where('start_date', '>=', now());
                });
            } elseif ($status === 'completed') {
                $query->whereHas('tournament', function($q) {
                    $q->where('end_date', '<', now());
                });
            } elseif ($status === 'confirmed') {
                $query->where('is_confirmed', true);
            } elseif ($status === 'pending') {
                $query->where('is_confirmed', false);
            }
        }

        // Ordina per data torneo
        $assignments = $query->orderBy(function($query) {
                return $query->select('start_date')
                    ->from('tournaments')
                    ->whereColumn('tournaments.id', 'assignments.tournament_id');
            }, 'desc')
            ->paginate(15)
            ->withQueryString();

        // Statistiche per l'anno corrente
        $stats = [
            'total' => Assignment::where('user_id', $user->id)
                ->whereHas('tournament', function($q) use ($year) {
                    $q->whereYear('start_date', $year);
                })->count(),

            'confirmed' => Assignment::where('user_id', $user->id)
                ->where('is_confirmed', true)
                ->whereHas('tournament', function($q) use ($year) {
                    $q->whereYear('start_date', $year);
                })->count(),

            'upcoming' => Assignment::where('user_id', $user->id)
                ->whereHas('tournament', function($q) use ($year) {
                    $q->where('start_date', '>=', now())
                     ->whereYear('start_date', $year);
                })->count(),

            'completed' => Assignment::where('user_id', $user->id)
                ->whereHas('tournament', function($q) use ($year) {
                    $q->where('end_date', '<', now())
                     ->whereYear('start_date', $year);
                })->count(),
        ];

        // Anni disponibili per il filtro
        $availableYears = Assignment::where('user_id', $user->id)
            ->join('tournaments', 'assignments.tournament_id', '=', 'tournaments.id')
            ->selectRaw('YEAR(tournaments.start_date) as year')
            ->distinct()
            ->orderBy('year', 'desc')
            ->pluck('year');

        return view('referee.assignments.index', compact(
            'assignments',
            'stats',
            'year',
            'availableYears'
        ));
    }

    /**
     * Show assignment details.
     */
    public function show(Assignment $assignment): View
    {
        // Verifica che l'assegnazione appartenga all'arbitro loggato
        if ($assignment->user_id !== auth()->id()) {
            abort(403, 'Non autorizzato a visualizzare questa assegnazione.');
        }

        $assignment->load([
            'tournament.club',
            'tournament.zone',
            'tournament.assignments.user', // Altri arbitri del torneo
        ]);

        return view('referee.assignments.show', compact('assignment'));
    }
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use App\Models\Availability;
use App\Models\Zone;
use Illuminate\Http\Request;
use Carbon\Carbon;
use Illuminate\View\View;

class AvailabilityController extends Controller
{
    /**
     * Display the availability summary page - SENZA AVAILABILITY_DEADLINE
     */
    public function index(Request $request)
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);

        // Get filter parameters - SOLO PER ARBITRI NAZIONALI
        $zoneId = $isNationalReferee ? $request->get('zone_id') : null;
        $categoryId = $isNationalReferee ? $request->get('category_id') : null;
        $month = $isNationalReferee ? $request->get('month') : null;

        // Base query - SENZA AVAILABILITY_DEADLINE
        $query = Tournament::with(['tournamentType', 'zone', 'club'])
            ->where(function ($q) use ($user) {
                $q->where(function ($q2) {
                    // Tornei futuri (status aperto o altro)
                    $q2->where('start_date', '>=', Carbon::today());
                })->orWhere(function ($q2) use ($user) {
                    // Oppure tornei dove l'arbitro ha già dato disponibilità
                    $q2->whereHas('availabilities', function ($q3) use ($user) {
                        $q3->where('user_id', $user->id);
                    });
                });
            });

        // Apply zone filter logic
        if ($isNationalReferee) {
            // Arbitri nazionali: zona propria + gare nazionali
            $query->where(function ($q) use ($user, $zoneId) {
                if ($zoneId) {
                    // Se filtro zona specificato, mostra solo quella zona
                    $q->where('zone_id', $zoneId);
                } else {
                    // Altrimenti: zona propria + gare nazionali ovunque
                    $q->where('zone_id', $user->zone_id)
                        ->orWhereHas('tournamentType', function ($q2) {
                            $q2->where('is_national', true);
                        });
                }
            });
        } else {
            // Arbitri aspiranti/primo_livello/regionali: SOLO zona propria
            $query->where('zone_id', $user->zone_id);
        }

        // Apply category filter SOLO SE SPECIFICATO E ARBITRO NAZIONALE
        if ($categoryId && $isNationalReferee) {
            $query->where('tournament_type_id', $categoryId);
        }

        // Apply month filter SOLO SE SPECIFICATO E ARBITRO NAZIONALE
        if ($month && $isNationalReferee) {
            $startOfMonth = Carbon::parse($month)->startOfMonth();
            $endOfMonth = Carbon::parse($month)->endOfMonth();
            $query->where(function ($q) use ($startOfMonth, $endOfMonth) {
                $q->whereBetween('start_date', [$startOfMonth, $endOfMonth])
                    ->orWhereBetween('end_date', [$startOfMonth, $endOfMonth])
                    ->orWhere(function ($q2) use ($startOfMonth, $endOfMonth) {
                        $q2->where('start_date', '<=', $startOfMonth)
                            ->where('end_date', '>=', $endOfMonth);
                    });
            });
        }

        // Order by start date
        $tournaments = $query->orderBy('start_date')->get();

        // Get user's current availabilities
        $userAvailabilities = $user->availabilities()
            ->pluck('tournament_id')
            ->toArray();

        // Get zones for filter (only for national referees)
        $zones = $isNationalReferee ? Zone::orderBy('name')->get() : collect();

        // Get categories visible to user (only for national referees) - FIX: Renamed from $categories to $types
        $types = $isNationalReferee ? \App\Models\TournamentType::active()
            ->when(!$isNationalReferee, function ($q) use ($user) {
                $q->where(function ($q2) use ($user) {
                    $q2->where('is_national', false)
                        ->whereJsonContains('settings->visibility_zones', $user->zone_id);
                })->orWhere('is_national', true);
            })
            ->ordered()
            ->get() : collect();

        // Group tournaments by month for display
        $tournamentsByMonth = $tournaments->groupBy(function ($tournament) {
            return $tournament->start_date->format('Y-m');
        });

        return view('referee.availability.index', compact(
            'tournamentsByMonth',
            'userAvailabilities',
            'zones',
            'types', // ← FIX: Corrected variable name
            'zoneId',
            'categoryId',
            'month',
            'isNationalReferee'
        ));
    }

    /**
     * Save referee availabilities - SENZA AVAILABILITY_DEADLINE
     */
    public function save(Request $request)
    {
        $request->validate([
            'availabilities' => 'array',
            'availabilities.*' => 'exists:tournaments,id',
            'notes' => 'array',
            'notes.*' => 'nullable|string|max:500',
        ]);

        $user = auth()->user();
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);
        $selectedTournaments = $request->input('availabilities', []);
        $notes = $request->input('notes', []);

        // Get tournaments user can access - SOLO TORNEI FUTURI
        $accessibleQuery = Tournament::where('start_date', '>=', Carbon::today());

        if ($isNationalReferee) {
            // Arbitri nazionali: zona propria + gare nazionali
            $accessibleQuery->where(function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id)
                    ->orWhereHas('tournamentType', function ($q2) {
                        $q2->where('is_national', true);
                    });
            });
        } else {
            // Arbitri aspiranti/primo_livello/regionali: solo zona propria
            $accessibleQuery->where('zone_id', $user->zone_id);
        }

        $accessibleTournaments = $accessibleQuery->pluck('id')->toArray();

        // Filter only accessible tournaments
        $selectedTournaments = array_intersect($selectedTournaments, $accessibleTournaments);

        // Start transaction
        \DB::beginTransaction();

        try {
            // Remove old availabilities for accessible tournaments
            Availability::where('user_id', $user->id)
                ->whereIn('tournament_id', $accessibleTournaments)
                ->delete();

            // Add new availabilities
            foreach ($selectedTournaments as $tournamentId) {
                Availability::create([
                    'user_id' => $user->id,
                    'tournament_id' => $tournamentId,
                    'notes' => $notes[$tournamentId] ?? null,
                    'submitted_at' => Carbon::now(),
                ]);
            }

            \DB::commit();

            return redirect()->route('referee.availability.index')
                ->with('success', 'Disponibilità aggiornate con successo!');
        } catch (\Exception $e) {
            \DB::rollback();

            return redirect()->route('referee.availability.index')
                ->with('error', 'Errore durante il salvataggio delle disponibilità. Riprova.');
        }
    }

    /**
     * Toggle single availability via AJAX - ORIGINALE
     */
    public function toggle(Request $request)
    {
        $request->validate([
            'tournament_id' => 'required|exists:tournaments,id',
            'available' => 'required|boolean',
            'notes' => 'nullable|string|max:500',
        ]);

        $user = auth()->user();
        $tournament = Tournament::findOrFail($request->tournament_id);
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);

        // Check if user can access this tournament
        $canAccess = false;
        if ($isNationalReferee) {
            // Arbitri nazionali: zona propria + gare nazionali
            $canAccess = $tournament->zone_id == $user->zone_id ||
                $tournament->tournamentType->is_national;
        } else {
            // Arbitri non nazionali: solo zona propria
            $canAccess = $tournament->zone_id == $user->zone_id;
        }

        if (!$canAccess) {
            return response()->json(['error' => 'Non autorizzato'], 403);
        }

        // Check if tournament allows availability changes - SENZA DEADLINE
        if ($tournament->start_date <= Carbon::today()) {
            return response()->json(['error' => 'Torneo già iniziato'], 400);
        }

        if ($request->available) {
            // Add availability
            Availability::updateOrCreate(
                [
                    'user_id' => $user->id,
                    'tournament_id' => $tournament->id,
                ],
                [
                    'notes' => $request->notes,
                    'submitted_at' => Carbon::now(),
                ]
            );

            return response()->json([
                'success' => true,
                'message' => 'Disponibilità confermata',
            ]);
        } else {
            // Remove availability
            Availability::where('user_id', $user->id)
                ->where('tournament_id', $tournament->id)
                ->delete();

            return response()->json([
                'success' => true,
                'message' => 'Disponibilità rimossa',
            ]);
        }
    }

    /**
     * Referee Calendar - Personal focus - SOLO GARE DI COMPETENZA
     */
    public function calendar(Request $request)
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level ?? '', ['nazionale', 'internazionale']);

        // Get tournaments for calendar - LOGICA AGGIORNATA
        $tournamentsQuery = Tournament::with(['tournamentType', 'zone', 'club'])
            ->whereIn('status', ['draft', 'open', 'closed', 'assigned']);

        if ($isNationalReferee) {
            // Arbitri nazionali: zona propria + gare nazionali ovunque
            $tournamentsQuery->where(function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id)
                    ->orWhereHas('tournamentType', function ($q2) {
                        $q2->where('is_national', true);
                    });
            });
        } else {
            // Arbitri aspiranti/primo_livello/regionali: solo zona propria (incluse gare nazionali nella loro zona)
            $tournamentsQuery->where('zone_id', $user->zone_id);
        }

        $tournaments = $tournamentsQuery->get();

        // Get user's availabilities and assignments
        $userAvailabilities = $user->availabilities()->pluck('tournament_id')->toArray();
        $userAssignments = $user->assignments()->pluck('tournament_id')->toArray();

        // Format tournaments for calendar - CON CODICE CIRCOLO NEL TITOLO
        $calendarTournaments = $tournaments->map(function ($tournament) use ($userAvailabilities, $userAssignments) {
            $isAvailable = in_array($tournament->id, $userAvailabilities);
            $isAssigned = in_array($tournament->id, $userAssignments);

            return [
                'id' => $tournament->id,
                'title' => $tournament->name . ($tournament->club->code ? ' (' . $tournament->club->code . ')' : ''),
                'start' => $tournament->start_date->format('Y-m-d'),
                'end' => $tournament->end_date->addDay()->format('Y-m-d'),
                'color' => $isAssigned ? '#10B981' : ($isAvailable ? '#3B82F6' : '#E5E7EB'),
                'borderColor' => $isAssigned ? '#10B981' : ($isAvailable ? '#F59E0B' : '#9CA3AF'),
                'textColor' => $isAssigned ? '#FFFFFF' : ($isAvailable ? '#FFFFFF' : '#374151'), // Testo nero per eventi non selezionati
                'extendedProps' => [
                    'club' => $tournament->club->name ?? 'N/A',
                    'club_code' => $tournament->club->code ?? '',
                    'zone' => $tournament->zone->name ?? 'N/A',
                    'category' => $tournament->tournamentType->name ?? 'N/A',
                    'status' => $tournament->status,
                    'deadline' => $tournament->availability_deadline?->format('d/m/Y') ?? 'N/A',
                    'days_until_deadline' => $tournament->availability_deadline
                        ? Carbon::today()->diffInDays($tournament->availability_deadline, false)
                        : null,
                    'is_available' => $isAvailable,
                    'is_assigned' => $isAssigned,
                    'can_apply' => $tournament->start_date > Carbon::today() &&
                        ($tournament->availability_deadline ? $tournament->availability_deadline >= Carbon::today() : true),
                    'personal_status' => $isAssigned ? 'assigned' : ($isAvailable ? 'available' : 'can_apply'),
                    'tournament_url' => route('tournaments.show', $tournament),
                    'is_national' => $tournament->tournamentType->is_national ?? false,
                ],
            ];
        });

        // STRUTTURA DATI per RefereeCalendar.jsx
        $calendarData = [
            'tournaments' => $calendarTournaments,
            'userType' => 'referee',
            'userRoles' => ['referee'],
            'canModify' => true,
            'zones' => collect(),
            'types' => collect(),
            'clubs' => collect(),
            'availabilities' => $userAvailabilities,
            'assignments' => $userAssignments,
            'totalTournaments' => $tournaments->count(),
            'lastUpdated' => now()->toISOString(),
            'userLevel' => $user->level,
            'isNationalReferee' => $isNationalReferee,
        ];

        return view('referee.availability.calendar', compact('calendarData'));
    }
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;

class DashboardController extends Controller
{
    /**
     * Display the referee dashboard.
     */
    public function index()
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);

        // Get referee statistics (usando un try-catch per evitare errori)
        try {
            $stats = $user->referee_statistics;
        } catch (\Exception $e) {
            // Se il metodo non esiste, creiamo delle statistiche base
            $stats = (object) [
                'total_assignments' => $user->assignments()->count(),
                'assignments_this_year' => $user->assignments()
                    ->whereHas('tournament', function($q) {
                        $q->whereYear('start_date', now()->year);
                    })
                    ->count(),
                'confirmed_assignments' => $user->assignments()->where('is_confirmed', true)->count(),
                'pending_assignments' => $user->assignments()->where('is_confirmed', false)->count(),
            ];
        }

        // Upcoming assignments
        $upcomingAssignments = $user->assignments()
            ->with(['tournament.club', 'tournament.zone', 'tournament.tournamentCategory'])
            ->whereHas('tournament', function ($q) {
                $q->where('start_date', '>=', Carbon::today());
            })
            ->limit(5)
            ->get();

        // Recent assignments (last 3 months)
        $recentAssignments = $user->assignments()
            ->with(['tournament.club', 'tournament.zone'])
            ->whereHas('tournament', function ($q) {
                $q->where('end_date', '>=', Carbon::now()->subMonths(3))
                  ->where('end_date', '<', Carbon::today());
            })
            ->limit(5)
            ->get();

        // Tournaments open for availability
        $openTournamentsQuery = Tournament::with(['club', 'zone', 'tournamentType'])
            ->where('status', 'open')
            ->where('availability_deadline', '>=', Carbon::today());

        // Filter by zone for non-national referees
        if (!$isNationalReferee) {
            $openTournamentsQuery->where('zone_id', $user->zone_id);
        } else {
            // National referees see national tournaments from all zones
            $openTournamentsQuery->where(function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id)
                  ->orWhereHas('tournamentType', function ($q2) {
                      $q2->where('is_national', true);
                  });
            });
        }

        $openTournaments = $openTournamentsQuery
            ->orderBy('availability_deadline')
            ->limit(10)
            ->get();

        // Get availabilities that haven't been assigned yet
        $pendingAvailabilities = $user->availabilities()
            ->with(['tournament.club', 'tournament.zone'])
            ->whereDoesntHave('tournament.assignments', function ($q) use ($user) {
                $q->where('user_id', $user->id);
            })
            ->whereHas('tournament', function ($q) {
                $q->whereIn('status', ['open', 'closed'])
                  ->where('start_date', '>=', Carbon::today());
            })
            ->limit(5)
            ->get();

        // Monthly statistics (last 12 months) - semplificato
        $monthlyStats = [];
        for ($i = 11; $i >= 0; $i--) {
            $month = Carbon::now()->subMonths($i)->format('Y-m');
            $count = $user->assignments()
                ->whereHas('tournament', function($q) use ($month) {
                    $q->where('start_date', 'like', $month . '%');
                })
                ->count();
            $monthlyStats[$month] = $count;
        }

        // Assignments by tournament type - semplificato
        $assignmentsByCategory = $user->assignments()
            ->join('tournaments', 'assignments.tournament_id', '=', 'tournaments.id')
            ->join('tournament_types', 'tournaments.tournament_type_id', '=', 'tournament_types.id')
            ->select('tournament_types.name', DB::raw('count(*) as total'))
            ->whereYear('assignments.created_at', Carbon::now()->year)
            ->groupBy('tournament_types.name')
            ->pluck('total', 'name')
            ->toArray();

        // Calendar events for the next 3 months - semplificato
        $calendarEvents = [];
        $calendarAssignments = $user->assignments()
            ->with(['tournament.club', 'tournament.tournamentCategory'])
            ->whereHas('tournament', function ($q) {
                $q->whereBetween('start_date', [Carbon::today(), Carbon::today()->addMonths(3)]);
            })
            ->get();

        foreach ($calendarAssignments as $assignment) {
            $calendarEvents[] = [
                'id' => 'assignment-' . $assignment->id,
                'title' => $assignment->tournament->name,
                'start' => $assignment->tournament->start_date->format('Y-m-d'),
                'end' => $assignment->tournament->end_date ? $assignment->tournament->end_date->addDay()->format('Y-m-d') : $assignment->tournament->start_date->format('Y-m-d'),
                'color' => $assignment->is_confirmed ? '#10b981' : '#f59e0b',
                'textColor' => '#ffffff'
            ];
        }

        return view('referee.dashboard', compact(
            'user',
            'stats',
            'upcomingAssignments',
            'recentAssignments',
            'openTournaments',
            'pendingAvailabilities',
            'monthlyStats',
            'assignmentsByCategory',
            'calendarEvents'
        ));
    }
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class DocumentController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use App\Models\Referee;
use App\Models\Zone;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Hash;

class ProfileController extends Controller
{
    public function edit()
    {
        $user = auth()->user();
        $referee = $user->referee;

        // Se non esiste il referee, crealo
        if (!$referee) {
            $referee = Referee::create([
                'user_id' => $user->id,
                'zone_id' => $user->zone_id,
                'referee_code' => 'REF' . str_pad($user->id, 4, '0', STR_PAD_LEFT),
                'level' => 'primo_livello',
                'category' => 'misto',
                'certified_date' => now(),
            ]);
        }

        $zones = Zone::orderBy('name')->get();

        $levels = [
            'primo_livello' => 'Primo Livello',
            'secondo_livello' => 'Secondo Livello',
            'terzo_livello' => 'Terzo Livello',
            'nazionale' => 'Nazionale',
            'internazionale' => 'Internazionale'
        ];

        return view('referee.profile.edit', compact('referee', 'zones', 'levels'));
    }

    public function update(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email,' . auth()->id(),
            'phone' => 'nullable|string|max:20',
            'level' => 'required|string',
            'zone_id' => 'required|exists:zones,id',
            'category' => 'required|string',
            'bio' => 'nullable|string|max:1000',
            'experience_years' => 'nullable|integer|min:0',
            'specializations' => 'nullable|array',
            'languages' => 'nullable|array',
        ]);

        try {
            DB::beginTransaction();

            $user = auth()->user();
            $referee = $user->referee;

            // Aggiorna User
            $user->update([
                'name' => $request->name,
                'email' => $request->email,
                'phone' => $request->phone,
                'zone_id' => $request->zone_id,
            ]);

            // Aggiorna Referee
            $referee->update([
                'level' => $request->level,
                'zone_id' => $request->zone_id,
                'category' => $request->category,
                'bio' => $request->bio ?: 'Profilo arbitro completato',
                'experience_years' => $request->experience_years ?: 0,
                'specializations' => json_encode($request->specializations ?: ['stroke_play']),
                'languages' => json_encode($request->languages ?: ['it']),
                'profile_completed_at' => now(), // ✅ IMPORTANTE: Marca come completato
            ]);

            DB::commit();

            return redirect()
                ->route('referee.dashboard')
                ->with('success', 'Profilo aggiornato con successo!');

        } catch (\Exception $e) {
            DB::rollback();

            return redirect()
                ->back()
                ->withInput()
                ->with('error', 'Errore durante l\'aggiornamento: ' . $e->getMessage());
        }
    }

    public function updatePassword(Request $request)
    {
        $request->validate([
            'current_password' => 'required',
            'password' => 'required|min:8|confirmed',
        ]);

        if (!Hash::check($request->current_password, auth()->user()->password)) {
            return back()->withErrors(['current_password' => 'Password attuale non corretta']);
        }

        auth()->user()->update([
            'password' => Hash::make($request->password)
        ]);

        return back()->with('success', 'Password aggiornata con successo!');
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class AnalyticsController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\Assignment;
use App\Models\Zone;
use App\Models\TournamentType; // ✅ FIXED: Changed from TournamentCategory
use Illuminate\Http\Request;
use Illuminate\View\View;
use Carbon\Carbon;

class AssignmentReportController extends Controller
{
    /**
     * Display assignments report.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();

        $query = Assignment::with([
            'user:id,name,referee_code,level',
            // ✅ FIXED: Changed tournament.tournamentCategory to tournament.tournamentType
            'tournament:id,name,start_date,end_date,zone_id,club_id,tournament_type_id',
            'tournament.club:id,name',
            'tournament.zone:id,name',
            'tournament.tournamentType:id,name', // ← FIXED: was tournamentCategory
            'assignedBy:id,name'
        ]);

        // Apply access restrictions
        if ($user->user_type === 'admin' && !in_array($user->user_type, ['super_admin', 'national_admin'])) {
            $query->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        // Apply filters
        if ($request->filled('zone_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('zone_id', $request->zone_id);
            });
        }

        if ($request->filled('status')) {
            if ($request->status === 'confirmed') {
                $query->where('is_confirmed', true);
            } elseif ($request->status === 'unconfirmed') {
                $query->where('is_confirmed', false);
            }
        }

        if ($request->filled('date_from')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('start_date', '>=', $request->date_from);
            });
        }

        if ($request->filled('date_to')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('start_date', '<=', $request->date_to);
            });
        }

        // ✅ FIXED: Changed from category_id to tournament_type_id
        if ($request->filled('tournament_type_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('tournament_type_id', $request->tournament_type_id);
            });
        }

        $assignments = $query
            ->orderBy('created_at', 'desc')
            ->paginate(20)
            ->withQueryString();

        // Get filter options
        $zones = $this->getAccessibleZones($user);

        // ✅ FIXED: Variable name from $categories to $tournamentTypes
        $tournamentTypes = TournamentType::active()->ordered()->get();

        // Get statistics
        $stats = $this->getAssignmentStats($user, $request);

        // ✅ FIXED: compact() uses tournamentTypes instead of categories
        return view('reports.assignments.index', compact(
            'assignments',
            'zones',
            'tournamentTypes', // ← FIXED: was 'categories'
            'stats'
        ));
    }

    /**
     * Get assignment statistics.
     */
    private function getAssignmentStats($user, $request): array
    {
        $query = Assignment::query();

        // Apply same access restrictions as main query
        if ($user->user_type === 'admin' && !in_array($user->user_type, ['super_admin', 'national_admin'])) {
            $query->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        // Apply same filters as main query
        if ($request->filled('zone_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('zone_id', $request->zone_id);
            });
        }

        if ($request->filled('date_from') || $request->filled('date_to')) {
            $query->whereHas('tournament', function($q) use ($request) {
                if ($request->filled('date_from')) {
                    $q->where('start_date', '>=', $request->date_from);
                }
                if ($request->filled('date_to')) {
                    $q->where('start_date', '<=', $request->date_to);
                }
            });
        }

        // ✅ FIXED: Changed tournament_category_id to tournament_type_id
        if ($request->filled('tournament_type_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('tournament_type_id', $request->tournament_type_id);
            });
        }

        return [
            'total' => $query->count(),
            'confirmed' => $query->where('is_confirmed', true)->count(),
            'unconfirmed' => $query->where('is_confirmed', false)->count(),
            'current_year' => $query->whereYear('created_at', now()->year)->count(),
            'this_month' => $query->whereMonth('created_at', now()->month)
                                 ->whereYear('created_at', now()->year)->count(),
        ];
    }

    /**
     * Get zones accessible to the user.
     */
    private function getAccessibleZones($user)
    {
        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return Zone::orderBy('name')->get();
        }

        return Zone::where('id', $user->zone_id)->get();
    }

    /**
     * Export assignments report.
     */
    public function export(Request $request)
    {
        $user = auth()->user();

        $query = Assignment::with([
            'user:id,name,referee_code,level',
            // ✅ FIXED: tournamentType relationship
            'tournament:id,name,start_date,end_date,zone_id,club_id,tournament_type_id',
            'tournament.club:id,name',
            'tournament.zone:id,name',
            'tournament.tournamentType:id,name', // ← FIXED
            'assignedBy:id,name'
        ]);

        // Apply same access restrictions and filters as index method
        if ($user->user_type === 'admin' && !in_array($user->user_type, ['super_admin', 'national_admin'])) {
            $query->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        // Apply filters (same logic as index)
        if ($request->filled('zone_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('zone_id', $request->zone_id);
            });
        }

        if ($request->filled('status')) {
            if ($request->status === 'confirmed') {
                $query->where('is_confirmed', true);
            } elseif ($request->status === 'unconfirmed') {
                $query->where('is_confirmed', false);
            }
        }

        if ($request->filled('date_from')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('start_date', '>=', $request->date_from);
            });
        }

        if ($request->filled('date_to')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('start_date', '<=', $request->date_to);
            });
        }

        // ✅ FIXED: tournament_type_id filter
        if ($request->filled('tournament_type_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('tournament_type_id', $request->tournament_type_id);
            });
        }

        $assignments = $query->orderBy('created_at', 'desc')->get();

        $filename = 'assignments_report_' . now()->format('Y-m-d_H-i-s') . '.csv';

        $headers = [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ];

        $callback = function() use ($assignments) {
            $file = fopen('php://output', 'w');

            // CSV headers
            fputcsv($file, [
                'ID',
                'Arbitro',
                'Codice Arbitro',
                'Livello',
                'Torneo',
                'Categoria Torneo', // ✅ Column name clarified
                'Club',
                'Zona',
                'Ruolo',
                'Data Assegnazione',
                'Confermato',
                'Assegnato da',
                'Note'
            ]);

            foreach ($assignments as $assignment) {
                fputcsv($file, [
                    $assignment->id,
                    $assignment->user->name,
                    $assignment->user->referee_code ?? 'N/A',
                    $assignment->user->level ?? 'N/A',
                    $assignment->tournament->name,
                    // ✅ FIXED: tournamentType relationship
                    $assignment->tournament->tournamentType->name ?? 'N/A',
                    $assignment->tournament->club->name ?? 'N/A',
                    $assignment->tournament->zone->name ?? 'N/A',
                    $assignment->role,
                    $assignment->assigned_at?->format('d/m/Y H:i') ?? 'N/A',
                    $assignment->is_confirmed ? 'Sì' : 'No',
                    $assignment->assignedBy->name ?? 'N/A',
                    $assignment->notes ?? ''
                ]);
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }

    /**
     * Show detailed assignment analytics.
     */
    public function analytics(Request $request): View
    {
        $user = auth()->user();
        $startDate = $request->get('start_date', now()->subMonths(6)->format('Y-m-d'));
        $endDate = $request->get('end_date', now()->format('Y-m-d'));

        // Base query with proper access control
        $baseQuery = Assignment::query()
            ->when($user->user_type === 'admin' && !in_array($user->user_type, ['super_admin', 'national_admin']), function($q) use ($user) {
                $q->whereHas('tournament', function($subQ) use ($user) {
                    $subQ->where('zone_id', $user->zone_id);
                });
            });

        // Assignments by tournament type
        $assignmentsByType = $baseQuery->clone()
            ->with(['tournament.tournamentType']) // ✅ FIXED relationship
            ->whereHas('tournament', function($q) use ($startDate, $endDate) {
                $q->whereBetween('start_date', [$startDate, $endDate]);
            })
            ->get()
            ->groupBy(function($assignment) {
                // ✅ FIXED: tournamentType relationship
                return $assignment->tournament->tournamentType->name ?? 'Sconosciuta';
            })
            ->map(function($assignments) {
                return $assignments->count();
            });

        // Assignments by month
        $assignmentsByMonth = $baseQuery->clone()
            ->whereHas('tournament', function($q) use ($startDate, $endDate) {
                $q->whereBetween('start_date', [$startDate, $endDate]);
            })
            ->get()
            ->groupBy(function($assignment) {
                return $assignment->tournament->start_date->format('Y-m');
            })
            ->map(function($assignments) {
                return $assignments->count();
            })
            ->sortKeys();

        // Top referees by assignments
        $topReferees = $baseQuery->clone()
            ->with(['user'])
            ->whereHas('tournament', function($q) use ($startDate, $endDate) {
                $q->whereBetween('start_date', [$startDate, $endDate]);
            })
            ->get()
            ->groupBy('user_id')
            ->map(function($assignments) {
                return [
                    'referee' => $assignments->first()->user,
                    'count' => $assignments->count(),
                    'confirmed' => $assignments->where('is_confirmed', true)->count()
                ];
            })
            ->sortByDesc('count')
            ->take(10);

        // Zone distribution (only for national admins)
        $zoneDistribution = collect();
        if (in_array($user->user_type, ['super_admin', 'national_admin'])) {
            $zoneDistribution = $baseQuery->clone()
                ->with(['tournament.zone'])
                ->whereHas('tournament', function($q) use ($startDate, $endDate) {
                    $q->whereBetween('start_date', [$startDate, $endDate]);
                })
                ->get()
                ->groupBy(function($assignment) {
                    return $assignment->tournament->zone->name ?? 'Sconosciuta';
                })
                ->map(function($assignments) {
                    return $assignments->count();
                });
        }

        return view('reports.assignments.analytics', compact(
            'assignmentsByType',
            'assignmentsByMonth',
            'topReferees',
            'zoneDistribution',
            'startDate',
            'endDate'
        ));
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\TournamentType;
use Illuminate\Http\Request;
use Illuminate\View\View;

class CategoryReportController extends Controller
{
    /**
     * Display category reports listing.
     */
    public function index(): View
    {
        $categories = TournamentType::withCount('tournaments')
            ->ordered()
            ->get();

        return view('reports.categories.index', compact('types'));
    }

    /**
     * Show specific category report.
     */
    public function show(TournamentCategory $category): View
    {
        return view('reports.categories.show', compact('category'));
    }

    /**
     * Export category report.
     */
    public function export(TournamentCategory $category)
    {
        return response()->json(['message' => 'Export in sviluppo']);
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Models\Zone;
use App\Models\Tournament;
use App\Models\TournamentType;
use App\Models\Club;
use App\Models\TournamentAssignment;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

class DashboardController extends Controller
{
    /**
     * Display the reports dashboard.
     */
    public function index(Request $request)
    {
        $period = $request->get('period', '30'); // days
        $startDate = Carbon::now()->subDays($period);

        // Basic statistics
        $stats = $this->getBasicStats();

        // Growth statistics
        $growth = $this->getGrowthStats($startDate);

        // Activity trends
        $trends = $this->getActivityTrends($startDate);

        // Zone performance
        $zonePerformance = $this->getZonePerformance();

        // Category usage
        $categoryUsage = $this->getCategoryUsage();

        // Recent activity
        $recentActivity = $this->getRecentActivity();

        // System health indicators
        $systemHealth = $this->getSystemHealth();

        return view('reports.dashboard.index', compact(
            'stats',
            'growth',
            'trends',
            'zonePerformance',
            'categoryUsage',
            'recentActivity',
            'systemHealth',
            'period'
        ));
    }

    /**
     * Get basic system statistics.
     */
    private function getBasicStats()
    {
        return [
            'total_users' => User::count(),
            'active_users' => User::where('is_active', true)->count(),
            'total_referees' => User::where('user_type', 'referee')->count(),
            'active_referees' => User::where('user_type', 'referee')->where('is_active', true)->count(),
            'total_zones' => Zone::count(),
            'active_zones' => Zone::where('is_active', true)->count(),
            'total_clubs' => Club::count(),
            'active_clubs' => Club::where('is_active', true)->count(),
            'total_tournaments' => Tournament::count(),
            'active_tournaments' => Tournament::whereIn('status', ['open', 'closed', 'assigned'])->count(),
            'completed_tournaments' => Tournament::where('status', 'completed')->count(),
            'total_categories' => TournamentType::count(),
            'active_categories' => TournamentType::where('is_active', true)->count(),
            'total_assignments' => TournamentAssignment::count(),
            'pending_assignments' => TournamentAssignment::where('status', 'pending')->count(),
            'accepted_assignments' => TournamentAssignment::where('status', 'accepted')->count(),
        ];
    }

    /**
     * Get growth statistics over a period.
     */
    private function getGrowthStats($startDate)
    {
        $previousPeriodStart = $startDate->copy()->subDays($startDate->diffInDays(Carbon::now()));

        // Current period counts
        $currentUsers = User::where('created_at', '>=', $startDate)->count();
        $currentTournaments = Tournament::where('created_at', '>=', $startDate)->count();
        $currentClubs = Club::where('created_at', '>=', $startDate)->count();
        $currentAssignments = TournamentAssignment::where('created_at', '>=', $startDate)->count();

        // Previous period counts
        $previousUsers = User::whereBetween('created_at', [$previousPeriodStart, $startDate])->count();
        $previousTournaments = Tournament::whereBetween('created_at', [$previousPeriodStart, $startDate])->count();
        $previousClubs = Club::whereBetween('created_at', [$previousPeriodStart, $startDate])->count();
        $previousAssignments = TournamentAssignment::whereBetween('created_at', [$previousPeriodStart, $startDate])->count();

        return [
            'users' => [
                'current' => $currentUsers,
                'previous' => $previousUsers,
                'growth' => $previousUsers > 0 ? (($currentUsers - $previousUsers) / $previousUsers) * 100 : 0
            ],
            'tournaments' => [
                'current' => $currentTournaments,
                'previous' => $previousTournaments,
                'growth' => $previousTournaments > 0 ? (($currentTournaments - $previousTournaments) / $previousTournaments) * 100 : 0
            ],
            'clubs' => [
                'current' => $currentClubs,
                'previous' => $previousClubs,
                'growth' => $previousClubs > 0 ? (($currentClubs - $previousClubs) / $previousClubs) * 100 : 0
            ],
            'assignments' => [
                'current' => $currentAssignments,
                'previous' => $previousAssignments,
                'growth' => $previousAssignments > 0 ? (($currentAssignments - $previousAssignments) / $previousAssignments) * 100 : 0
            ],
        ];
    }

    /**
     * Get activity trends over time.
     */
    private function getActivityTrends($startDate)
    {
        $userTrends = User::select(
            DB::raw('DATE(created_at) as date'),
            DB::raw('COUNT(*) as count')
        )
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get()
            ->keyBy('date')
            ->pluck('count');

        $tournamentTrends = Tournament::select(
            DB::raw('DATE(created_at) as date'),
            DB::raw('COUNT(*) as count')
        )
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get()
            ->keyBy('date')
            ->pluck('count');

        $assignmentTrends = TournamentAssignment::select(
            DB::raw('DATE(created_at) as date'),
            DB::raw('COUNT(*) as count')
        )
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get()
            ->keyBy('date')
            ->pluck('count');

        // Fill missing dates with 0
        $dates = [];
        $current = $startDate->copy();
        while ($current <= Carbon::now()) {
            $dateStr = $current->format('Y-m-d');
            $dates[] = [
                'date' => $dateStr,
                'users' => $userTrends->get($dateStr, 0),
                'tournaments' => $tournamentTrends->get($dateStr, 0),
                'assignments' => $assignmentTrends->get($dateStr, 0),
            ];
            $current->addDay();
        }

        return $dates;
    }

    /**
     * Get zone performance statistics.
     */
    private function getZonePerformance()
    {
        return Zone::withCount(['users', 'tournaments', 'clubs'])
            ->orderBy('tournaments_count', 'desc')
            ->limit(10)
            ->get()
            ->map(function ($zone) {
                return [
                    'id' => $zone->id,
                    'name' => $zone->name,
                    'region' => $zone->region,
                    'users_count' => $zone->users_count,
                    'tournaments_count' => $zone->tournaments_count,
                    'clubs_count' => $zone->clubs_count,
                    'is_active' => $zone->is_active,
                ];
            });
    }

    /**
     * Get tournament type usage statistics.
     */
    private function getCategoryUsage()
    {
        return TournamentType::withCount('tournaments')
            ->orderBy('tournaments_count', 'desc')
            ->get()
            ->map(function ($category) {
                return [
                    'id' => $category->id,
                    'name' => $category->name,
                    'code' => $category->code,
                    'tournaments_count' => $category->tournaments_count,
                    'is_national' => $category->is_national,
                    'is_active' => $category->is_active,
                ];
            });
    }

    /**
     * Get recent system activity.
     */
    private function getRecentActivity()
    {
        $activities = [];

        // Recent users
        $recentUsers = User::latest()->limit(5)->get();
        foreach ($recentUsers as $user) {
            $activities[] = [
                'type' => 'user_registered',
                'title' => 'Nuovo utente registrato',
                'description' => "{$user->name} si è registrato come {$user->user_type}",
                'created_at' => $user->created_at,
                'icon' => 'user-plus',
                'color' => 'blue',
            ];
        }

        // Recent tournaments
        $recentTournaments = Tournament::with(['category', 'zone'])->latest()->limit(5)->get();
        foreach ($recentTournaments as $tournament) {
            $activities[] = [
                'type' => 'tournament_created',
                'title' => 'Nuovo torneo creato',
                'description' => $tournament->name . ' (' . ($tournament->tournamentCategory->name ?? 'N/A') . ') - ' . ($tournament->zone->name ?? 'N/A'),
                'created_at' => $tournament->created_at,
                'icon' => 'calendar',
                'color' => 'green',
            ];
        }

        // Recent assignments
        $recentAssignments = TournamentAssignment::with(['tournament', 'referee'])
            ->where('status', 'accepted')
            ->latest()
            ->limit(5)
            ->get();
        foreach ($recentAssignments as $assignment) {
            $activities[] = [
                'type' => 'assignment_accepted',
                'title' => 'Assegnazione accettata',
                'description' => "{$assignment->referee->name} ha accettato {$assignment->tournament->name}",
                'created_at' => $assignment->updated_at,
                'icon' => 'check-circle',
                'color' => 'green',
            ];
        }

        // Sort by creation date
        return collect($activities)->sortByDesc('created_at')->take(15)->values();
    }

    /**
     * Get system health indicators.
     */
    private function getSystemHealth()
    {
        $health = [
            'database' => $this->checkDatabaseHealth(),
            'user_activity' => $this->checkUserActivity(),
            'tournament_activity' => $this->checkTournamentActivity(),
            'assignment_rate' => $this->checkAssignmentRate(),
            'system_errors' => $this->checkSystemErrors(),
        ];

        // Calculate overall health score
        $scores = array_column($health, 'score');
        $overallScore = count($scores) > 0 ? array_sum($scores) / count($scores) : 0;

        $health['overall'] = [
            'score' => $overallScore,
            'status' => $this->getHealthStatus($overallScore),
            'message' => $this->getHealthMessage($overallScore),
        ];

        return $health;
    }

    /**
     * Check database health.
     */
    private function checkDatabaseHealth()
    {
        try {
            DB::connection()->getPdo();
            $tableCount = count(DB::select('SHOW TABLES'));

            return [
                'score' => 100,
                'status' => 'healthy',
                'message' => "Database connesso ({$tableCount} tabelle)",
                'details' => ['tables' => $tableCount]
            ];
        } catch (\Exception $e) {
            return [
                'score' => 0,
                'status' => 'error',
                'message' => 'Errore connessione database',
                'details' => ['error' => $e->getMessage()]
            ];
        }
    }

    /**
     * Check user activity.
     */
    private function checkUserActivity()
    {
        $totalUsers = User::count();
        $activeUsers = User::where('last_login_at', '>=', Carbon::now()->subDays(30))->count();

        if ($totalUsers == 0) {
            $activityRate = 0;
        } else {
            $activityRate = ($activeUsers / $totalUsers) * 100;
        }

        return [
            'score' => min($activityRate, 100),
            'status' => $activityRate >= 70 ? 'healthy' : ($activityRate >= 40 ? 'warning' : 'error'),
            'message' => "{$activeUsers}/{$totalUsers} utenti attivi (ultimi 30 giorni)",
            'details' => [
                'total' => $totalUsers,
                'active' => $activeUsers,
                'rate' => round($activityRate, 1)
            ]
        ];
    }

    /**
     * Check tournament activity.
     */
    private function checkTournamentActivity()
    {
        $recentTournaments = Tournament::where('created_at', '>=', Carbon::now()->subDays(30))->count();
        $activeTournaments = Tournament::whereIn('status', ['open', 'closed', 'assigned'])->count();

        $score = min(($recentTournaments * 10) + ($activeTournaments * 5), 100);

        return [
            'score' => $score,
            'status' => $score >= 70 ? 'healthy' : ($score >= 40 ? 'warning' : 'error'),
            'message' => "{$recentTournaments} tornei creati, {$activeTournaments} attivi",
            'details' => [
                'recent' => $recentTournaments,
                'active' => $activeTournaments
            ]
        ];
    }

    /**
     * Check assignment rate.
     */
    private function checkAssignmentRate()
    {
        $totalAssignments = TournamentAssignment::count();
        $acceptedAssignments = TournamentAssignment::where('status', 'accepted')->count();

        if ($totalAssignments == 0) {
            $acceptanceRate = 100; // No assignments yet, assume healthy
        } else {
            $acceptanceRate = ($acceptedAssignments / $totalAssignments) * 100;
        }

        return [
            'score' => $acceptanceRate,
            'status' => $acceptanceRate >= 80 ? 'healthy' : ($acceptanceRate >= 60 ? 'warning' : 'error'),
            'message' => "{$acceptedAssignments}/{$totalAssignments} assegnazioni accettate",
            'details' => [
                'total' => $totalAssignments,
                'accepted' => $acceptedAssignments,
                'rate' => round($acceptanceRate, 1)
            ]
        ];
    }

    /**
     * Check for system errors.
     */
    private function checkSystemErrors()
    {
        // This is a simplified check - in a real app you'd check log files
        $inactiveZones = Zone::where('is_active', false)->count();
        $inactiveUsers = User::where('is_active', false)->count();

        $issues = $inactiveZones + $inactiveUsers;
        $score = max(100 - ($issues * 5), 0);

        return [
            'score' => $score,
            'status' => $score >= 90 ? 'healthy' : ($score >= 70 ? 'warning' : 'error'),
            'message' => $issues == 0 ? 'Nessun problema rilevato' : "{$issues} elementi disattivati",
            'details' => [
                'inactive_zones' => $inactiveZones,
                'inactive_users' => $inactiveUsers
            ]
        ];
    }

    /**
     * Get health status based on score.
     */
    private function getHealthStatus($score)
    {
        if ($score >= 80) return 'healthy';
        if ($score >= 60) return 'warning';
        return 'error';
    }

    /**
     * Get health message based on score.
     */
    private function getHealthMessage($score)
    {
        if ($score >= 90) return 'Sistema in ottima salute';
        if ($score >= 80) return 'Sistema in buona salute';
        if ($score >= 60) return 'Sistema con alcuni problemi';
        if ($score >= 40) return 'Sistema con problemi significativi';
        return 'Sistema con gravi problemi';
    }

    /**
     * Export dashboard data.
     */
    public function export(Request $request)
    {
        $period = $request->get('period', '30');
        $format = $request->get('format', 'csv');

        $stats = $this->getBasicStats();
        $growth = $this->getGrowthStats(Carbon::now()->subDays($period));

        $data = array_merge($stats, [
            'export_date' => Carbon::now()->format('Y-m-d H:i:s'),
            'period_days' => $period,
        ]);

        if ($format === 'json') {
            return response()->json($data);
        }

        // CSV Export
        $filename = 'dashboard_report_' . Carbon::now()->format('Y-m-d_H-i-s') . '.csv';

        $headers = [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ];

        $callback = function () use ($data) {
            $file = fopen('php://output', 'w');

            // CSV headers
            fputcsv($file, ['Metrica', 'Valore']);

            foreach ($data as $key => $value) {
                if (is_numeric($value)) {
                    fputcsv($file, [ucfirst(str_replace('_', ' ', $key)), $value]);
                }
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\View\View;

class RefereeReportController extends Controller
{
    /**
     * Display referee report.
     */
    public function show(User $referee): View
    {
        // Check that user is actually a referee
        if (!$referee->isReferee()) {
            abort(404, 'Utente non trovato.');
        }

        // Check access
        $this->checkRefereeAccess($referee);

        // Load relationships and statistics
        $referee->load([
            'zone',
            'assignments.tournament.club',
            'availabilities.tournament.club'
        ]);

        // Get statistics
        $stats = [
            'total_assignments' => $referee->assignments()->count(),
            'confirmed_assignments' => $referee->assignments()->where('is_confirmed', true)->count(),
            'current_year_assignments' => $referee->assignments()->whereYear('created_at', now()->year)->count(),
            'total_availabilities' => $referee->availabilities()->count(),
            'current_year_availabilities' => $referee->availabilities()->whereYear('created_at', now()->year)->count(),
            'upcoming_assignments' => $referee->assignments()->upcoming()->count(),
        ];

        // Get recent assignments
        $recentAssignments = $referee->assignments()
            ->with(['tournament.club', 'tournament.zone'])
            ->orderBy('created_at', 'desc')
            ->limit(10)
            ->get();

        return view('reports.referee.show', compact('referee', 'stats', 'recentAssignments'));
    }

    /**
     * Export referee report.
     */
    public function export(User $referee)
    {
        $this->checkRefereeAccess($referee);

        // TODO: Implement export functionality
        return response()->json([
            'message' => 'Export functionality coming soon'
        ]);
    }

    /**
     * Check if user can access referee reports.
     */
    private function checkRefereeAccess(User $referee): void
    {
        $user = auth()->user();

        // Super admin and national admin can access all
        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        // Zone admin can access referees in their zone
        if ($user->user_type === 'admin' && $user->zone_id === $referee->zone_id) {
            return;
        }

        // Referees can only access their own reports
        if ($user->isReferee() && $user->id === $referee->id) {
            return;
        }

        abort(403, 'Non sei autorizzato ad accedere a questo report.');
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\Zone;
use App\Models\Tournament;
use App\Models\User;
use App\Models\Assignment;
use Illuminate\Http\Request;
use Illuminate\View\View;

class ReportController extends Controller
{
    /**
     * Display reports dashboard.
     */
    public function index(): View
    {
        $user = auth()->user();

        // Get user's accessible zones
        $zones = $this->getAccessibleZones($user);

        // Get recent tournaments
        $recentTournaments = $this->getAccessibleTournaments($user)
            ->with(['club', 'zone', 'tournamentType'])
            ->orderBy('start_date', 'desc')
            ->limit(10)
            ->get();

        // Get statistics based on user access
        $stats = $this->getAccessibleStats($user);

        return view('reports.index', compact('zones', 'recentTournaments', 'stats'));
    }

    /**
     * Get zones accessible to the user.
     */
    private function getAccessibleZones($user)
    {
        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return Zone::orderBy('name')->get();
        }

        return Zone::where('id', $user->zone_id)->get();
    }

    /**
     * Get tournaments accessible to the user.
     */
    private function getAccessibleTournaments($user)
    {
        $query = Tournament::query();

        if ($user->user_type === 'admin' && $user->user_type !== 'super_admin' && $user->user_type !== 'national_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        return $query;
    }

    /**
     * Get statistics based on user access.
     */
    private function getAccessibleStats($user): array
    {
        $tournamentsQuery = $this->getAccessibleTournaments($user);
        $assignmentsQuery = Assignment::query();

        if ($user->user_type === 'admin' && $user->user_type !== 'super_admin' && $user->user_type !== 'national_admin') {
            $assignmentsQuery->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        return [
            'total_tournaments' => $tournamentsQuery->count(),
            'upcoming_tournaments' => $tournamentsQuery->upcoming()->count(),
            'active_tournaments' => $tournamentsQuery->active()->count(),
            'total_assignments' => $assignmentsQuery->count(),
            'confirmed_assignments' => $assignmentsQuery->where('is_confirmed', true)->count(),
            'current_year_assignments' => $assignmentsQuery->whereYear('created_at', now()->year)->count(),
        ];
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use Illuminate\View\View;

class TournamentReportController extends Controller
{
    /**
     * Display tournament report.
     */
    public function show(Tournament $tournament): View
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Load relationships
        $tournament->load([
            'club',
            'zone',
            'tournamentType',
            'availabilities.user',
            'assignments.user',
            'assignments.assignedBy'
        ]);

        // Get statistics
        $stats = [
            'total_availabilities' => $tournament->availabilities()->count(),
            'total_assignments' => $tournament->assignments()->count(),
            'confirmed_assignments' => $tournament->assignments()->where('is_confirmed', true)->count(),
            'required_referees' => $tournament->required_referees,
            'max_referees' => $tournament->max_referees,
            'days_until_start' => $tournament->start_date ? now()->diffInDays($tournament->start_date, false) : null,
        ];

        return view('reports.tournament.show', compact('tournament', 'stats'));
    }

    /**
     * Export tournament report.
     */
    public function export(Tournament $tournament)
    {
        $this->checkTournamentAccess($tournament);

        // TODO: Implement export functionality
        return response()->json([
            'message' => 'Export functionality coming soon'
        ]);
    }

    /**
     * Check if user can access tournament reports.
     */
    private function checkTournamentAccess(Tournament $tournament): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $user->zone_id !== $tournament->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere ai report di questo torneo.');
        }
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\Zone;
use App\Models\User;
use App\Models\Tournament;
use App\Models\Assignment;
use Illuminate\Http\Request;
use Illuminate\View\View;
use Carbon\Carbon;

class ZoneReportController extends Controller
{
    /**
     * Display zone overview report.
     */
    public function show(Zone $zone): View
    {
        // Check access
        $this->checkZoneAccess($zone);

        // Get statistics
        $stats = [
            'total_referees' => $zone->referees()->count(),
            'active_referees' => $zone->referees()->where('is_active', true)->count(),
            'total_clubs' => $zone->clubs()->count(),
            'active_clubs' => $zone->clubs()->where('is_active', true)->count(),
            'total_tournaments' => $zone->tournaments()->count(),
            'upcoming_tournaments' => $zone->tournaments()->upcoming()->count(),
            'active_tournaments' => $zone->tournaments()->active()->count(),
            'completed_tournaments' => $zone->tournaments()->where('status', 'completed')->count(),
        ];

        // Get referees by level
        $refereesByLevel = $zone->referees()
            ->where('is_active', true)
            ->selectRaw('level, COUNT(*) as total')
            ->groupBy('level')
            ->get()
            ->pluck('total', 'level')
            ->toArray();

        // Get recent tournaments
        $recentTournaments = $zone->tournaments()
            ->with(['club', 'tournamentType'])
            ->orderBy('start_date', 'desc')
            ->limit(10)
            ->get();

        // Get assignment statistics
        $assignmentStats = [
            'total_assignments' => Assignment::whereHas('tournament', function($q) use ($zone) {
                $q->where('zone_id', $zone->id);
            })->count(),
            'confirmed_assignments' => Assignment::whereHas('tournament', function($q) use ($zone) {
                $q->where('zone_id', $zone->id);
            })->where('is_confirmed', true)->count(),
            'current_year' => Assignment::whereHas('tournament', function($q) use ($zone) {
                $q->where('zone_id', $zone->id);
            })->whereYear('created_at', now()->year)->count(),
        ];

        return view('reports.zone.show', compact(
            'zone',
            'stats',
            'refereesByLevel',
            'recentTournaments',
            'assignmentStats'
        ));
    }

    /**
     * Display zone referees report.
     */
    public function referees(Zone $zone): View
    {
        $this->checkZoneAccess($zone);

        $referees = $zone->referees()
            ->with(['assignments' => function($q) {
                $q->whereYear('created_at', now()->year);
            }])
            ->withCount([
                'assignments',
                'assignments as current_year_assignments' => function($q) {
                    $q->whereYear('created_at', now()->year);
                },
                'availabilities'
            ])
            ->orderBy('is_active', 'desc')
            ->orderBy('level')
            ->orderBy('name')
            ->paginate(20);

        return view('reports.zone.referees', compact('zone', 'referees'));
    }

    /**
     * Display zone tournaments report.
     */
    public function tournaments(Zone $zone): View
    {
        $this->checkZoneAccess($zone);

        $tournaments = $zone->tournaments()
            ->with(['club', 'tournamentType'])
            ->withCount(['assignments', 'availabilities'])
            ->orderBy('start_date', 'desc')
            ->paginate(20);

        return view('reports.zone.tournaments', compact('zone', 'tournaments'));
    }

    /**
     * Export zone report.
     */
    public function export(Zone $zone)
    {
        $this->checkZoneAccess($zone);

        // TODO: Implement export functionality
        return response()->json([
            'message' => 'Export functionality coming soon'
        ]);
    }

    /**
     * Check if user can access zone reports.
     */
    private function checkZoneAccess(Zone $zone): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $user->zone_id !== $zone->id) {
            abort(403, 'Non sei autorizzato ad accedere ai report di questa zona.');
        }
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;

class SystemController extends Controller
{
    /**
     * Display system logs.
     */
    public function logs(Request $request)
    {
        $logFile = $request->get('file', 'laravel.log');
        $logPath = storage_path("logs/{$logFile}");

        $logs = [];
        $availableFiles = [];

        // Get available log files
        $logFiles = File::files(storage_path('logs'));
        foreach ($logFiles as $file) {
            if (pathinfo($file, PATHINFO_EXTENSION) === 'log') {
                $availableFiles[] = $file->getFilename();
            }
        }

        // Read log file if exists
        if (File::exists($logPath)) {
            $content = File::get($logPath);
            $lines = array_reverse(explode("\n", $content));

            foreach ($lines as $line) {
                if (trim($line) && preg_match('/^\[(.*?)\].*?(ERROR|WARNING|INFO|DEBUG).*?: (.*)/', $line, $matches)) {
                    $logs[] = [
                        'timestamp' => $matches[1],
                        'level' => $matches[2],
                        'message' => $matches[3],
                        'full_line' => $line
                    ];
                }

                // Limit to 1000 entries for performance
                if (count($logs) >= 1000) {
                    break;
                }
            }
        }

        return view('super-admin.system.logs', compact('logs', 'availableFiles', 'logFile'));
    }

    /**
     * Display system activity.
     */
    public function activity(Request $request)
    {
        $period = $request->get('period', '7'); // days
        $startDate = now()->subDays($period);

        // User activity
        $userActivity = DB::table('users')
            ->select(DB::raw('DATE(updated_at) as date'), DB::raw('count(*) as count'))
            ->where('updated_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        // Tournament activity
        $tournamentActivity = DB::table('tournaments')
            ->select(DB::raw('DATE(created_at) as date'), DB::raw('count(*) as count'))
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        // Assignment activity
        $assignmentActivity = DB::table('tournament_assignments')
            ->select(DB::raw('DATE(created_at) as date'), DB::raw('count(*) as count'))
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        // Active users
        $activeUsers = DB::table('users')
            ->where('last_login_at', '>=', now()->subDays(1))
            ->count();

        // System stats
        $systemStats = [
            'total_users' => DB::table('users')->count(),
            'active_users_24h' => $activeUsers,
            'total_tournaments' => DB::table('tournaments')->count(),
            'active_tournaments' => DB::table('tournaments')->whereIn('status', ['open', 'closed', 'assigned'])->count(),
            'total_assignments' => DB::table('tournament_assignments')->count(),
            'pending_assignments' => DB::table('tournament_assignments')->where('status', 'pending')->count(),
        ];

        return view('super-admin.system.activity', compact(
            'userActivity',
            'tournamentActivity',
            'assignmentActivity',
            'systemStats',
            'period'
        ));
    }

    /**
     * Display system performance metrics.
     */
    public function performance(Request $request)
    {
        $metrics = $this->getPerformanceMetrics();
        $dbStats = $this->getDatabaseStats();
        $cacheStats = $this->getCacheStats();

        return view('super-admin.system.performance', compact('metrics', 'dbStats', 'cacheStats'));
    }

    /**
     * Toggle maintenance mode.
     */
    public function toggleMaintenance(Request $request)
    {
        try {
            if (app()->isDownForMaintenance()) {
                Artisan::call('up');
                $message = 'Modalità manutenzione disattivata.';
                $status = false;
            } else {
                $secret = $request->get('secret', \Str::random(8));
                Artisan::call('down', [
                    '--secret' => $secret,
                    '--render' => 'errors.503'
                ]);
                $message = 'Modalità manutenzione attivata.';
                $status = true;
            }

            return response()->json([
                'success' => true,
                'message' => $message,
                'maintenance_mode' => $status
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Errore: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * Clear specific cache types.
     */
    public function clearCache(Request $request)
    {
        $type = $request->get('type', 'all');

        try {
            switch ($type) {
                case 'config':
                    Artisan::call('config:clear');
                    $message = 'Cache configurazione svuotata.';
                    break;

                case 'view':
                    Artisan::call('view:clear');
                    $message = 'Cache viste svuotata.';
                    break;

                case 'route':
                    Artisan::call('route:clear');
                    $message = 'Cache rotte svuotata.';
                    break;

                case 'application':
                    Cache::flush();
                    $message = 'Cache applicazione svuotata.';
                    break;

                default:
                    Artisan::call('cache:clear');
                    Artisan::call('config:clear');
                    Artisan::call('view:clear');
                    Artisan::call('route:clear');
                    Cache::flush();
                    $message = 'Tutte le cache svuotate.';
            }

            return response()->json([
                'success' => true,
                'message' => $message
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Errore: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * Optimize system performance.
     */
    public function optimize(Request $request)
    {
        try {
            Artisan::call('config:cache');
            Artisan::call('route:cache');
            Artisan::call('view:cache');

            if (app()->environment('production')) {
                Artisan::call('optimize');
            }

            return response()->json([
                'success' => true,
                'message' => 'Sistema ottimizzato con successo.'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Errore: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * Run system diagnostics.
     */
    public function diagnostics()
    {
        $diagnostics = [
            'php_version' => [
                'value' => PHP_VERSION,
                'status' => version_compare(PHP_VERSION, '8.1.0', '>=') ? 'success' : 'warning',
                'message' => version_compare(PHP_VERSION, '8.1.0', '>=') ? 'OK' : 'Aggiornamento consigliato'
            ],
            'laravel_version' => [
                'value' => app()->version(),
                'status' => 'success',
                'message' => 'OK'
            ],
            'database_connection' => [
                'value' => $this->testDatabaseConnection(),
                'status' => $this->testDatabaseConnection() ? 'success' : 'error',
                'message' => $this->testDatabaseConnection() ? 'Connessa' : 'Errore connessione'
            ],
            'cache_working' => [
                'value' => $this->testCache(),
                'status' => $this->testCache() ? 'success' : 'warning',
                'message' => $this->testCache() ? 'Funzionante' : 'Problemi rilevati'
            ],
            'storage_writable' => [
                'value' => is_writable(storage_path()),
                'status' => is_writable(storage_path()) ? 'success' : 'error',
                'message' => is_writable(storage_path()) ? 'Scrivibile' : 'Non scrivibile'
            ],
            'disk_space' => [
                'value' => $this->getAvailableDiskSpace(),
                'status' => $this->getAvailableDiskSpace() > 1000 ? 'success' : 'warning',
                'message' => $this->formatBytes($this->getAvailableDiskSpace()) . ' disponibili'
            ],
            'memory_usage' => [
                'value' => memory_get_usage(true),
                'status' => memory_get_usage(true) < 128 * 1024 * 1024 ? 'success' : 'warning',
                'message' => $this->formatBytes(memory_get_usage(true)) . ' in uso'
            ]
        ];

        return response()->json($diagnostics);
    }

    /**
     * Get performance metrics.
     */
    private function getPerformanceMetrics()
    {
        return [
            'memory_usage' => [
                'current' => memory_get_usage(true),
                'peak' => memory_get_peak_usage(true),
                'limit' => $this->parseSize(ini_get('memory_limit'))
            ],
            'execution_time' => [
                'max' => ini_get('max_execution_time'),
                'current' => microtime(true) - LARAVEL_START
            ],
            'upload_limits' => [
                'max_filesize' => $this->parseSize(ini_get('upload_max_filesize')),
                'post_max_size' => $this->parseSize(ini_get('post_max_size'))
            ]
        ];
    }

    /**
     * Get database statistics.
     */
    private function getDatabaseStats()
    {
        try {
            $stats = [
                'connection' => DB::connection()->getDatabaseName(),
                'tables_count' => count(DB::select('SHOW TABLES')),
                'size' => $this->getDatabaseSize(),
            ];

            // Table sizes
            $tables = DB::select("
                SELECT table_name as 'table',
                       ROUND(((data_length + index_length) / 1024 / 1024), 2) as 'size_mb'
                FROM information_schema.TABLES
                WHERE table_schema = DATABASE()
                ORDER BY (data_length + index_length) DESC
                LIMIT 10
            ");

            $stats['largest_tables'] = $tables;

            return $stats;
        } catch (\Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Get cache statistics.
     */
    private function getCacheStats()
    {
        try {
            return [
                'driver' => config('cache.default'),
                'working' => $this->testCache(),
                'keys_count' => $this->getCacheKeysCount()
            ];
        } catch (\Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Test database connection.
     */
    private function testDatabaseConnection()
    {
        try {
            DB::connection()->getPdo();
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Test cache functionality.
     */
    private function testCache()
    {
        try {
            $key = 'test_cache_key_' . time();
            Cache::put($key, 'test_value', 60);
            $value = Cache::get($key);
            Cache::forget($key);
            return $value === 'test_value';
        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Get available disk space in bytes.
     */
    private function getAvailableDiskSpace()
    {
        return disk_free_space(storage_path());
    }

    /**
     * Get database size.
     */
    private function getDatabaseSize()
    {
        try {
            $result = DB::select("
                SELECT ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) as size_mb
                FROM information_schema.TABLES
                WHERE table_schema = DATABASE()
            ");

            return $result[0]->size_mb ?? 0;
        } catch (\Exception $e) {
            return 0;
        }
    }

    /**
     * Get cache keys count (approximation).
     */
    private function getCacheKeysCount()
    {
        try {
            // This is a simplified approach - actual implementation depends on cache driver
            return 'N/A';
        } catch (\Exception $e) {
            return 'Error';
        }
    }

    /**
     * Parse size string to bytes.
     */
    private function parseSize($size)
    {
        $unit = preg_replace('/[^bkmgtpezy]/i', '', $size);
        $size = preg_replace('/[^0-9\.]/', '', $size);

        if ($unit) {
            return round($size * pow(1024, stripos('bkmgtpezy', $unit[0])));
        }

        return round($size);
    }

    /**
     * Format bytes to human readable.
     */
    private function formatBytes($size, $precision = 2)
    {
        $base = log($size, 1024);
        $suffixes = array('B', 'KB', 'MB', 'GB', 'TB');

        return round(pow(1024, $base - floor($base)), $precision) . ' ' . $suffixes[floor($base)];
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Cache;
use App\Models\Setting;

class SystemSettingsController extends Controller
{
    /**
     * Display the system settings.
     */
    public function index()
    {
        $settings = $this->getCurrentSettings();
        $systemInfo = $this->getSystemInfo();

        return view('super-admin.settings.index', compact('settings', 'systemInfo'));
    }

    /**
     * Update the system settings.
     */
    public function update(Request $request)
    {
        $request->validate([
            'app_name' => 'required|string|max:255',
            'app_timezone' => 'required|string',
            'app_locale' => 'required|string',
            'mail_driver' => 'required|string',
            'mail_host' => 'nullable|string',
            'mail_port' => 'nullable|integer',
            'mail_username' => 'nullable|string',
            'mail_password' => 'nullable|string',
            'mail_encryption' => 'nullable|string',
            'mail_from_address' => 'required|email',
            'mail_from_name' => 'required|string',
            'system_maintenance' => 'boolean',
            'system_debug' => 'boolean',
            'cache_driver' => 'required|string',
            'session_lifetime' => 'required|integer|min:1|max:1440',
            'max_upload_size' => 'required|integer|min:1|max:100',
            'backup_enabled' => 'boolean',
            'backup_frequency' => 'required|string',
            'log_level' => 'required|string',
            'api_rate_limit' => 'required|integer|min:1|max:10000',
        ]);

        try {
            // Update database settings
            $this->updateSettings($request->all());

            // Clear cache
            Cache::flush();

            // Update .env file for critical settings
            $this->updateEnvFile([
                'APP_NAME' => $request->app_name,
                'APP_TIMEZONE' => $request->app_timezone,
                'APP_LOCALE' => $request->app_locale,
                'APP_DEBUG' => $request->system_debug ? 'true' : 'false',
                'MAIL_MAILER' => $request->mail_driver,
                'MAIL_HOST' => $request->mail_host,
                'MAIL_PORT' => $request->mail_port,
                'MAIL_USERNAME' => $request->mail_username,
                'MAIL_FROM_ADDRESS' => $request->mail_from_address,
                'MAIL_FROM_NAME' => $request->mail_from_name,
                'SESSION_LIFETIME' => $request->session_lifetime,
            ]);

            return redirect()->route('super-admin.settings.index')
                ->with('success', 'Impostazioni aggiornate con successo.');

        } catch (\Exception $e) {
            return redirect()->route('super-admin.settings.index')
                ->with('error', 'Errore durante l\'aggiornamento: ' . $e->getMessage());
        }
    }

    /**
     * Clear system cache
     */
    public function clearCache()
    {
        try {
            Artisan::call('cache:clear');
            Artisan::call('config:clear');
            Artisan::call('view:clear');
            Artisan::call('route:clear');

            return response()->json(['success' => true, 'message' => 'Cache svuotata con successo']);
        } catch (\Exception $e) {
            return response()->json(['success' => false, 'message' => 'Errore: ' . $e->getMessage()]);
        }
    }

    /**
     * Optimize system
     */
    public function optimize()
    {
        try {
            Artisan::call('config:cache');
            Artisan::call('route:cache');
            Artisan::call('view:cache');

            return response()->json(['success' => true, 'message' => 'Sistema ottimizzato con successo']);
        } catch (\Exception $e) {
            return response()->json(['success' => false, 'message' => 'Errore: ' . $e->getMessage()]);
        }
    }

    /**
     * Get current settings
     */
    private function getCurrentSettings()
    {
        return [
            'app_name' => config('app.name'),
            'app_timezone' => config('app.timezone'),
            'app_locale' => config('app.locale'),
            'mail_driver' => config('mail.default'),
            'mail_host' => config('mail.mailers.smtp.host'),
            'mail_port' => config('mail.mailers.smtp.port'),
            'mail_username' => config('mail.mailers.smtp.username'),
            'mail_encryption' => config('mail.mailers.smtp.encryption'),
            'mail_from_address' => config('mail.from.address'),
            'mail_from_name' => config('mail.from.name'),
            'system_maintenance' => app()->isDownForMaintenance(),
            'system_debug' => config('app.debug'),
            'cache_driver' => config('cache.default'),
            'session_lifetime' => config('session.lifetime'),
            'max_upload_size' => ini_get('upload_max_filesize'),
            'backup_enabled' => $this->getSetting('backup_enabled', false),
            'backup_frequency' => $this->getSetting('backup_frequency', 'daily'),
            'log_level' => config('logging.level'),
            'api_rate_limit' => $this->getSetting('api_rate_limit', 1000),
        ];
    }

    /**
     * Get system information
     */
    private function getSystemInfo()
    {
        return [
            'php_version' => PHP_VERSION,
            'laravel_version' => app()->version(),
            'server_software' => $_SERVER['SERVER_SOFTWARE'] ?? 'Unknown',
            'database_size' => $this->getDatabaseSize(),
            'storage_used' => $this->getStorageUsed(),
            'log_size' => $this->getLogSize(),
            'uptime' => $this->getSystemUptime(),
            'memory_usage' => $this->getMemoryUsage(),
        ];
    }

    /**
     * Update settings in database
     */
    private function updateSettings(array $settings)
    {
        foreach ($settings as $key => $value) {
            Setting::updateOrCreate(
                ['key' => $key],
                ['value' => $value]
            );
        }
    }

    /**
     * Get setting value
     */
    private function getSetting($key, $default = null)
    {
        $setting = Setting::where('key', $key)->first();
        return $setting ? $setting->value : $default;
    }

    /**
     * Update .env file
     */
    private function updateEnvFile(array $data)
    {
        $envFile = base_path('.env');

        if (!File::exists($envFile)) {
            return;
        }

        $envContent = File::get($envFile);

        foreach ($data as $key => $value) {
            if ($value === null) continue;

            $pattern = "/^{$key}=.*/m";
            $replacement = "{$key}=\"{$value}\"";

            if (preg_match($pattern, $envContent)) {
                $envContent = preg_replace($pattern, $replacement, $envContent);
            } else {
                $envContent .= "\n{$replacement}";
            }
        }

        File::put($envFile, $envContent);
    }

    /**
     * Helper methods for system info
     */
    private function getDatabaseSize()
    {
        try {
            $size = \DB::selectOne("SELECT pg_size_pretty(pg_database_size(current_database())) as size");
            return $size->size ?? 'N/A';
        } catch (\Exception $e) {
            return 'N/A';
        }
    }

    private function getStorageUsed()
    {
        $bytes = disk_total_space(storage_path()) - disk_free_space(storage_path());
        return $this->formatBytes($bytes);
    }

    private function getLogSize()
    {
        $logPath = storage_path('logs');
        $size = 0;

        if (is_dir($logPath)) {
            foreach (new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($logPath)) as $file) {
                $size += $file->getSize();
            }
        }

        return $this->formatBytes($size);
    }

    private function getSystemUptime()
    {
        if (function_exists('sys_getloadavg')) {
            $uptime = shell_exec('uptime');
            return $uptime ? trim($uptime) : 'N/A';
        }
        return 'N/A';
    }

    private function getMemoryUsage()
    {
        $memory = memory_get_usage(true);
        return $this->formatBytes($memory);
    }

    private function formatBytes($bytes, $precision = 2)
    {
        $units = array('B', 'KB', 'MB', 'GB', 'TB');

        for ($i = 0; $bytes > 1024 && $i < count($units) - 1; $i++) {
            $bytes /= 1024;
        }

        return round($bytes, $precision) . ' ' . $units[$i];
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use App\Http\Requests\TournamentTypeRequest; // ✅ FIXED: Request name aligned
use App\Models\TournamentType; // ✅ FIXED: Model aligned with database convention
use App\Models\Zone;
use Illuminate\Http\Request;

class TournamentTypeController extends Controller
{
    /**
     * Display a listing of the tournament types.
     */
    public function index()
    {
        // ✅ FIXED: Variable name from $categories to $tournamentTypes
        $tournamentTypes = TournamentType::withCount('tournaments')
            ->ordered()
            ->get();

        // ✅ FIXED: compact() uses tournamentTypes
        return view('super-admin.tournament-types.index', compact('tournamentTypes'));
    }

    /**
     * Show the form for creating a new tournament type.
     */
    public function create()
    {
        $zones = Zone::where('is_national', false)->orderBy('name')->get();
        $refereeLevels = TournamentType::REFEREE_LEVELS;
        $categoryLevels = TournamentType::CATEGORY_LEVELS;

        return view('super-admin.tournament-types.create', compact(
            'zones',
            'refereeLevels',
            'categoryLevels'
        ));
    }

    /**
     * Store a newly created tournament type in storage.
     */
    public function store(TournamentTypeRequest $request)
    {
        $data = $request->validated();

        // Prepara le impostazioni per il campo JSON
        $settings = [
            'required_referee_level' => $data['required_referee_level'] ?? 'aspirante',
            'min_referees' => $data['min_referees'] ?? 1,
            'max_referees' => $data['max_referees'] ?? $data['min_referees'] ?? 1,
            'special_requirements' => $data['special_requirements'] ?? null,
            'notification_templates' => $data['notification_templates'] ?? [],
        ];

        // Gestione visibility_zones
        if ($data['is_national'] ?? false) {
            $settings['visibility_zones'] = 'all';
        } else {
            $settings['visibility_zones'] = $data['visibility_zones'] ?? [];
        }

        // ✅ FIXED: Create using TournamentType model
        $tournamentType = TournamentType::create([
            'name' => $data['name'],
            'code' => strtoupper($data['code']),
            'description' => $data['description'] ?? null,
            'is_national' => $data['is_national'] ?? false,
            'level' => $data['level'] ?? 'zonale',
            'required_level' => $data['required_referee_level'] ?? 'aspirante',
            'sort_order' => $data['sort_order'] ?? 0,
            'is_active' => $data['is_active'] ?? true,

            // Colonne fisiche
            'min_referees' => $data['min_referees'] ?? 1,
            'max_referees' => $data['max_referees'] ?? $data['min_referees'] ?? 1,

            // Campo JSON (sincronizzato automaticamente dal modello)
            'settings' => $settings,
        ]);

        return redirect()
            ->route('super-admin.tournament-types.index')
            ->with('success', 'Tipo torneo creato con successo!');
    }

    /**
     * Display the specified tournament type.
     */
    public function show(TournamentType $tournamentType)
    {
        $tournamentType->loadCount('tournaments');
        $recentTournaments = $tournamentType->tournaments()
            ->with(['club', 'zone'])
            ->latest()
            ->limit(10)
            ->get();

        return view('super-admin.tournament-types.show', compact(
            'tournamentType',
            'recentTournaments'
        ));
    }

    /**
     * Show the form for editing the specified tournament type.
     */
    public function edit(TournamentType $tournamentType)
    {
        $zones = Zone::where('is_national', false)->orderBy('name')->get();
        $refereeLevels = TournamentType::REFEREE_LEVELS;
        $categoryLevels = TournamentType::CATEGORY_LEVELS;

        return view('super-admin.tournament-types.edit', compact(
            'tournamentType',
            'zones',
            'refereeLevels',
            'categoryLevels'
        ));
    }

    /**
     * Update the specified tournament type in storage.
     */
    public function update(TournamentTypeRequest $request, TournamentType $tournamentType)
    {
        $data = $request->validated();

        // Prepara le impostazioni per il campo JSON
        $settings = [
            'required_referee_level' => $data['required_referee_level'] ?? 'aspirante',
            'min_referees' => $data['min_referees'] ?? 1,
            'max_referees' => $data['max_referees'] ?? $data['min_referees'] ?? 1,
            'special_requirements' => $data['special_requirements'] ?? null,
            'notification_templates' => $data['notification_templates'] ?? [],
        ];

        // Gestione visibility_zones
        if ($data['is_national'] ?? false) {
            $settings['visibility_zones'] = 'all';
        } else {
            $settings['visibility_zones'] = $data['visibility_zones'] ?? [];
        }

        // ✅ FIXED: Update TournamentType model
        $tournamentType->update([
            'name' => $data['name'],
            'code' => strtoupper($data['code']),
            'description' => $data['description'] ?? null,
            'is_national' => $data['is_national'] ?? false,
            'level' => $data['level'] ?? 'zonale',
            'required_level' => $data['required_referee_level'] ?? 'aspirante',
            'sort_order' => $data['sort_order'] ?? 0,
            'is_active' => $data['is_active'] ?? true,

            // Colonne fisiche
            'min_referees' => $data['min_referees'] ?? 1,
            'max_referees' => $data['max_referees'] ?? $data['min_referees'] ?? 1,

            // Campo JSON (sincronizzato automaticamente dal modello)
            'settings' => $settings,
        ]);

        return redirect()
            ->route('super-admin.tournament-types.show', $tournamentType)
            ->with('success', 'Tipo torneo aggiornato con successo!');
    }

    /**
     * Remove the specified tournament type from storage.
     */
    public function destroy(TournamentType $tournamentType)
    {
        if (!$tournamentType->canBeDeleted()) {
            return redirect()
                ->route('super-admin.tournament-types.index')
                ->with('error', 'Impossibile eliminare un tipo con tornei associati.');
        }

        $name = $tournamentType->name;
        $tournamentType->delete();

        return redirect()
            ->route('super-admin.tournament-types.index')
            ->with('success', "Tipo torneo \"{$name}\" eliminato con successo!");
    }

    /**
     * Toggle active status.
     */
    public function toggleActive(TournamentType $tournamentType)
    {
        $tournamentType->update([
            'is_active' => !$tournamentType->is_active
        ]);

        $status = $tournamentType->is_active ? 'attivato' : 'disattivato';

        return redirect()->back()
            ->with('success', "Tipo \"{$tournamentType->name}\" {$status} con successo!");
    }

    /**
     * Update display order.
     */
    public function updateOrder(Request $request)
    {
        $request->validate([
            // ✅ FIXED: tournament_types instead of categories
            'tournament_types' => 'required|array',
            'tournament_types.*.id' => 'required|exists:tournament_types,id',
            'tournament_types.*.sort_order' => 'required|integer|min:0',
        ]);

        // ✅ FIXED: tournament_types instead of categories
        foreach ($request->tournament_types as $typeData) {
            TournamentType::where('id', $typeData['id'])
                ->update(['sort_order' => $typeData['sort_order']]);
        }

        return response()->json(['success' => true]);
    }

    /**
     * Duplicate a tournament type.
     */
    public function duplicate(TournamentType $tournamentType)
    {
        $newType = $tournamentType->replicate();
        $newType->name = $tournamentType->name . ' (Copia)';
        $newType->code = $tournamentType->code . '_COPY';
        $newType->sort_order = TournamentType::max('sort_order') + 10;
        $newType->is_active = false;
        $newType->save();

        return redirect()
            ->route('super-admin.tournament-types.edit', $newType)
            ->with('success', "Tipo duplicato con successo! Modifica i dettagli e attivalo quando pronto.");
    }

    /**
     * Get tournament types statistics.
     */
    public function statistics()
    {
        $stats = [
            'total_types' => TournamentType::count(),
            'active_types' => TournamentType::where('is_active', true)->count(),
            'national_types' => TournamentType::where('is_national', true)->count(),
            'zonal_types' => TournamentType::where('is_national', false)->count(),
            'types_with_tournaments' => TournamentType::has('tournaments')->count(),
        ];

        // Types by usage
        $typesByUsage = TournamentType::withCount('tournaments')
            ->orderBy('tournaments_count', 'desc')
            ->limit(10)
            ->get()
            ->map(function($type) {
                return [
                    'id' => $type->id,
                    'name' => $type->name,
                    'code' => $type->code,
                    'tournaments_count' => $type->tournaments_count,
                    'is_national' => $type->is_national,
                    'is_active' => $type->is_active,
                ];
            });

        return response()->json([
            'stats' => $stats,
            'types_by_usage' => $typesByUsage,
        ]);
    }

    /**
     * Export tournament types data.
     */
    public function export(Request $request)
    {
        $tournamentTypes = TournamentType::withCount('tournaments')->get();

        $filename = 'tournament_types_export_' . now()->format('Y-m-d_H-i-s') . '.csv';

        $headers = [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ];

        $callback = function() use ($tournamentTypes) {
            $file = fopen('php://output', 'w');

            // CSV headers
            fputcsv($file, [
                'ID',
                'Nome',
                'Codice',
                'Descrizione',
                'Tipo',
                'Livello Richiesto',
                'Min Arbitri',
                'Max Arbitri',
                'Ordine',
                'Attivo',
                'Tornei Associati',
                'Data Creazione'
            ]);

            foreach ($tournamentTypes as $type) {
                fputcsv($file, [
                    $type->id,
                    $type->name,
                    $type->code,
                    $type->description ?? '',
                    $type->is_national ? 'Nazionale' : 'Zonale',
                    $type->required_level,
                    $type->min_referees,
                    $type->max_referees,
                    $type->sort_order,
                    $type->is_active ? 'Sì' : 'No',
                    $type->tournaments_count ?? 0,
                    $type->created_at->format('d/m/Y H:i')
                ]);
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }

    /**
     * Bulk operations on tournament types.
     */
    public function bulkAction(Request $request)
    {
        $request->validate([
            'action' => 'required|in:activate,deactivate,delete',
            'tournament_type_ids' => 'required|array|min:1',
            'tournament_type_ids.*' => 'exists:tournament_types,id'
        ]);

        $tournamentTypes = TournamentType::whereIn('id', $request->tournament_type_ids);

        switch ($request->action) {
            case 'activate':
                $tournamentTypes->update(['is_active' => true]);
                $message = 'Tipi torneo attivati con successo.';
                break;

            case 'deactivate':
                $tournamentTypes->update(['is_active' => false]);
                $message = 'Tipi torneo disattivati con successo.';
                break;

            case 'delete':
                // Check if any type has tournaments
                $hasToournaments = $tournamentTypes->has('tournaments')->exists();

                if ($hasToournaments) {
                    return redirect()->route('super-admin.tournament-types.index')
                        ->with('error', 'Impossibile eliminare tipi con tornei associati.');
                }

                $tournamentTypes->delete();
                $message = 'Tipi torneo eliminati con successo.';
                break;
        }

        return redirect()->route('super-admin.tournament-types.index')
            ->with('success', $message);
    }

    /**
     * Preview tournament type settings.
     */
    public function preview(TournamentType $tournamentType)
    {
        $preview = [
            'basic_info' => [
                'name' => $tournamentType->name,
                'code' => $tournamentType->code,
                'description' => $tournamentType->description,
                'type' => $tournamentType->is_national ? 'Nazionale' : 'Zonale',
            ],
            'referee_requirements' => [
                'required_level' => $tournamentType->required_level,
                'min_referees' => $tournamentType->min_referees,
                'max_referees' => $tournamentType->max_referees,
            ],
            'settings' => $tournamentType->settings ?? [],
            'visibility' => [
                'zones' => $tournamentType->visibility_zones,
                'is_national' => $tournamentType->is_national,
            ],
            'statistics' => [
                'tournaments_count' => $tournamentType->tournaments()->count(),
                'active_tournaments' => $tournamentType->tournaments()->active()->count(),
                'upcoming_tournaments' => $tournamentType->tournaments()->upcoming()->count(),
            ]
        ];

        return response()->json($preview);
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Models\Zone;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Validation\Rule;

class UserController extends Controller
{
    /**
     * Display a listing of users.
     */
    public function index(Request $request)
    {
        $query = User::with(['zone', 'tournaments', 'assignments']);

        // Search filters
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                  ->orWhere('email', 'like', "%{$search}%")
                  ->orWhere('codice_tessera', 'like', "%{$search}%");
            });
        }

        if ($request->filled('user_type')) {
            $query->where('user_type', $request->user_type);
        }

        if ($request->filled('zone_id')) {
            $query->where('zone_id', $request->zone_id);
        }

        if ($request->filled('is_active')) {
            $query->where('is_active', $request->is_active);
        }

        $users = $query->orderBy('created_at', 'desc')->paginate(20);
        $zones = Zone::orderBy('name')->get();

        return view('super-admin.users.index', compact('users', 'zones'));
    }

    /**
     * Show the form for creating a new user.
     */
    public function create()
    {
        $zones = Zone::where('is_active', true)->orderBy('name')->get();
        $userTypes = [
            'super_admin' => 'Super Admin',
            'national_admin' => 'Admin Nazionale (CRC)',
            'zone_admin' => 'Admin Zona',
            'referee' => 'Arbitro'
        ];
        $refereeLevels = config('referee.referee_levels');

        return view('super-admin.users.create', compact('zones', 'userTypes', 'refereeLevels'));
    }

    /**
     * Store a newly created user.
     */
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8|confirmed',
            'user_type' => 'required|string|in:super_admin,national_admin,zone_admin,referee',
            'zone_id' => 'nullable|exists:zones,id',
            'codice_tessera' => 'nullable|string|max:50|unique:users',
            'telefono' => 'nullable|string|max:20',
            'data_nascita' => 'nullable|date',
            'indirizzo' => 'nullable|string|max:255',
            'citta' => 'nullable|string|max:100',
            'cap' => 'nullable|string|max:10',
            'livello_arbitro' => 'nullable|string|in:aspirante,1_livello,regionale,nazionale,internazionale',
            'is_active' => 'boolean',
            'profile_photo' => 'nullable|image|max:2048',
        ]);

        $userData = $request->except(['password', 'password_confirmation', 'profile_photo']);
        $userData['password'] = Hash::make($request->password);
        $userData['email_verified_at'] = now();

        // Handle profile photo upload
        if ($request->hasFile('profile_photo')) {
            $path = $request->file('profile_photo')->store('profile-photos', 'public');
            $userData['profile_photo_path'] = $path;
        }

        $user = User::create($userData);

        return redirect()->route('super-admin.users.index')
            ->with('success', 'Utente creato con successo.');
    }

    /**
     * Display the specified user.
     */
    public function show(User $user)
    {
        $user->load(['zone', 'tournaments', 'assignments.tournament']);

        $stats = [
            'tournaments_count' => $user->tournaments()->count(),
            'assignments_count' => $user->assignments()->count(),
            'pending_assignments' => $user->assignments()->where('status', 'pending')->count(),
            'completed_assignments' => $user->assignments()->where('status', 'accepted')->count(),
        ];

        return view('super-admin.users.show', compact('user', 'stats'));
    }

    /**
     * Show the form for editing the user.
     */
    public function edit(User $user)
    {
        $zones = Zone::where('is_active', true)->orderBy('name')->get();
        $userTypes = [
            'super_admin' => 'Super Admin',
            'national_admin' => 'Admin Nazionale (CRC)',
            'zone_admin' => 'Admin Zona',
            'referee' => 'Arbitro'
        ];
        $refereeLevels = config('referee.referee_levels');

        return view('super-admin.users.edit', compact('user', 'zones', 'userTypes', 'refereeLevels'));
    }

    /**
     * Update the specified user.
     */
    public function update(Request $request, User $user)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => ['required', 'string', 'email', 'max:255', Rule::unique('users')->ignore($user->id)],
            'password' => 'nullable|string|min:8|confirmed',
            'user_type' => 'required|string|in:super_admin,national_admin,zone_admin,referee',
            'zone_id' => 'nullable|exists:zones,id',
            'codice_tessera' => ['nullable', 'string', 'max:50', Rule::unique('users')->ignore($user->id)],
            'telefono' => 'nullable|string|max:20',
            'data_nascita' => 'nullable|date',
            'indirizzo' => 'nullable|string|max:255',
            'citta' => 'nullable|string|max:100',
            'cap' => 'nullable|string|max:10',
            'livello_arbitro' => 'nullable|string|in:aspirante,1_livello,regionale,nazionale,internazionale',
            'is_active' => 'boolean',
            'profile_photo' => 'nullable|image|max:2048',
        ]);

        $userData = $request->except(['password', 'password_confirmation', 'profile_photo']);

        // Update password only if provided
        if ($request->filled('password')) {
            $userData['password'] = Hash::make($request->password);
        }

        // Handle profile photo upload
        if ($request->hasFile('profile_photo')) {
            // Delete old photo if exists
            if ($user->profile_photo_path) {
                \Storage::disk('public')->delete($user->profile_photo_path);
            }

            $path = $request->file('profile_photo')->store('profile-photos', 'public');
            $userData['profile_photo_path'] = $path;
        }

        $user->update($userData);

        return redirect()->route('super-admin.users.show', $user)
            ->with('success', 'Utente aggiornato con successo.');
    }

    /**
     * Remove the specified user.
     */
    public function destroy(User $user)
    {
        // Prevent deleting current user
        if ($user->id === auth()->id()) {
            return redirect()->route('super-admin.users.index')
                ->with('error', 'Non puoi eliminare il tuo account.');
        }

        // Check if user has active assignments
        if ($user->assignments()->where('status', 'accepted')->exists()) {
            return redirect()->route('super-admin.users.index')
                ->with('error', 'Impossibile eliminare utente con assegnazioni attive.');
        }

        // Delete profile photo if exists
        if ($user->profile_photo_path) {
            \Storage::disk('public')->delete($user->profile_photo_path);
        }

        $user->delete();

        return redirect()->route('super-admin.users.index')
            ->with('success', 'Utente eliminato con successo.');
    }

    /**
     * Toggle user active status.
     */
    public function toggleActive(User $user)
    {
        // Prevent deactivating current user
        if ($user->id === auth()->id()) {
            return response()->json([
                'success' => false,
                'message' => 'Non puoi disattivare il tuo account.'
            ]);
        }

        $user->update(['is_active' => !$user->is_active]);

        return response()->json([
            'success' => true,
            'message' => $user->is_active ? 'Utente attivato.' : 'Utente disattivato.',
            'is_active' => $user->is_active
        ]);
    }

    /**
     * Reset user password.
     */
    public function resetPassword(User $user)
    {
        // Generate temporary password
        $tempPassword = \Str::random(12);

        $user->update([
            'password' => Hash::make($tempPassword),
            'email_verified_at' => null, // Force email verification
        ]);

        // Send password reset email
        try {
            // Here you would send an email with the temporary password
            // or a password reset link

            return response()->json([
                'success' => true,
                'message' => 'Password reimpostata. L\'utente riceverà le istruzioni via email.',
                'temp_password' => $tempPassword // Remove this in production
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Errore durante l\'invio dell\'email: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * Bulk actions on users.
     */
    public function bulkAction(Request $request)
    {
        $request->validate([
            'action' => 'required|in:activate,deactivate,delete',
            'user_ids' => 'required|array|min:1',
            'user_ids.*' => 'exists:users,id'
        ]);

        $userIds = array_filter($request->user_ids, function($id) {
            return $id != auth()->id(); // Exclude current user
        });

        $users = User::whereIn('id', $userIds);

        switch ($request->action) {
            case 'activate':
                $users->update(['is_active' => true]);
                $message = 'Utenti attivati con successo.';
                break;

            case 'deactivate':
                $users->update(['is_active' => false]);
                $message = 'Utenti disattivati con successo.';
                break;

            case 'delete':
                // Check for active assignments
                $hasActiveAssignments = $users->whereHas('assignments', function($q) {
                    $q->where('status', 'accepted');
                })->exists();

                if ($hasActiveAssignments) {
                    return redirect()->route('super-admin.users.index')
                        ->with('error', 'Impossibile eliminare utenti con assegnazioni attive.');
                }

                $users->delete();
                $message = 'Utenti eliminati con successo.';
                break;
        }

        return redirect()->route('super-admin.users.index')
            ->with('success', $message);
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use App\Models\Zone;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Validation\Rule;

class ZoneController extends Controller
{
    /**
     * Display a listing of zones.
     */
    public function index(Request $request)
    {
        $query = Zone::withCount(['users', 'tournaments', 'clubs']);

        // Search filters
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                  ->orWhere('code', 'like', "%{$search}%")
                  ->orWhere('description', 'like', "%{$search}%");
            });
        }

        if ($request->filled('is_active')) {
            $query->where('is_active', $request->is_active);
        }

        $zones = $query->orderBy('sort_order')->orderBy('name')->paginate(15);

        // Statistics
        $stats = [
            'total_zones' => Zone::count(),
            'active_zones' => Zone::where('is_active', true)->count(),
            'total_users' => User::whereIn('zone_id', Zone::pluck('id'))->count(),
            'total_tournaments' => \DB::table('tournaments')->whereIn('zone_id', Zone::pluck('id'))->count(),
        ];

        return view('super-admin.zones.index', compact('zones', 'stats'));
    }

    /**
     * Show the form for creating a new zone.
     */
    public function create()
    {
        $admins = User::where('user_type', 'zone_admin')
                     ->whereNull('zone_id')
                     ->orWhere('zone_id', '')
                     ->orderBy('name')
                     ->get();

        return view('super-admin.zones.create', compact('admins'));
    }

    /**
     * Store a newly created zone.
     */
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255|unique:zones',
            'code' => 'required|string|max:10|unique:zones',
            'description' => 'nullable|string',
            'region' => 'required|string|max:100',
            'contact_email' => 'nullable|email|max:255',
            'contact_phone' => 'nullable|string|max:20',
            'address' => 'nullable|string|max:255',
            'city' => 'nullable|string|max:100',
            'postal_code' => 'nullable|string|max:10',
            'website' => 'nullable|url|max:255',
            'admin_id' => 'nullable|exists:users,id',
            'sort_order' => 'nullable|integer|min:0',
            'is_active' => 'boolean',
            'settings' => 'nullable|array',
            'coordinates' => 'nullable|string',
        ]);

        $zoneData = $request->all();
        $zoneData['settings'] = $request->settings ?? [];

        // Set sort order if not provided
        if (!$request->filled('sort_order')) {
            $zoneData['sort_order'] = Zone::max('sort_order') + 10;
        }

        $zone = Zone::create($zoneData);

        // Assign admin to zone if provided
        if ($request->filled('admin_id')) {
            User::where('id', $request->admin_id)->update(['zone_id' => $zone->id]);
        }

        return redirect()->route('super-admin.zones.index')
            ->with('success', 'Zona creata con successo.');
    }

    /**
     * Display the specified zone.
     */
    public function show(Zone $zone)
    {
        $zone->load(['users', 'tournaments.category', 'clubs']);

        $stats = [
            'total_users' => $zone->users()->count(),
            'active_users' => $zone->users()->where('is_active', true)->count(),
            'referees_count' => $zone->users()->where('user_type', 'referee')->count(),
            'admins_count' => $zone->users()->where('user_type', 'zone_admin')->count(),
            'tournaments_count' => $zone->tournaments()->count(),
            'active_tournaments' => $zone->tournaments()->whereIn('status', ['open', 'closed', 'assigned'])->count(),
            'clubs_count' => $zone->clubs()->count(),
            'active_clubs' => $zone->clubs()->where('is_active', true)->count(),
        ];

        // Recent activity
        $recentTournaments = $zone->tournaments()
                                  ->with('category')
                                  ->orderBy('created_at', 'desc')
                                  ->limit(10)
                                  ->get();

        $recentUsers = $zone->users()
                            ->orderBy('created_at', 'desc')
                            ->limit(10)
                            ->get();

        return view('super-admin.zones.show', compact('zone', 'stats', 'recentTournaments', 'recentUsers'));
    }

    /**
     * Show the form for editing the zone.
     */
    public function edit(Zone $zone)
    {
        $admins = User::where('user_type', 'zone_admin')
                     ->where(function($q) use ($zone) {
                         $q->whereNull('zone_id')
                           ->orWhere('zone_id', '')
                           ->orWhere('zone_id', $zone->id);
                     })
                     ->orderBy('name')
                     ->get();

        $currentAdmin = $zone->users()->where('user_type', 'zone_admin')->first();

        return view('super-admin.zones.edit', compact('zone', 'admins', 'currentAdmin'));
    }

    /**
     * Update the specified zone.
     */
    public function update(Request $request, Zone $zone)
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255', Rule::unique('zones')->ignore($zone->id)],
            'code' => ['required', 'string', 'max:10', Rule::unique('zones')->ignore($zone->id)],
            'description' => 'nullable|string',
            'region' => 'required|string|max:100',
            'contact_email' => 'nullable|email|max:255',
            'contact_phone' => 'nullable|string|max:20',
            'address' => 'nullable|string|max:255',
            'city' => 'nullable|string|max:100',
            'postal_code' => 'nullable|string|max:10',
            'website' => 'nullable|url|max:255',
            'admin_id' => 'nullable|exists:users,id',
            'sort_order' => 'nullable|integer|min:0',
            'is_active' => 'boolean',
            'settings' => 'nullable|array',
            'coordinates' => 'nullable|string',
        ]);

        $zoneData = $request->all();
        $zoneData['settings'] = $request->settings ?? [];

        $zone->update($zoneData);

        // Update admin assignment
        $currentAdmin = $zone->users()->where('user_type', 'zone_admin')->first();

        if ($currentAdmin && $currentAdmin->id != $request->admin_id) {
            // Remove current admin
            $currentAdmin->update(['zone_id' => null]);
        }

        if ($request->filled('admin_id') && (!$currentAdmin || $currentAdmin->id != $request->admin_id)) {
            // Assign new admin
            User::where('id', $request->admin_id)->update(['zone_id' => $zone->id]);
        }

        return redirect()->route('super-admin.zones.show', $zone)
            ->with('success', 'Zona aggiornata con successo.');
    }

    /**
     * Remove the specified zone.
     */
    public function destroy(Zone $zone)
    {
        // Check if zone has users
        if ($zone->users()->exists()) {
            return redirect()->route('super-admin.zones.index')
                ->with('error', 'Impossibile eliminare una zona con utenti associati.');
        }

        // Check if zone has tournaments
        if ($zone->tournaments()->exists()) {
            return redirect()->route('super-admin.zones.index')
                ->with('error', 'Impossibile eliminare una zona con tornei associati.');
        }

        // Check if zone has clubs
        if ($zone->clubs()->exists()) {
            return redirect()->route('super-admin.zones.index')
                ->with('error', 'Impossibile eliminare una zona con circoli associati.');
        }

        $zone->delete();

        return redirect()->route('super-admin.zones.index')
            ->with('success', 'Zona eliminata con successo.');
    }

    /**
     * Toggle zone active status.
     */
    public function toggleActive(Zone $zone)
    {
        $zone->update(['is_active' => !$zone->is_active]);

        return response()->json([
            'success' => true,
            'message' => $zone->is_active ? 'Zona attivata.' : 'Zona disattivata.',
            'is_active' => $zone->is_active
        ]);
    }

    /**
     * Update zones sort order.
     */
    public function updateOrder(Request $request)
    {
        $request->validate([
            'zones' => 'required|array',
            'zones.*.id' => 'required|exists:zones,id',
            'zones.*.sort_order' => 'required|integer|min:0',
        ]);

        foreach ($request->zones as $zoneData) {
            Zone::where('id', $zoneData['id'])
                ->update(['sort_order' => $zoneData['sort_order']]);
        }

        return response()->json(['success' => true]);
    }

    /**
     * Duplicate a zone.
     */
    public function duplicate(Zone $zone)
    {
        $newZone = $zone->replicate();
        $newZone->name = $zone->name . ' (Copia)';
        $newZone->code = $zone->code . '_COPY';
        $newZone->sort_order = Zone::max('sort_order') + 10;
        $newZone->save();

        return redirect()->route('super-admin.zones.edit', $newZone)
            ->with('success', 'Zona duplicata con successo. Modifica i dettagli necessari.');
    }

    /**
     * Export zones data.
     */
    public function export(Request $request)
    {
        $zones = Zone::withCount(['users', 'tournaments', 'clubs'])->get();

        $filename = 'zones_export_' . now()->format('Y-m-d_H-i-s') . '.csv';

        $headers = [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ];

        $callback = function() use ($zones) {
            $file = fopen('php://output', 'w');

            // CSV headers
            fputcsv($file, [
                'ID',
                'Nome',
                'Codice',
                'Regione',
                'Città',
                'Email Contatto',
                'Telefono',
                'Utenti',
                'Tornei',
                'Circoli',
                'Stato',
                'Data Creazione'
            ]);

            foreach ($zones as $zone) {
                fputcsv($file, [
                    $zone->id,
                    $zone->name,
                    $zone->code,
                    $zone->region,
                    $zone->city,
                    $zone->contact_email,
                    $zone->contact_phone,
                    $zone->users_count,
                    $zone->tournaments_count,
                    $zone->clubs_count,
                    $zone->is_active ? 'Attiva' : 'Non Attiva',
                    $zone->created_at->format('d/m/Y H:i')
                ]);
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }

    /**
     * Get zone statistics for dashboard.
     */
    public function getStats()
    {
        $stats = [
            'zones_by_region' => Zone::selectRaw('region, count(*) as count')
                                    ->groupBy('region')
                                    ->pluck('count', 'region'),

            'users_by_zone' => Zone::withCount('users')
                                  ->orderBy('users_count', 'desc')
                                  ->limit(10)
                                  ->pluck('users_count', 'name'),

            'tournaments_by_zone' => Zone::withCount('tournaments')
                                        ->orderBy('tournaments_count', 'desc')
                                        ->limit(10)
                                        ->pluck('tournaments_count', 'name'),

            'active_vs_inactive' => [
                'active' => Zone::where('is_active', true)->count(),
                'inactive' => Zone::where('is_active', false)->count(),
            ]
        ];

        return response()->json($stats);
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Assignment extends Model
{
    use HasFactory;

    protected $fillable = [
        'user_id',
        'tournament_id',
        'role',
        'is_confirmed',
        'assigned_at',
        'assigned_by_id', // CORRETTO: usa assigned_by_id
        'notes',
    ];

    protected $casts = [
        'is_confirmed' => 'boolean',
        'assigned_at' => 'datetime',
    ];

    // Assignment roles
    const ROLE_REFEREE = 'Arbitro';
    const ROLE_TOURNAMENT_DIRECTOR = 'Direttore di Torneo';
    const ROLE_OBSERVER = 'Osservatore';

    const ROLES = [
        self::ROLE_REFEREE => 'Arbitro',
        self::ROLE_TOURNAMENT_DIRECTOR => 'Direttore di Torneo',
        self::ROLE_OBSERVER => 'Osservatore',
    ];

    /**
     * Get the referee (user) for the assignment.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
    /**
     * Alias for backward compatibility - referee is actually user
     */
    public function referee(): BelongsTo
    {
        return $this->user();
    }

    /**
     * Get the tournament for the assignment.
     */
    public function tournament(): BelongsTo
    {
        return $this->belongsTo(Tournament::class);
    }

    /**
     * Get the user who made the assignment.
     */
    public function assignedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'assigned_by_id'); // Cambiato da 'assigned_by'
    }

    /**
     * Scope a query to only include confirmed assignments.
     */
    public function scopeConfirmed($query)
    {
        return $query->where('is_confirmed', true);
    }

    /**
     * Scope a query to only include unconfirmed assignments.
     */
    public function scopeUnconfirmed($query)
    {
        return $query->where('is_confirmed', false);
    }

    /**
     * Scope a query to only include assignments for upcoming tournaments.
     */
    public function scopeUpcoming($query)
    {
        return $query->whereHas('tournament', function ($q) {
            $q->upcoming();
        });
    }

    /**
     * Check if assignment can be confirmed by the referee
     */
    public function canBeConfirmed(): bool
    {
        return !$this->is_confirmed &&
            $this->tournament->status === 'assigned' &&
            $this->tournament->start_date >= now();
    }

    /**
     * Get status label for UI
     */
    public function getStatusLabelAttribute(): string
    {
        if ($this->is_confirmed) {
            return 'Confermato';
        }

        if ($this->tournament->start_date < now()) {
            return 'Scaduto';
        }

        return 'In attesa di conferma';
    }

    /**
     * Get status color for UI
     */
    public function getStatusColorAttribute(): string
    {
        if ($this->is_confirmed) {
            return 'green';
        }

        if ($this->tournament->start_date < now()) {
            return 'gray';
        }

        return 'yellow';
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Availability extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'user_id',
        'tournament_id',
        'notes',
        'submitted_at',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'submitted_at' => 'datetime',
    ];

    /**
     * Get the user (referee) who declared availability.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
    /**
     * Alias for backward compatibility - referee is actually user
     */
    public function referee(): BelongsTo
    {
        return $this->user();
    }

    /**
     * Get the tournament for the availability.
     */
    public function tournament(): BelongsTo
    {
        return $this->belongsTo(Tournament::class);
    }

    /**
     * Scope a query to only include availabilities for upcoming tournaments.
     */
    public function scopeForUpcomingTournaments($query)
    {
        return $query->whereHas('tournament', function ($q) {
            $q->upcoming();
        });
    }

    /**
     * Scope a query to only include availabilities for open tournaments.
     */
    public function scopeForOpenTournaments($query)
    {
        return $query->whereHas('tournament', function ($q) {
            $q->where('status', 'open');
        });
    }

    /**
     * Scope a query to only include unassigned availabilities.
     */
    public function scopeUnassigned($query)
    {
        return $query->whereDoesntHave('tournament.assignments', function ($q) {
            $q->where('user_id', $this->user_id);
        });
    }

    /**
     * Check if availability has been converted to assignment
     */
    public function hasBeenAssigned(): bool
    {
        return Assignment::where('tournament_id', $this->tournament_id)
            ->where('user_id', $this->user_id)
            ->exists();
    }

    /**
     * Get the assignment if exists
     */
    public function getAssignmentAttribute(): ?Assignment
    {
        return Assignment::where('tournament_id', $this->tournament_id)
            ->where('user_id', $this->user_id)
            ->first();
    }

    /**
     * Check if availability can be withdrawn
     */
    public function canBeWithdrawn(): bool
    {
        // Cannot withdraw if already assigned
        if ($this->hasBeenAssigned()) {
            return false;
        }

        // Cannot withdraw if tournament is not open
        if ($this->tournament->status !== 'open') {
            return false;
        }

        // Cannot withdraw if past deadline
        if ($this->tournament->availability_deadline < now()) {
            return false;
        }

        return true;
    }

    /**
     * Get days since submission
     */
    public function getDaysSinceSubmissionAttribute(): int
    {
        return $this->submitted_at->diffInDays(now());
    }

    /**
     * Get submission status
     */
    public function getStatusAttribute(): string
    {
        if ($this->hasBeenAssigned()) {
            return 'assigned';
        }

        if ($this->tournament->status === 'completed') {
            return 'not_selected';
        }

        if ($this->tournament->status === 'assigned') {
            return 'not_selected';
        }

        return 'pending';
    }

    /**
     * Get status label
     */
    public function getStatusLabelAttribute(): string
    {
        return match ($this->status) {
            'assigned' => 'Assegnato',
            'not_selected' => 'Non selezionato',
            'pending' => 'In attesa',
            default => 'Sconosciuto',
        };
    }

    /**
     * Get status color
     */
    public function getStatusColorAttribute(): string
    {
        return match ($this->status) {
            'assigned' => 'green',
            'not_selected' => 'gray',
            'pending' => 'yellow',
            default => 'gray',
        };
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Club extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'clubs';

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'code',
        'city',
        'province',
        'email',
        'phone',
        'address',
        'contact_person',
        'zone_id',
        'notes',
        'is_active',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'is_active' => 'boolean',
    ];

    /**
     * Get the zone that the club belongs to.
     */
    public function zone(): BelongsTo
    {
        return $this->belongsTo(Zone::class);
    }

    /**
     * Get the tournaments hosted by the club.
     */
    public function tournaments(): HasMany
    {
        return $this->hasMany(Tournament::class, 'club_id');
    }

    /**
     * Scope a query to only include active clubs.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include clubs from a specific zone.
     */
    public function scopeFromZone($query, $zoneId)
    {
        return $query->where('zone_id', $zoneId);
    }

    /**
     * Get the full address
     */
    public function getFullAddressAttribute(): string
    {
        $parts = array_filter([
            $this->address,
            $this->city,
            $this->province
        ]);

        return implode(', ', $parts);
    }

    /**
     * Get upcoming tournaments count
     */
    public function getUpcomingTournamentsCountAttribute(): int
    {
        return $this->tournaments()
            ->upcoming()
            ->count();
    }

    /**
     * Get active tournaments count
     */
    public function getActiveTournamentsCountAttribute(): int
    {
        return $this->tournaments()
            ->active()
            ->count();
    }

    /**
     * Check if club has any active tournaments
     */
    public function hasActiveTournaments(): bool
    {
        return $this->tournaments()
            ->active()
            ->exists();
    }

    /**
     * Get formatted contact info
     */
    public function getContactInfoAttribute(): array
    {
        return [
            'person' => $this->contact_person,
            'email' => $this->email,
            'phone' => $this->phone,
        ];
    }

    /**
     * Search clubs by name or code
     */
    public function scopeSearch($query, $search)
    {
        return $query->where(function ($q) use ($search) {
            $q->where('name', 'like', "%{$search}%")
              ->orWhere('code', 'like', "%{$search}%")
              ->orWhere('city', 'like', "%{$search}%");
        });
    }

    /**
     * Order by name
     */
    public function scopeOrdered($query)
    {
        return $query->orderBy('name');
    }

    /**
     * Get display name with code
     */
    public function getDisplayNameAttribute(): string
    {
        return "{$this->name} ({$this->code})";
    }

    /**
     * Check if can be deleted
     */
    public function canBeDeleted(): bool
    {
        return !$this->tournaments()->exists();
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class InstitutionalEmail extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'description',
        'is_active',
        'zone_id',
        'category',
        'receive_all_notifications',
        'notification_types',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'is_active' => 'boolean',
        'receive_all_notifications' => 'boolean',
        'notification_types' => 'array',
    ];

    /**
     * Categories
     */
    const CATEGORY_FEDERATION = 'federazione';
    const CATEGORY_COMMITTEE = 'comitato';
    const CATEGORY_ZONE = 'zona';
    const CATEGORY_OTHER = 'altro';

    const CATEGORIES = [
        self::CATEGORY_FEDERATION => 'Federazione',
        self::CATEGORY_COMMITTEE => 'Comitato',
        self::CATEGORY_ZONE => 'Zona',
        self::CATEGORY_OTHER => 'Altro',
    ];

    /**
     * Notification types
     */
    const NOTIFICATION_TYPES = [
        'assignment' => 'Assegnazioni',
        'availability' => 'Disponibilità',
        'tournament_created' => 'Nuovi Tornei',
        'tournament_updated' => 'Modifiche Tornei',
        'referee_registered' => 'Nuovi Arbitri',
        'reports' => 'Report',
    ];

    /**
     * Get the zone that the institutional email belongs to.
     */
    public function zone(): BelongsTo
    {
        return $this->belongsTo(Zone::class);
    }

    /**
     * Scope a query to only include active emails.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include emails for a specific zone.
     */
    public function scopeForZone($query, $zoneId)
    {
        return $query->where(function ($q) use ($zoneId) {
            $q->whereNull('zone_id')
              ->orWhere('zone_id', $zoneId);
        });
    }

    /**
     * Scope a query to only include emails that should receive a specific notification type.
     */
    public function scopeForNotificationType($query, string $type)
    {
        return $query->where(function ($q) use ($type) {
            $q->where('receive_all_notifications', true)
              ->orWhereJsonContains('notification_types', $type);
        });
    }

    /**
     * Get the category label
     */
    public function getCategoryLabelAttribute(): string
    {
        return self::CATEGORIES[$this->category] ?? $this->category;
    }

    /**
     * Check if should receive notification type
     */
    public function shouldReceiveNotificationType(string $type): bool
    {
        if ($this->receive_all_notifications) {
            return true;
        }

        return in_array($type, $this->notification_types ?? []);
    }

    /**
     * Get notification types labels
     */
    public function getNotificationTypesLabelsAttribute(): array
    {
        if ($this->receive_all_notifications) {
            return ['Tutte le notifiche'];
        }

        $labels = [];
        foreach ($this->notification_types ?? [] as $type) {
            $labels[] = self::NOTIFICATION_TYPES[$type] ?? $type;
        }

        return $labels;
    }

    /**
     * Get display name with category
     */
    public function getDisplayNameAttribute(): string
    {
        return $this->name . ' (' . $this->category_label . ')';
    }

    /**
     * Get zone display
     */
    public function getZoneDisplayAttribute(): string
    {
        return $this->zone ? $this->zone->name : 'Tutte le zone';
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class LetterTemplate extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'type',
        'subject',
        'body',
        'variables',
        'is_active',
        'zone_id',
        'tournament_type_id',
        'description',
        'settings',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'variables' => 'array',
        'is_active' => 'boolean',
        'settings' => 'array',
    ];

    /**
     * Template types
     */
    const TYPE_CONVOCATION = 'convocation';
    const TYPE_ASSIGNMENT = 'assignment';
    const TYPE_club = 'club';
    const TYPE_GENERAL = 'general';

    const TYPES = [
        self::TYPE_CONVOCATION => 'Convocazione Arbitro',
        self::TYPE_ASSIGNMENT => 'Notifica Assegnazione',
        self::TYPE_club => 'Comunicazione Circolo',
        self::TYPE_GENERAL => 'Generale',
    ];

    /**
     * Available variables by type
     */
    const AVAILABLE_VARIABLES = [
        'common' => [
            'tournament_name' => 'Nome Torneo',
            'tournament_dates' => 'Date Torneo',
            'tournament_category' => 'Categoria Torneo',
            'club_name' => 'Nome Circolo',
            'club_address' => 'Indirizzo Circolo',
            'zone_name' => 'Nome Zona',
            'current_date' => 'Data Corrente',
            'current_year' => 'Anno Corrente',
        ],
        'convocation' => [
            'referee_name' => 'Nome Arbitro',
            'referee_code' => 'Codice Arbitro',
            'referee_level' => 'Livello Arbitro',
            'role' => 'Ruolo Assegnato',
            'assignment_notes' => 'Note Assegnazione',
        ],
        'assignment' => [
            'referee_name' => 'Nome Arbitro',
            'referee_email' => 'Email Arbitro',
            'assigned_date' => 'Data Assegnazione',
            'assigned_by' => 'Assegnato da',
        ],
        'club' => [
            'contact_person' => 'Persona di Contatto',
            'referee_list' => 'Lista Arbitri',
            'total_referees' => 'Totale Arbitri',
        ],
    ];

    /**
     * Get the zone that the template belongs to.
     */
    public function zone(): BelongsTo
    {
        return $this->belongsTo(Zone::class);
    }

    /**
     * Get the tournament type that the template belongs to.
     */
    public function tournamentType(): BelongsTo
    {
        return $this->belongsTo(TournamentType::class);
    }

    /**
     * Scope a query to only include active templates.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include templates for a specific type.
     */
    public function scopeOfType($query, string $type)
    {
        return $query->where('type', $type);
    }

    /**
     * Scope a query to only include templates for a specific zone.
     */
    public function scopeForZone($query, $zoneId)
    {
        return $query->where(function ($q) use ($zoneId) {
            $q->whereNull('zone_id')
              ->orWhere('zone_id', $zoneId);
        });
    }

    /**
     * Scope a query to only include templates for a specific category.
     */
    public function scopeForCategory($query, $categoryId)
    {
        return $query->where(function ($q) use ($categoryId) {
            $q->whereNull('tournament_type_id')
              ->orWhere('tournament_type_id', $categoryId);
        });
    }

    /**
     * Get the type label
     */
    public function getTypeLabelAttribute(): string
    {
        return self::TYPES[$this->type] ?? $this->type;
    }

    /**
     * Get available variables for this template type
     */
    public function getAvailableVariablesAttribute(): array
    {
        $variables = self::AVAILABLE_VARIABLES['common'] ?? [];

        if (isset(self::AVAILABLE_VARIABLES[$this->type])) {
            $variables = array_merge($variables, self::AVAILABLE_VARIABLES[$this->type]);
        }

        return $variables;
    }

    /**
     * Get variables as formatted list
     */
    public function getVariablesListAttribute(): array
    {
        $list = [];
        foreach ($this->available_variables as $key => $label) {
            $list[] = [
                'variable' => '{{' . $key . '}}',
                'description' => $label,
            ];
        }
        return $list;
    }

    /**
     * Get scope display
     */
    public function getScopeDisplayAttribute(): string
    {
        $scope = [];

        if ($this->zone) {
            $scope[] = 'Zona: ' . $this->zone->name;
        }

        if ($this->tournamentCategory) {
            $scope[] = 'Categoria: ' . $this->tournamentCategory->name;
        }

        return !empty($scope) ? implode(' - ', $scope) : 'Globale';
    }

    /**
     * Preview template with sample data
     */
    public function preview(array $data = []): array
    {
        // Merge with sample data
        $sampleData = [
            'tournament_name' => 'Torneo di Esempio',
            'tournament_dates' => '01/07 - 03/07/2025',
            'tournament_category' => 'Open Nazionale',
            'club_name' => 'Golf Club Esempio',
            'club_address' => 'Via Esempio 123, Città',
            'zone_name' => 'Zona Centro',
            'current_date' => now()->format('d/m/Y'),
            'current_year' => now()->year,
            'referee_name' => 'Mario Rossi',
            'referee_code' => 'ARB001',
            'referee_level' => 'Nazionale',
            'role' => 'Arbitro',
        ];

        $data = array_merge($sampleData, $data);

        // Replace variables
        $subject = $this->subject;
        $body = $this->body;

        foreach ($data as $key => $value) {
            $subject = str_replace('{{' . $key . '}}', $value, $subject);
            $body = str_replace('{{' . $key . '}}', $value, $body);
        }

        return [
            'subject' => $subject,
            'body' => $body,
        ];
    }

    /**
     * Clone template
     */
    public function cloneTemplate(array $overrides = []): self
    {
        $clone = $this->replicate();
        $clone->name = $this->name . ' (Copia)';
        $clone->is_active = false;

        foreach ($overrides as $key => $value) {
            $clone->$key = $value;
        }

        $clone->save();

        return $clone;
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Support\Facades\Storage;

class Letterhead extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'zone_id',
        'title',
        'logo_path',
        'header_text',
        'header_content',
        'footer_text',
        'footer_content',
        'contact_info',
        'is_active',
        'is_default',
        'settings',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'contact_info' => 'array',
        'is_active' => 'boolean',
        'is_default' => 'boolean',
        'settings' => 'array',
    ];

    /**
     * Default settings structure
     */
    protected $attributes = [
        'settings' => '{}',
        'contact_info' => '{}',
        'is_active' => true,
        'is_default' => false,
    ];

    /**
     * Get the zone that owns the letterhead.
     */
    public function zone(): BelongsTo
    {
        return $this->belongsTo(Zone::class);
    }

    /**
     * Scope a query to only include active letterheads.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include default letterheads.
     */
    public function scopeDefault($query)
    {
        return $query->where('is_default', true);
    }

    /**
     * Scope a query to get letterhead for a specific zone.
     */
    public function scopeForZone($query, $zoneId)
    {
        return $query->where(function ($q) use ($zoneId) {
            $q->where('zone_id', $zoneId)
              ->orWhereNull('zone_id');
        });
    }

    /**
     * Get the logo URL
     */
    public function getLogoUrlAttribute(): ?string
    {
        if (!$this->logo_path) {
            return null;
        }

        return Storage::url($this->logo_path);
    }

    /**
     * Get formatted contact info
     */
    public function getFormattedContactInfoAttribute(): string
    {
        $info = $this->contact_info ?? [];
        $parts = [];

        if (!empty($info['address'])) {
            $parts[] = $info['address'];
        }

        if (!empty($info['phone'])) {
            $parts[] = "Tel: " . $info['phone'];
        }

        if (!empty($info['email'])) {
            $parts[] = "Email: " . $info['email'];
        }

        if (!empty($info['website'])) {
            $parts[] = "Web: " . $info['website'];
        }

        return implode(' | ', $parts);
    }

    /**
     * Get scope display
     */
    public function getScopeDisplayAttribute(): string
    {
        return $this->zone ? $this->zone->name : 'Globale';
    }

    /**
     * Set as default for zone
     */
    public function setAsDefault(): void
    {
        // Remove default from other letterheads in same zone
        self::where('zone_id', $this->zone_id)
            ->where('id', '!=', $this->id)
            ->update(['is_default' => false]);

        // Set this as default
        $this->update(['is_default' => true]);
    }

    /**
     * Get margin settings
     */
    public function getMarginSettingsAttribute(): array
    {
        return $this->settings['margins'] ?? [
            'top' => 20,
            'bottom' => 20,
            'left' => 25,
            'right' => 25,
        ];
    }

    /**
     * Get font settings
     */
    public function getFontSettingsAttribute(): array
    {
        return $this->settings['font'] ?? [
            'family' => 'Arial',
            'size' => 11,
            'color' => '#000000',
        ];
    }

    /**
     * Clone letterhead
     */
    public function cloneLetterhead(array $overrides = []): self
    {
        $clone = $this->replicate();
        $clone->title = $this->title . ' (Copia)';
        $clone->is_default = false;
        $clone->is_active = false;

        foreach ($overrides as $key => $value) {
            $clone->$key = $value;
        }

        // Copy logo if exists
        if ($this->logo_path && Storage::exists($this->logo_path)) {
            $extension = pathinfo($this->logo_path, PATHINFO_EXTENSION);
            $newPath = 'letterheads/logo_' . uniqid() . '.' . $extension;
            Storage::copy($this->logo_path, $newPath);
            $clone->logo_path = $newPath;
        }

        $clone->save();

        return $clone;
    }

    /**
     * Delete logo file when deleting letterhead
     */
    protected static function boot()
    {
        parent::boot();

        static::deleting(function ($letterhead) {
            if ($letterhead->logo_path && Storage::exists($letterhead->logo_path)) {
                Storage::delete($letterhead->logo_path);
            }
        });
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Carbon\Carbon;

class Notification extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'assignment_id',
        'recipient_type',
        'recipient_email',
        'subject',
        'body',
        'template_used',
        'status',
        'sent_at',
        'error_message',
        'retry_count',
        'attachments',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'sent_at' => 'datetime',
        'retry_count' => 'integer',
        'attachments' => 'array',
    ];

    /**
     * Notification statuses
     */
    const STATUS_PENDING = 'pending';
    const STATUS_SENT = 'sent';
    const STATUS_FAILED = 'failed';
    const STATUS_CANCELLED = 'cancelled';

    const STATUSES = [
        self::STATUS_PENDING => 'In attesa',
        self::STATUS_SENT => 'Inviata',
        self::STATUS_FAILED => 'Fallita',
        self::STATUS_CANCELLED => 'Annullata',
    ];

    /**
     * Recipient types
     */
    const TYPE_REFEREE = 'referee';
    const TYPE_club = 'club';
    const TYPE_INSTITUTIONAL = 'institutional';

    const RECIPIENT_TYPES = [
        self::TYPE_REFEREE => 'Arbitro',
        self::TYPE_club => 'Circolo',
        self::TYPE_INSTITUTIONAL => 'Istituzionale',
    ];

    /**
     * Maximum retry attempts
     */
    const MAX_RETRY_ATTEMPTS = 3;

    /**
     * Get the assignment that this notification belongs to.
     */
    public function assignment(): BelongsTo
    {
        return $this->belongsTo(Assignment::class);
    }

    /**
     * Scope a query to only include sent notifications.
     */
    public function scopeSent($query)
    {
        return $query->where('status', self::STATUS_SENT);
    }

    /**
     * Scope a query to only include pending notifications.
     */
    public function scopePending($query)
    {
        return $query->where('status', self::STATUS_PENDING);
    }

    /**
     * Scope a query to only include failed notifications.
     */
    public function scopeFailed($query)
    {
        return $query->where('status', self::STATUS_FAILED);
    }

    /**
     * Scope a query to only include notifications for a specific recipient type.
     */
    public function scopeForRecipientType($query, string $type)
    {
        return $query->where('recipient_type', $type);
    }

    /**
     * Scope a query to only include notifications that can be retried.
     */
    public function scopeRetryable($query)
    {
        return $query->where('status', self::STATUS_FAILED)
                    ->where('retry_count', '<', self::MAX_RETRY_ATTEMPTS);
    }

    /**
     * Scope a query to only include recent notifications.
     */
    public function scopeRecent($query, int $days = 7)
    {
        return $query->where('created_at', '>=', now()->subDays($days));
    }

    /**
     * Mark notification as sent.
     */
    public function markAsSent(): void
    {
        $this->update([
            'status' => self::STATUS_SENT,
            'sent_at' => now(),
            'error_message' => null,
        ]);
    }

    /**
     * Mark notification as failed.
     */
    public function markAsFailed(string $errorMessage): void
    {
        $this->update([
            'status' => self::STATUS_FAILED,
            'error_message' => $errorMessage,
            'retry_count' => $this->retry_count + 1,
        ]);
    }

    /**
     * Mark notification as cancelled.
     */
    public function markAsCancelled(): void
    {
        $this->update([
            'status' => self::STATUS_CANCELLED,
        ]);
    }

    /**
     * Reset notification for retry.
     */
    public function resetForRetry(): void
    {
        $this->update([
            'status' => self::STATUS_PENDING,
            'error_message' => null,
        ]);
    }

    /**
     * Check if notification can be retried.
     */
    public function canBeRetried(): bool
    {
        return $this->status === self::STATUS_FAILED &&
               $this->retry_count < self::MAX_RETRY_ATTEMPTS;
    }

    /**
     * Check if notification has exceeded max retry attempts.
     */
    public function hasExceededMaxRetries(): bool
    {
        return $this->retry_count >= self::MAX_RETRY_ATTEMPTS;
    }

    /**
     * Get recipient type label.
     */
    public function getRecipientTypeLabelAttribute(): string
    {
        return self::RECIPIENT_TYPES[$this->recipient_type] ?? ucfirst($this->recipient_type);
    }

    /**
     * Get status label.
     */
    public function getStatusLabelAttribute(): string
    {
        return self::STATUSES[$this->status] ?? ucfirst($this->status);
    }

    /**
     * Get status color for UI.
     */
    public function getStatusColorAttribute(): string
    {
        return match($this->status) {
            self::STATUS_SENT => 'green',
            self::STATUS_PENDING => 'yellow',
            self::STATUS_FAILED => 'red',
            self::STATUS_CANCELLED => 'gray',
            default => 'gray',
        };
    }

    /**
     * Get time since sent/created.
     */
    public function getTimeSinceAttribute(): string
    {
        $date = $this->sent_at ?? $this->created_at;
        return $date->diffForHumans();
    }

    /**
     * Get days since creation.
     */
    public function getDaysSinceCreationAttribute(): int
    {
        return $this->created_at->diffInDays(now());
    }

    /**
     * Check if notification is recent.
     */
    public function isRecent(int $days = 7): bool
    {
        return $this->days_since_creation <= $days;
    }

    /**
     * Get attachment count.
     */
    public function getAttachmentCountAttribute(): int
    {
        return $this->attachments ? count($this->attachments) : 0;
    }

    /**
     * Check if notification has attachments.
     */
    public function hasAttachments(): bool
    {
        return $this->attachment_count > 0;
    }

    /**
     * Get attachment names.
     */
    public function getAttachmentNamesAttribute(): array
    {
        if (!$this->attachments) {
            return [];
        }

        return array_keys($this->attachments);
    }

    /**
     * Get attachment paths.
     */
    public function getAttachmentPathsAttribute(): array
    {
        if (!$this->attachments) {
            return [];
        }

        return array_values($this->attachments);
    }

    /**
     * Get template display name.
     */
    public function getTemplateDisplayNameAttribute(): string
    {
        return $this->template_used ?: 'Template predefinito';
    }

    /**
     * Get notification priority for queue processing.
     */
    public function getPriorityAttribute(): int
    {
        $priority = 0;

        // Higher priority for referees
        if ($this->recipient_type === self::TYPE_REFEREE) {
            $priority += 10;
        }

        // Higher priority for urgent tournaments (within 3 days)
        if ($this->assignment) {
            $daysUntil = now()->diffInDays($this->assignment->tournament->start_date, false);
            if ($daysUntil <= 3) {
                $priority += 20;
            }
        }

        // Higher priority for retries
        if ($this->status === self::STATUS_FAILED) {
            $priority += 5;
        }

        return $priority;
    }

    /**
     * Get summary for logging/display.
     */
    public function getSummaryAttribute(): string
    {
        $summary = "{$this->recipient_type_label} - {$this->recipient_email}";

        if ($this->assignment) {
            $summary .= " - {$this->assignment->tournament->name}";
        }

        return $summary;
    }

    /**
     * Create notification for assignment.
     */
    public static function createForAssignment(Assignment $assignment, array $data): self
    {
        return self::create(array_merge($data, [
            'assignment_id' => $assignment->id,
        ]));
    }

    /**
     * Get failed notifications requiring attention.
     */
    public static function getFailedNotificationsRequiringAttention()
    {
        return self::failed()
            ->where('retry_count', '>=', self::MAX_RETRY_ATTEMPTS)
            ->where('created_at', '>=', now()->subDays(7))
            ->with(['assignment.tournament', 'assignment.user'])
            ->get();
    }

    /**
     * Get notifications statistics.
     */
    public static function getStatistics(int $days = 30): array
    {
        $query = self::where('created_at', '>=', now()->subDays($days));

        return [
            'total' => $query->count(),
            'sent' => $query->where('status', self::STATUS_SENT)->count(),
            'pending' => $query->where('status', self::STATUS_PENDING)->count(),
            'failed' => $query->where('status', self::STATUS_FAILED)->count(),
            'by_type' => $query->selectRaw('recipient_type, COUNT(*) as count')
                              ->groupBy('recipient_type')
                              ->pluck('count', 'recipient_type')
                              ->toArray(),
        ];
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

/**
 * Referee Model - Extension Only
 *
 * NOTE: Core referee data (referee_code, level, category, certified_date, zone_id, phone, is_active)
 * is now stored in Users table. This model contains only additional referee-specific fields.
 */
class Referee extends Model
{
    use HasFactory, SoftDeletes;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'user_id',
        'address',
        'city',
        'postal_code',
        'tax_code',
        'profile_completed_at',
        'preferences',
        'badge_number',
        'first_certification_date',
        'last_renewal_date',
        'expiry_date',
        'qualifications',
        'languages',
        'available_for_international',
        'specializations',
        'total_tournaments',
        'tournaments_current_year'
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'certified_date' => 'date',
        'first_certification_date' => 'date',
        'last_renewal_date' => 'date',
        'expiry_date' => 'date',
        'profile_completed_at' => 'datetime',
        'is_active' => 'boolean',
        'available_for_international' => 'boolean',
        'preferences' => 'array',
        'qualifications' => 'array',
        'languages' => 'array',
        'total_tournaments' => 'integer',
        'tournaments_current_year' => 'integer',
    ];

    /**
     * Referee levels
     */
    const LEVEL_ASPIRANTE = 'aspirante';
    const LEVEL_PRIMO_LIVELLO = 'primo_livello';
    const LEVEL_REGIONALE = 'regionale';
    const LEVEL_NAZIONALE = 'nazionale';
    const LEVEL_INTERNAZIONALE = 'internazionale';

    const REFEREE_LEVELS = [
        self::LEVEL_ASPIRANTE => 'Aspirante',
        self::LEVEL_PRIMO_LIVELLO => 'Primo Livello',
        self::LEVEL_REGIONALE => 'Regionale',
        self::LEVEL_NAZIONALE => 'Nazionale',
        self::LEVEL_INTERNAZIONALE => 'Internazionale',
    ];

    /**
     * Referee categories
     */
    const CATEGORY_MASCHILE = 'maschile';
    const CATEGORY_FEMMINILE = 'femminile';
    const CATEGORY_MISTO = 'misto';

    const CATEGORIES = [
        self::CATEGORY_MASCHILE => 'Maschile',
        self::CATEGORY_FEMMINILE => 'Femminile',
        self::CATEGORY_MISTO => 'Misto',
    ];

    /**
     * Get the user that owns the referee profile.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the zone that the referee belongs to.
     */
    public function zone(): BelongsTo
    {
        return $this->belongsTo(Zone::class);
    }

    /**
     * Get the availabilities for the referee.
     */
    public function availabilities(): HasMany
    {
        return $this->hasMany(Availability::class, 'user_id', 'user_id');
    }

    /**
     * Get the assignments for the referee.
     */
    public function assignments(): HasMany
    {
        return $this->hasMany(Assignment::class, 'user_id', 'user_id');
    }

    /**
     * Scope a query to only include active referees.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include referees from a specific zone.
     */
    public function scopeInZone($query, $zoneId)
    {
        return $query->where('zone_id', $zoneId);
    }

    /**
     * Scope a query to only include national level referees.
     */
    public function scopeNationalLevel($query)
    {
        return $query->whereIn('level', [self::LEVEL_NAZIONALE, self::LEVEL_INTERNAZIONALE]);
    }

    /**
     * Check if referee can access national tournaments.
     */
    public function canAccessNationalTournaments(): bool
    {
        return in_array($this->level, [self::LEVEL_NAZIONALE, self::LEVEL_INTERNAZIONALE]);
    }

    /**
     * Check if referee has completed their profile.
     */
    public function hasCompletedProfile(): bool
    {
        return !is_null($this->profile_completed_at) &&
            !is_null($this->referee_code) &&
            !is_null($this->level) &&
            !is_null($this->certified_date) &&
            !is_null($this->phone);
    }

    /**
     * Mark profile as completed.
     */
    public function markProfileAsCompleted(): void
    {
        $this->update(['profile_completed_at' => now()]);
    }

    /**
     * Get the referee's level label.
     */
    public function getLevelLabelAttribute(): string
    {
        return self::REFEREE_LEVELS[$this->level] ?? ucfirst($this->level ?? '');
    }

    /**
     * Get the referee's category label.
     */
    public function getCategoryLabelAttribute(): string
    {
        return self::CATEGORIES[$this->category] ?? ucfirst($this->category ?? '');
    }

    /**
     * Get the referee's full name with code.
     */
    public function getFullNameWithCodeAttribute(): string
    {
        return "{$this->user->name} ({$this->referee_code})";
    }

    /**
     * Get upcoming assignments count.
     */
    public function getUpcomingAssignmentsCountAttribute(): int
    {
        return $this->assignments()
            ->whereHas('tournament', function ($q) {
                $q->where('start_date', '>=', now());
            })
            ->count();
    }

    /**
     * Get this year's assignments count.
     */
    public function getThisYearAssignmentsCountAttribute(): int
    {
        return $this->assignments()
            ->whereHas('tournament', function ($q) {
                $q->whereYear('start_date', now()->year);
            })
            ->count();
    }

    /**
     * Get availability count for current year.
     */
    public function getThisYearAvailabilitiesCountAttribute(): int
    {
        return $this->availabilities()
            ->whereHas('tournament', function ($q) {
                $q->whereYear('start_date', now()->year);
            })
            ->count();
    }

    /**
     * Generate unique referee code.
     */
    public static function generateRefereeCode(): string
    {
        do {
            $code = 'ARB' . str_pad(rand(1, 9999), 4, '0', STR_PAD_LEFT);
        } while (self::where('referee_code', $code)->exists());

        return $code;
    }

    /**
     * Check if certification is expiring soon.
     */
    public function isCertificationExpiringSoon(int $days = 30): bool
    {
        if (!$this->expiry_date) {
            return false;
        }

        return $this->expiry_date->lte(now()->addDays($days));
    }

    /**
     * Check if certification is expired.
     */
    public function isCertificationExpired(): bool
    {
        if (!$this->expiry_date) {
            return false;
        }

        return $this->expiry_date->lt(now());
    }

    public function isProfileComplete(): bool
    {
        // Se è stato marcato come completato (dall'admin o dal form), è completo
        if ($this->profile_completed_at !== null) {
            return true;
        }

        // Controllo minimale: solo campi veramente essenziali
        return !empty($this->user->name) &&
            !empty($this->user->email) &&
            !empty($this->level) &&
            !empty($this->zone_id);
    }

    // Aggiungi anche questo metodo helper:
    public function markAsCompleted()
    {
        $this->update(['profile_completed_at' => now()]);
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Cache;

class Setting extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'key',
        'value',
        'type',
        'description',
        'group',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'value' => 'string',
    ];

    /**
     * Boot method to clear cache when settings change
     */
    protected static function boot()
    {
        parent::boot();

        static::saved(function () {
            Cache::forget('system_settings');
        });

        static::deleted(function () {
            Cache::forget('system_settings');
        });
    }

    /**
     * Get a setting value by key
     */
    public static function get($key, $default = null)
    {
        $settings = Cache::remember('system_settings', 3600, function () {
            return static::pluck('value', 'key')->toArray();
        });

        return $settings[$key] ?? $default;
    }

    /**
     * Set a setting value
     */
    public static function set($key, $value, $type = 'string', $description = null, $group = 'general')
    {
        return static::updateOrCreate(
            ['key' => $key],
            [
                'value' => $value,
                'type' => $type,
                'description' => $description,
                'group' => $group,
            ]
        );
    }

    /**
     * Get settings by group
     */
    public static function getByGroup($group)
    {
        return static::where('group', $group)->pluck('value', 'key')->toArray();
    }

    /**
     * Get all settings grouped
     */
    public static function getAllGrouped()
    {
        return static::all()->groupBy('group')->map(function ($settings) {
            return $settings->pluck('value', 'key');
        });
    }

    /**
     * Check if setting exists
     */
    public static function has($key)
    {
        return static::where('key', $key)->exists();
    }

    /**
     * Remove a setting
     */
    public static function remove($key)
    {
        return static::where('key', $key)->delete();
    }

    /**
     * Get typed value
     */
    public function getTypedValue()
    {
        switch ($this->type) {
            case 'boolean':
                return filter_var($this->value, FILTER_VALIDATE_BOOLEAN);
            case 'integer':
                return (int) $this->value;
            case 'float':
                return (float) $this->value;
            case 'array':
                return json_decode($this->value, true) ?: [];
            case 'json':
                return json_decode($this->value) ?: new \stdClass();
            default:
                return $this->value;
        }
    }

    /**
     * Set typed value
     */
    public function setTypedValue($value)
    {
        switch ($this->type) {
            case 'boolean':
                $this->value = $value ? '1' : '0';
                break;
            case 'array':
            case 'json':
                $this->value = json_encode($value);
                break;
            default:
                $this->value = (string) $value;
        }
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Carbon\Carbon;

class Tournament extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
protected $fillable = [
    'name', 'start_date', 'end_date', 'availability_deadline',
    'club_id', 'tournament_type_id', 'zone_id', // ✅ tournament_type_id
    'notes', 'status', // ... rest of fields
];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'start_date' => 'date',
        'end_date' => 'date',
        'availability_deadline' => 'date',
        'letters_generated_at' => 'datetime',
        'convocation_generated_at' => 'datetime',
        'club_letter_generated_at' => 'datetime',
        'document_version' => 'integer',
    ];

    /**
     * Tournament statuses
     */
    const STATUS_DRAFT = 'draft';
    const STATUS_OPEN = 'open';
    const STATUS_CLOSED = 'closed';
    const STATUS_ASSIGNED = 'assigned';
    const STATUS_COMPLETED = 'completed';

    const STATUSES = [
        self::STATUS_DRAFT => 'Bozza',
        self::STATUS_OPEN => 'Aperto',
        self::STATUS_CLOSED => 'Chiuso',
        self::STATUS_ASSIGNED => 'Assegnato',
        self::STATUS_COMPLETED => 'Completato',
    ];

    /**
     * Get the club that hosts the tournament.
     */
    public function club(): BelongsTo
    {
        return $this->belongsTo(Club::class);
    }

    /**
     * Get the tournament type (NEW primary relationship)
     */
    public function tournamentType(): BelongsTo
    {
        return $this->belongsTo(TournamentType::class);
    }

    /**
     * Alias for backward compatibility
     */
    public function tournamentCategory()
    {
        return $this->tournamentType();
    }

    /**
     * Get the zone.
     */
    public function zone(): BelongsTo
    {
        return $this->belongsTo(Zone::class);
    }

    /**
     * Get the user who last updated documents.
     */
    public function documentsLastUpdatedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'documents_last_updated_by');
    }

    /**
     * Get the availabilities for the tournament.
     */
    public function availabilities(): HasMany
    {
        return $this->hasMany(Availability::class);
    }

    /**
     * Get the assignments for the tournament.
     */
    public function assignments(): HasMany
    {
        return $this->hasMany(Assignment::class);
    }

    /**
     * Scope a query to only include tournaments visible to a specific zone.
     */
    public function scopeVisibleToZone($query, $zoneId)
    {
        return $query->where(function ($q) use ($zoneId) {
            $q->where('zone_id', $zoneId)
              ->orWhereHas('tournamentType', function ($q) {
                  $q->where('is_national', true);
              });
        });
    }

    /**
     * Scope a query to only include active tournaments.
     */
    public function scopeActive($query)
    {
        return $query->whereIn('status', [self::STATUS_OPEN, self::STATUS_CLOSED, self::STATUS_ASSIGNED]);
    }

    /**
     * Scope a query to only include upcoming tournaments.
     */
    public function scopeUpcoming($query)
    {
        return $query->where('start_date', '>=', Carbon::today());
    }

    /**
     * Scope a query to only include past tournaments.
     */
    public function scopePast($query)
    {
        return $query->where('end_date', '<', Carbon::today());
    }

    /**
     * Scope a query to only include tournaments open for availability.
     */
    public function scopeOpenForAvailability($query)
    {
        return $query->where('status', self::STATUS_OPEN)
                     ->where('availability_deadline', '>=', Carbon::today());
    }

    /**
     * Check if tournament is editable
     */
    public function isEditable(): bool
    {
        return in_array($this->status, [self::STATUS_DRAFT, self::STATUS_OPEN]);
    }

    /**
     * Check if tournament is open for availability declarations
     */
    public function isOpenForAvailability(): bool
    {
        return $this->status === self::STATUS_OPEN
               && $this->availability_deadline >= Carbon::today();
    }

    /**
     * Check if tournament needs referees
     */
    public function needsReferees(): bool
    {
        $requiredReferees = $this->tournamentType->min_referees ?? 1;
        $assignedReferees = $this->assignments()->count();

        return $assignedReferees < $requiredReferees;
    }

    /**
     * Get the number of required referees
     */
    public function getRequiredRefereesAttribute(): int
    {
        return $this->tournamentType->min_referees ?? 1;
    }

    /**
     * Get the maximum number of referees allowed
     */
    public function getMaxRefereesAttribute(): int
    {
        return $this->tournamentType->max_referees ?? $this->required_referees;
    }

    /**
     * Check if a referee can be assigned
     */
    public function canAssignReferee(User $referee): bool
    {
        // Check if already assigned
        if ($this->assignments()->where('user_id', $referee->id)->exists()) {
            return false;
        }

        // Check if max referees reached
        if ($this->assignments()->count() >= $this->max_referees) {
            return false;
        }

        // Check referee level
        if (!$this->tournamentType->requiresRefereeLevel($referee->level)) {
            return false;
        }

        return true;
    }

    /**
     * Get status label
     */
    public function getStatusLabelAttribute(): string
    {
        return self::STATUSES[$this->status] ?? $this->status;
    }

    /**
     * Get status color for UI
     */
    public function getStatusColorAttribute(): string
    {
        return match($this->status) {
            self::STATUS_DRAFT => 'gray',
            self::STATUS_OPEN => 'green',
            self::STATUS_CLOSED => 'yellow',
            self::STATUS_ASSIGNED => 'blue',
            self::STATUS_COMPLETED => 'gray',
            default => 'gray',
        };
    }

    /**
     * Get formatted date range
     */
    public function getDateRangeAttribute(): string
    {
        if ($this->start_date->equalTo($this->end_date)) {
            return $this->start_date->format('d/m/Y');
        }

        return $this->start_date->format('d/m/Y') . ' - ' . $this->end_date->format('d/m/Y');
    }

    /**
     * Get days until availability deadline
     */
    public function getDaysUntilDeadlineAttribute(): int
    {
        return Carbon::today()->diffInDays($this->availability_deadline, false);
    }

    /**
     * Update tournament status based on conditions
     */
    public function updateStatus(): void
    {
        // If past deadline and still open, close it
        if ($this->status === self::STATUS_OPEN && $this->availability_deadline < Carbon::today()) {
            $this->update(['status' => self::STATUS_CLOSED]);
        }

        // If has enough assignments and closed, mark as assigned
        if ($this->status === self::STATUS_CLOSED && $this->assignments()->count() >= $this->required_referees) {
            $this->update(['status' => self::STATUS_ASSIGNED]);
        }

        // If tournament date has passed and assigned, mark as completed
        if ($this->status === self::STATUS_ASSIGNED && $this->end_date < Carbon::today()) {
            $this->update(['status' => self::STATUS_COMPLETED]);
        }
    }

    /**
     * Generate document version number
     */
    public function incrementDocumentVersion(): void
    {
        $this->increment('document_version');
        $this->update(['documents_last_updated_by' => auth()->id()]);
    }

    /**
 * Get available referees (those who declared availability)
 */
public function availableReferees()
{
    return $this->belongsToMany(User::class, 'availabilities', 'tournament_id', 'user_id')
                ->withPivot('notes', 'submitted_at')
                ->withTimestamps();
}

/**
 * Get assigned referees
 */
public function assignedReferees()
{
    return $this->belongsToMany(User::class, 'assignments', 'tournament_id', 'user_id')
                ->withPivot('role', 'is_confirmed', 'assigned_at', 'assigned_by_id', 'notes')
                ->withTimestamps();
}

}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class TournamentType extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'tournament_types';

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'code',
        'description',
        'is_national',
        'required_level',
        'level',
        'sort_order',
        'is_active',
        'settings',
        'min_referees',
        'max_referees',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'is_national' => 'boolean',
        'is_active' => 'boolean',
        'settings' => 'array',
        'sort_order' => 'integer',
        'min_referees' => 'integer',
        'max_referees' => 'integer',
    ];

    /**
     * Default settings structure
     *
     * @var array
     */
    protected $attributes = [
        'settings' => '{}',
        'is_active' => true,
        'sort_order' => 0,
        'level' => 'zonale',
        'min_referees' => 1,
        'max_referees' => 1,
    ];

    /**
     * Referee levels
     */
    const REFEREE_LEVELS = [
        'aspirante' => 'Aspirante',
        'primo_livello' => 'Primo Livello',
        'regionale' => 'Regionale',
        'nazionale' => 'Nazionale',
        'internazionale' => 'Internazionale',
    ];

    /**
     * Category levels
     */
    const CATEGORY_LEVELS = [
        'zonale' => 'Zonale',
        'nazionale' => 'Nazionale',
    ];

    /**
     * Boot method to keep JSON settings in sync with physical columns
     */
    protected static function boot()
    {
        parent::boot();

        static::saving(function ($model) {
            // ✅ FIXED: Gestisce correttamente sia array che stringa JSON
            $settings = $model->settings;

            // Se settings è una stringa JSON, convertila in array
            if (is_string($settings)) {
                $settings = json_decode($settings, true) ?: [];
            }

            // Se settings è null, usa array vuoto
            if (!is_array($settings)) {
                $settings = [];
            }

            // Sync physical columns to JSON settings
            $settings['min_referees'] = $model->min_referees;
            $settings['max_referees'] = $model->max_referees;

            // Riassegna come array (il cast lo convertirà in JSON automaticamente)
            $model->settings = $settings;
        });
    }

    /**
     * Get the tournaments for the type.
     */
    public function tournaments(): HasMany
    {
        return $this->hasMany(Tournament::class, 'tournament_type_id');
    }

    /**
     * Scope a query to only include active types.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include national types.
     */
    public function scopeNational($query)
    {
        return $query->where('is_national', true);
    }

    /**
     * Scope a query to only include zonal types.
     */
    public function scopeZonal($query)
    {
        return $query->where('is_national', false);
    }

    /**
     * Scope a query to order by sort order.
     */
    public function scopeOrdered($query)
    {
        return $query->orderBy('sort_order')->orderBy('name');
    }

    /**
     * Get the required referee level from settings (for backward compatibility)
     */
    public function getRequiredRefereeLevelAttribute(): string
    {
        // ✅ FIXED: Gestisce correttamente l'accesso a settings
        $settings = $this->getSettingsAsArray();
        return $settings['required_referee_level'] ?? $this->required_level ?? 'aspirante';
    }

    /**
     * Get the visibility zones setting
     */
    public function getVisibilityZonesAttribute()
    {
        $settings = $this->getSettingsAsArray();
        return $settings['visibility_zones'] ?? ($this->is_national ? 'all' : 'own');
    }

    /**
     * Check if type requires specific referee level
     */
    public function requiresRefereeLevel(string $level): bool
    {
        // Se level è null, considera come aspirante
        if ($level === null) {
            $level = 'aspirante';
        }
        $levels = array_keys(self::REFEREE_LEVELS);
        $requiredIndex = array_search($this->required_referee_level, $levels);
        $checkIndex = array_search($level, $levels);

        return $checkIndex !== false && $requiredIndex !== false && $checkIndex >= $requiredIndex;
    }

    /**
     * Get notification templates for this type
     */
    public function getNotificationTemplatesAttribute(): array
    {
        $settings = $this->getSettingsAsArray();
        return $settings['notification_templates'] ?? [];
    }

    /**
     * Get special requirements
     */
    public function getSpecialRequirementsAttribute(): ?string
    {
        $settings = $this->getSettingsAsArray();
        return $settings['special_requirements'] ?? null;
    }

    /**
     * ✅ NEW: Helper method to get settings as array safely
     */
    private function getSettingsAsArray(): array
    {
        $settings = $this->settings;

        if (is_string($settings)) {
            return json_decode($settings, true) ?: [];
        }

        return is_array($settings) ? $settings : [];
    }

    /**
     * Update settings and sync with physical columns
     */
    public function updateSettings(array $settings): void
    {
        $currentSettings = $this->getSettingsAsArray();
        $newSettings = array_merge($currentSettings, $settings);

        // Update physical columns if provided in settings
        if (isset($settings['min_referees'])) {
            $this->min_referees = $settings['min_referees'];
        }
        if (isset($settings['max_referees'])) {
            $this->max_referees = $settings['max_referees'];
        }

        $this->settings = $newSettings;
        $this->save();
    }

    /**
     * Get available for zones
     */
    public function isAvailableForZone($zoneId): bool
    {
        if ($this->is_national || $this->visibility_zones === 'all') {
            return true;
        }

        if (is_array($this->visibility_zones)) {
            return in_array($zoneId, $this->visibility_zones);
        }

        return false;
    }

    /**
     * Get formatted name with level
     */
    public function getFormattedNameAttribute(): string
    {
        $prefix = $this->is_national ? '[NAZ] ' : '[ZONA] ';
        return $prefix . $this->name;
    }

    /**
     * Check if can be deleted
     */
    public function canBeDeleted(): bool
    {
        return !$this->tournaments()->exists();
    }

    /**
     * Get display information
     */
    public function getDisplayInfoAttribute(): array
    {
        return [
            'formatted_name' => $this->formatted_name,
            'referee_range' => "{$this->min_referees}-{$this->max_referees} arbitri",
            'required_level' => self::REFEREE_LEVELS[$this->required_referee_level] ?? 'Non specificato',
            'visibility' => $this->is_national ? 'Nazionale' : 'Zonale',
        ];
    }
}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable, SoftDeletes;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
protected $fillable = [
    'name', 'email', 'password', 'user_type', 'is_active',
    // ✅ ADD REFEREE CORE FIELDS:
    'referee_code', 'level', 'category', 'zone_id', 'certified_date', 'phone', 'city',
    'notes', 'last_login_at'
];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
        'is_active' => 'boolean',
        'certified_date' => 'date',
    ];

    /**
     * User types
     */
    const TYPE_REFEREE = 'referee';
    const TYPE_ADMIN = 'admin';
    const TYPE_NATIONAL_ADMIN = 'national_admin';
    const TYPE_SUPER_ADMIN = 'super_admin';

    const USER_TYPES = [
        self::TYPE_REFEREE => 'Arbitro',
        self::TYPE_ADMIN => 'Admin Zona',
        self::TYPE_NATIONAL_ADMIN => 'Admin CRC',
        self::TYPE_SUPER_ADMIN => 'Super Admin',
    ];

    /**
     * Referee levels
     */
    const LEVEL_ASPIRANT = 'aspirante';
    const LEVEL_FIRST = 'primo_livello';
    const LEVEL_REGIONAL = 'regionale';
    const LEVEL_NATIONAL = 'nazionale';
    const LEVEL_INTERNATIONAL = 'internazionale';
    const LEVEL_ARCHIVE = 'archivio';

    const REFEREE_LEVELS = [
        self::LEVEL_ASPIRANT => 'Aspirante',
        self::LEVEL_FIRST => 'Primo Livello',
        self::LEVEL_REGIONAL => 'Regionale',
        self::LEVEL_NATIONAL => 'Nazionale',
        self::LEVEL_INTERNATIONAL => 'Internazionale',
        self::LEVEL_ARCHIVE => 'Archivio',
    ];

    /**
     * Get the zone that the user belongs to.
     */
    public function zone(): BelongsTo
    {
        return $this->belongsTo(Zone::class);
    }

    /**
     * Get the referee details.
     */
    public function refereeDetails(): HasOne
    {
        return $this->hasOne(RefereeDetail::class);
    }

    /**
     * Get the availabilities declared by the user.
     */
    public function availabilities(): HasMany
    {
        return $this->hasMany(Availability::class);
    }

    /**
     * Get the assignments for the user.
     */
    public function assignments(): HasMany
    {
        return $this->hasMany(Assignment::class);
    }

    /**
     * Get the assignments made by this user (as admin).
     */
    public function assignmentsMade(): HasMany
    {
        return $this->hasMany(Assignment::class, 'assigned_by');
    }

    /**
     * Scope a query to only include active users.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include referees.
     */
    public function scopeReferees($query)
    {
        return $query->where('user_type', self::TYPE_REFEREE);
    }

    /**
     * Scope a query to only include admins (all types).
     */
    public function scopeAdmins($query)
    {
        return $query->whereIn('user_type', [
            self::TYPE_ADMIN,
            self::TYPE_NATIONAL_ADMIN,
            self::TYPE_SUPER_ADMIN
        ]);
    }

    /**
     * Scope a query to only include users from a specific zone.
     */
    public function scopeFromZone($query, $zoneId)
    {
        return $query->where('zone_id', $zoneId);
    }

    /**
     * Scope a query to only include referees of a specific level.
     */
    public function scopeOfLevel($query, $level)
    {
        return $query->where('level', $level);
    }

    /**
     * Scope a query to only include national/international referees.
     */
    public function scopeNationalReferees($query)
    {
        return $query->whereIn('level', [self::LEVEL_NATIONAL, self::LEVEL_INTERNATIONAL]);
    }

    /**
     * Check if user is a referee
     */
    public function isReferee(): bool
    {
        return $this->user_type === self::TYPE_REFEREE;
    }

    /**
     * Check if user is an admin (any type)
     */
    public function isAdmin(): bool
    {
        return in_array($this->user_type, [
            self::TYPE_ADMIN,
            self::TYPE_NATIONAL_ADMIN,
            self::TYPE_SUPER_ADMIN
        ]);
    }

    /**
     * Check if user is a zone admin
     */
    public function isZoneAdmin(): bool
    {
        return $this->user_type === self::TYPE_ADMIN;
    }

    /**
     * Check if user is a national admin
     */
    public function isNationalAdmin(): bool
    {
        return $this->user_type === self::TYPE_NATIONAL_ADMIN;
    }

    /**
     * Check if user is a super admin
     */
    public function isSuperAdmin(): bool
    {
        return $this->user_type === self::TYPE_SUPER_ADMIN;
    }

    /**
     * Check if user can manage zone
     */
    public function canManageZone($zoneId): bool
    {
        if ($this->isSuperAdmin() || $this->isNationalAdmin()) {
            return true;
        }

        if ($this->isZoneAdmin() && $this->zone_id == $zoneId) {
            return true;
        }

        return false;
    }

    /**
     * Check if user can view tournament
     */
    public function canViewTournament(Tournament $tournament): bool
    {
        // Admins can view based on zone access
        if ($this->isAdmin()) {
            return $this->canManageZone($tournament->zone_id);
        }

        // Referees can view if tournament is visible to them
        if ($this->isReferee()) {
            // National tournaments are visible to all
            if ($tournament->tournamentCategory->is_national) {
                return true;
            }

            // Zone tournaments are visible to zone referees
            return $this->zone_id === $tournament->zone_id;
        }

        return false;
    }

    /**
     * Get user type label
     */
    public function getUserTypeLabelAttribute(): string
    {
        return self::USER_TYPES[$this->user_type] ?? $this->user_type;
    }

    /**
     * Get referee level label
     */
    public function getLevelLabelAttribute(): string
    {
        return self::REFEREE_LEVELS[$this->level] ?? $this->level;
    }

    /**
     * Get full display name with code
     */
    public function getFullNameAttribute(): string
    {
        if ($this->referee_code) {
            return "{$this->name} ({$this->referee_code})";
        }
        return $this->name;
    }

    /**
     * Get upcoming assignments
     */
    public function getUpcomingAssignmentsAttribute()
    {
        return $this->assignments()
            ->upcoming()
            ->with(['tournament.club', 'tournament.zone'])
            ->orderBy('tournaments.start_date')
            ->get();
    }

    /**
     * Get statistics for referee
     */
    public function getRefereeStatisticsAttribute(): array
    {
        if (!$this->isReferee()) {
            return [];
        }

        return [
            'total_availabilities' => $this->availabilities()->count(),
            'total_assignments' => $this->assignments()->count(),
            'confirmed_assignments' => $this->assignments()->confirmed()->count(),
            'upcoming_assignments' => $this->assignments()->upcoming()->count(),
            'completed_assignments' => $this->assignments()->whereHas('tournament', function ($q) {
                $q->where('status', 'completed');
            })->count(),
            'current_year_assignments' => $this->assignments()
                ->whereYear('assigned_at', now()->year)
                ->count(),
        ];
    }

    /**
     * Check if can be assigned to tournament
     */
    public function canBeAssignedToTournament(Tournament $tournament): bool
    {
        if (!$this->isReferee() || !$this->is_active) {
            return false;
        }

        // Check if already assigned
        if ($this->assignments()->where('tournament_id', $tournament->id)->exists()) {
            return false;
        }

        // Check level requirement
        if (!$tournament->tournamentCategory->requiresRefereeLevel($this->level)) {
            return false;
        }

        // Check zone for non-national tournaments
        if (!$tournament->tournamentCategory->is_national && $this->zone_id !== $tournament->zone_id) {
            return false;
        }

        return true;
    }
    /**
     * Check if user has completed their profile.
     * Add this method to your app/Models/User.php file
     */
    public function hasCompletedProfile(): bool
    {
        // Per gli admin, considerali sempre con profilo completo
        if ($this->isAdmin()) {
            return true;
        }

        // Per gli arbitri, verifica campi obbligatori
        if ($this->isReferee()) {
            return !empty($this->name) &&
                !empty($this->email) &&
                !empty($this->referee_code) &&
                !empty($this->level) &&
                !empty($this->zone_id) &&
                !empty($this->phone);
        }

        // Default: profilo completo se ha nome ed email
        return !empty($this->name) && !empty($this->email);
    }
    /**
     * Check if user has a specific role based on user_type
     * Aggiungere questo metodo alla fine della classe User in app/Models/User.php
     */
    public function hasRole($role): bool
    {
        // Mapping dei ruoli al user_type per compatibilità
        $roleMapping = [
            'admin' => ['admin', 'national_admin', 'super_admin'],
            'zone_admin' => ['admin'], // zone_admin è un alias per admin
            'national_admin' => ['national_admin', 'super_admin'],
            'super_admin' => ['super_admin'],
            'referee' => ['referee'],
            'administrator' => ['admin', 'national_admin', 'super_admin'],
        ];

        // Se il ruolo non è mappato, verifica direttamente con user_type
        if (!isset($roleMapping[$role])) {
            return $this->user_type === $role;
        }

        // Verifica se user_type è incluso nel mapping del ruolo
        return in_array($this->user_type, $roleMapping[$role]);
    }

    /**
     * Check if user has any of the specified roles
     */
    public function hasAnyRole($roles): bool
    {
        if (is_string($roles)) {
            $roles = [$roles];
        }

        foreach ($roles as $role) {
            if ($this->hasRole($role)) {
                return true;
            }
        }

        return false;
    }
    /**
     * Get the referee profile.
     */
    public function referee(): HasOne
    {
        return $this->hasOne(Referee::class);
    }

}
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Zone extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'description',
        'is_national',
        'header_document_path',
        'header_updated_at',
        'header_updated_by',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'is_national' => 'boolean',
        'header_updated_at' => 'datetime',
    ];

    /**
     * Get the users in this zone.
     */
    public function users(): HasMany
    {
        return $this->hasMany(User::class);
    }

    /**
     * Get the referees in this zone.
     */
    public function referees(): HasMany
    {
        return $this->hasMany(User::class)->where('user_type', 'referee');
    }

    /**
     * Get the admins in this zone.
     */
    public function admins(): HasMany
    {
        return $this->hasMany(User::class)->where('user_type', 'admin');
    }

    /**
     * Get the clubs in this zone.
     */
    public function clubs(): HasMany
    {
        return $this->hasMany(Club::class);
    }

    /**
     * Get the tournaments in this zone.
     */
    public function tournaments(): HasMany
    {
        return $this->hasMany(Tournament::class);
    }

    /**
     * Get the institutional emails for this zone.
     */
    public function institutionalEmails(): HasMany
    {
        return $this->hasMany(InstitutionalEmail::class);
    }

    /**
     * Get the letter templates for this zone.
     */
    public function letterTemplates(): HasMany
    {
        return $this->hasMany(LetterTemplate::class);
    }

    /**
     * Get the letterheads for this zone.
     */
    public function letterheads(): HasMany
    {
        return $this->hasMany(Letterhead::class);
    }

    /**
     * Get the user who last updated the header.
     */
    public function headerUpdatedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'header_updated_by');
    }

    /**
     * Scope a query to only include non-national zones.
     */
    public function scopeRegional($query)
    {
        return $query->where('is_national', false);
    }

    /**
     * Get active referees count
     */
    public function getActiveRefereesCountAttribute(): int
    {
        return $this->referees()->where('is_active', true)->count();
    }

    /**
     * Get active clubs count
     */
    public function getActiveClubsCountAttribute(): int
    {
        return $this->clubs()->where('is_active', true)->count();
    }

    /**
     * DEPRECATED: Use getActiveClubsCountAttribute() instead
     */
    public function getActiveCirclesCountAttribute(): int
    {
        return $this->getActiveClubsCountAttribute();
    }

    /**
     * Get upcoming tournaments count
     */
    public function getUpcomingTournamentsCountAttribute(): int
    {
        return $this->tournaments()->upcoming()->count();
    }

    /**
     * Get active tournaments count
     */
    public function getActiveTournamentsCountAttribute(): int
    {
        return $this->tournaments()->active()->count();
    }

    /**
     * Get statistics for the zone
     */
    public function getStatisticsAttribute(): array
    {
        return [
            'total_referees' => $this->referees()->count(),
            'active_referees' => $this->active_referees_count,
            'total_clubs' => $this->clubs()->count(),
            'active_clubs' => $this->active_clubs_count,
            'total_circles' => $this->clubs()->count(), // For backward compatibility
            'active_circles' => $this->active_clubs_count, // For backward compatibility
            'total_tournaments' => $this->tournaments()->count(),
            'upcoming_tournaments' => $this->upcoming_tournaments_count,
            'active_tournaments' => $this->active_tournaments_count,
            'completed_tournaments' => $this->tournaments()->where('status', 'completed')->count(),
        ];
    }

    /**
     * Get referee statistics by level
     */
    public function getRefereesByLevelAttribute(): array
    {
        return $this->referees()
            ->where('is_active', true)
            ->get()
            ->groupBy('level')
            ->map(function ($referees) {
                return $referees->count();
            })
            ->toArray();
    }

    /**
     * Get tournaments by category
     */
    public function getTournamentsByCategoryAttribute(): array
    {
        return $this->tournaments()
            ->with('tournamentType')
            ->get()
            ->groupBy('tournamentCategory.name')
            ->map(function ($tournaments) {
                return $tournaments->count();
            })
            ->toArray();
    }

    /**
 * Scope per ottenere solo le zone attive
 */
public function scopeActive($query)
{
    return $query->where('is_active', true);
}

/**
 * Scope per ordinare le zone per nome
 */
public function scopeOrdered($query)
{
    return $query->orderBy('name');
}
}
@tailwind base;
@tailwind components;
@tailwind utilities;
/* Enhanced Tournament Calendar CSS */

.calendar-grid {
    display: grid;
    grid-template-columns: repeat(7, minmax(0, 1fr));
    grid-auto-rows: minmax(120px, auto);
    gap: 2px;
    background-color: #f3f4f6;
    border: 1px solid #e5e7eb;
    border-radius: 0.5rem;
    overflow: hidden;
  }

  .calendar-header {
    text-align: center;
    font-weight: 500;
    color: #4b5563;
    padding: 0.5rem 0;
    background-color: #f9fafb;
    border-bottom: 1px solid #e5e7eb;
  }

  .calendar-cell {
    background-color: white;
    min-height: 6rem;
    border: 1px solid #e5e7eb;
    padding: 0.5rem;
    position: relative;
    overflow: visible;
  }

  .calendar-cell-empty {
    background-color: #f9fafb;
  }

  /* Tournament item styles */
  .tournament-item {
    padding: 0.35rem 0.5rem;
    margin-bottom: 0.25rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    cursor: pointer;
    transition: transform 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
    position: relative;
    z-index: 1;
  }

  .tournament-item:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  }

  /* Tournament item styles based on type */
  .tournament-item-default {
    background-color: #f3f4f6;
    border: 1px solid #e5e7eb;
    color: #4b5563;
  }

  .tournament-item-national {
    background-color: #dbeafe;
    border: 1px solid #bfdbfe;
    color: #1e40af;
  }

  .tournament-item-championship {
    background-color: #fee2e2;
    border: 1px solid #fecaca;
    color: #b91c1c;
  }

  .tournament-item-regional {
    background-color: #d1fae5;
    border: 1px solid #a7f3d0;
    color: #065f46;
  }

  .tournament-item-local {
    background-color: #fef3c7;
    border: 1px solid #fde68a;
    color: #92400e;
  }

  .tournament-item-continuation {
    opacity: 0.85;
    background-color: inherit;
    border-style: dashed;
  }

  /* Multi-day tournament styles */
  .tournament-multi-day {
    position: absolute;
    z-index: 5;
    top: 1.5rem;
    left: 0;
    right: 0;
    padding: 0.25rem;
    border-radius: 0;
    margin: 0 -1px;
  }

  .tournament-first-day {
    border-top-left-radius: 0.25rem;
    border-bottom-left-radius: 0.25rem;
    margin-left: 0.25rem;
  }

  .tournament-last-day {
    border-top-right-radius: 0.25rem;
    border-bottom-right-radius: 0.25rem;
    margin-right: 0.25rem;
  }

  /* Create/Edit buttons */
  .tournament-actions {
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    position: absolute;
    top: 0;
    right: 0;
    background-color: rgba(255,255,255,0.9);
    border-radius: 0.25rem;
    padding: 0.25rem;
    z-index: 10;
  }

  .tournament-item:hover .tournament-actions {
    visibility: visible;
    opacity: 1;
  }

  .action-button {
    padding: 0.1rem 0.25rem;
    font-size: 0.65rem;
    background: none;
    border: none;
    cursor: pointer;
  }

  .edit-button {
    color: #3b82f6;
  }

  .edit-button:hover {
    color: #2563eb;
  }

  .delete-button {
    color: #ef4444;
  }

  .delete-button:hover {
    color: #dc2626;
  }

  /* Calendar navigation and controls */
  .calendar-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding: 0.5rem;
    background-color: #f9fafb;
    border-radius: 0.5rem;
  }

  .calendar-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: #1f2937;
  }

  .calendar-nav {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .nav-button {
    padding: 0.35rem 0.5rem;
    background-color: white;
    border: 1px solid #e5e7eb;
    border-radius: 0.25rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .nav-button:hover {
    background-color: #f3f4f6;
  }

  .create-button {
    padding: 0.5rem 0.75rem;
    background-color: #4f46e5;
    color: white;
    border: none;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
  }

  .create-button:hover {
    background-color: #4338ca;
  }

  /* Day number indicator */
  .day-number {
    position: absolute;
    top: 0.25rem;
    right: 0.5rem;
    font-size: 0.75rem;
    color: #9ca3af;
    font-weight: 500;
  }

  /* Current day highlight */
  .current-day {
    background-color: #f8fafc;
    border: 2px solid #3b82f6;
  }

  /* Responsive styles */
  @media (max-width: 768px) {
    .calendar-grid {
      grid-template-columns: repeat(1, 1fr);
    }

    .calendar-cell {
      min-height: auto;
      padding-top: 2rem;
    }

    .day-number {
      font-size: 1rem;
      top: 0.5rem;
      left: 0.5rem;
      right: auto;
    }

    .calendar-header {
      display: none;
    }

    .tournament-actions {
      visibility: visible;
      opacity: 1;
    }
  }
/* FullCalendar Multi-day Event Styling */
.fc-event.fc-daygrid-block-event {
  border-radius: 4px !important;
  border-width: 2px !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
  transition: all 0.3s cubic-bezier(.25,.8,.25,1);
  overflow: visible !important;
}

.fc-event.fc-daygrid-block-event:hover {
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
  filter: brightness(1.1);
  transform: translateY(-1px);
  z-index: 10 !important;
}

/* Multi-day event connection styles */
.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start) {
  border-top-left-radius: 0 !important;
  border-bottom-left-radius: 0 !important;
  border-left-width: 0 !important;
  padding-left: 1px !important;
  margin-left: 0 !important;
}

.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end) {
  border-top-right-radius: 0 !important;
  border-bottom-right-radius: 0 !important;
  border-right-width: 0 !important;
  padding-right: 1px !important;
  margin-right: 0 !important;
}

/* National tournament indicator */
.fc-event.fc-daygrid-block-event[style*="background-color: rgb(79, 70, 229)"]::before {
  content: "🏆";
  position: absolute;
  right: 4px;
  top: 2px;
  font-size: 10px;
}

/* Style for edit/delete control buttons */
.event-controls {
  transition: opacity 0.2s ease;
  z-index: 20;
}

.event-controls button {
  padding: 2px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  background-color: white;
}

.event-controls button:hover {
  background-color: #f3f4f6;
}

/* Add to your CSS */

/* Make borders more visible */
.fc-event.fc-daygrid-block-event {
  border-width: 2px !important;
}

/* Status badge styling */
.fc-event-title span {
  font-size: 0.6rem;
  vertical-align: middle;
  opacity: 0.9;
}

/* Highlight on hover */
.fc-event.fc-daygrid-block-event:hover {
  filter: brightness(1.1);
  transform: translateY(-1px);
  transition: all 0.2s ease;
}

/* Color legend styling */
.tournament-calendar-container .color-legend {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 16px;
}

.tournament-calendar-container .legend-item {
  display: flex;
  align-items: center;
  font-size: 0.75rem;
}

.tournament-calendar-container .legend-color {
  width: 12px;
  height: 12px;
  margin-right: 4px;
  border-radius: 2px;
}
{{-- Referee List Partial --}}
<div class="grid grid-cols-1 gap-4">
    @foreach($referees as $index => $referee)
        @php
            $checkboxName = "referees[{$type}_{$referee->id}]";
            $hasConflicts = $referee->has_conflicts ?? false;

            // Determine styling based on type
            $cardClass = match($type) {
                'available' => 'border-green-200 hover:border-green-300',
                'possible' => 'border-yellow-200 hover:border-yellow-300',
                'national' => 'border-blue-200 hover:border-blue-300',
                default => 'border-gray-200 hover:border-gray-300'
            };

            $badgeClass = match($type) {
                'available' => 'bg-green-100 text-green-800',
                'possible' => 'bg-yellow-100 text-yellow-800',
                'national' => 'bg-blue-100 text-blue-800',
                default => 'bg-gray-100 text-gray-800'
            };
        @endphp

        <div class="border {{ $cardClass }} rounded-lg p-4 {{ $hasConflicts ? 'bg-red-50' : 'bg-white' }}">
            <div class="flex items-start space-x-4">
                {{-- Checkbox --}}
                <div class="flex-shrink-0 pt-1">
                    <input type="checkbox"
                           name="{{ $checkboxName }}[selected]"
                           value="1"
                           id="referee_{{ $type }}_{{ $referee->id }}"
                           class="h-4 w-4 text-green-600 focus:ring-green-500 border-gray-300 rounded">
                </div>

                {{-- Referee Info --}}
                <div class="flex-grow">
                    <div class="flex items-start justify-between">
                        <div>
                            <label for="referee_{{ $type }}_{{ $referee->id }}" class="block">
                                <h4 class="font-medium text-gray-900 cursor-pointer">{{ $referee->name }}</h4>
                                <div class="mt-1 space-y-1 text-sm text-gray-600">
                                    <p><strong>Codice:</strong> {{ $referee->referee->referee_code ?? 'N/A' }}</p>
                                    <p><strong>Livello:</strong>
                                        <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium {{ $badgeClass }}">
                                            {{ $referee->referee->level_label ?? 'N/A' }}
                                        </span>
                                    </p>
                                    <p><strong>Zona:</strong> {{ $referee->zone->name ?? 'N/A' }}</p>
                                </div>
                            </label>

                            {{-- Conflicts Warning --}}
                            @if($hasConflicts)
                                <div class="mt-2 p-2 bg-red-100 border border-red-200 rounded">
                                    <p class="text-sm font-medium text-red-800">⚠️ Conflitti di Date:</p>
                                    @foreach($referee->conflicts as $conflict)
                                        <p class="text-xs text-red-700">
                                            • {{ $conflict->tournament->name }}
                                            ({{ $conflict->tournament->start_date->format('d/m') }} - {{ $conflict->tournament->end_date->format('d/m') }})
                                        </p>
                                    @endforeach
                                </div>
                            @endif
                        </div>
                    </div>

                    {{-- Assignment Details (shown when selected) --}}
                    <div class="mt-4 space-y-3 referee-details" style="display: none;">
                        {{-- Hidden inputs for form data --}}
                        <input type="hidden" name="{{ $checkboxName }}[user_id]" value="{{ $referee->id }}">

                        {{-- Role Selection --}}
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Ruolo</label>
                            <select name="{{ $checkboxName }}[role]"
                                    class="w-full rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 text-sm">
                                <option value="Arbitro">Arbitro</option>
                                <option value="Direttore di Torneo">Direttore di Torneo</option>
                                <option value="Osservatore">Osservatore</option>
                            </select>
                        </div>

                        {{-- Notes --}}
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Note (opzionali)</label>
                            <textarea name="{{ $checkboxName }}[notes]"
                                      rows="2"
                                      placeholder="Note per questa assegnazione..."
                                      class="w-full rounded-md border-gray-300 shadow-sm focus:border-green-500 focus:ring-green-500 text-sm"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    @endforeach
</div>

@if($referees->count() === 0)
    <div class="text-center py-8 text-gray-500">
        <p>Nessun arbitro disponibile in questa categoria.</p>
    </div>
@endif

@push('scripts')
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Show/hide referee details when checkbox is toggled
    document.querySelectorAll('input[type="checkbox"][name^="referees["]').forEach(function(checkbox) {
        checkbox.addEventListener('change', function() {
            const detailsDiv = this.closest('.border').querySelector('.referee-details');
            if (this.checked) {
                detailsDiv.style.display = 'block';
            } else {
                detailsDiv.style.display = 'none';
            }
        });
    });
});
</script>
@endpush
{{-- Referee Selection Grid Partial - admin/assignments/partials/referee-selection-grid.blade.php --}}
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    @foreach($referees as $referee)
        @php
            $checkboxName = "referees[{$type}_{$referee->id}]";
            $hasConflicts = $referee->has_conflicts ?? false;

            // Determine styling based on type
            $cardClass = match($type) {
                'available' => 'border-green-200 hover:border-green-300 bg-green-50',
                'possible' => 'border-yellow-200 hover:border-yellow-300 bg-yellow-50',
                'national' => 'border-blue-200 hover:border-blue-300 bg-blue-50',
                default => 'border-gray-200 hover:border-gray-300 bg-white'
            };

            $badgeClass = match($type) {
                'available' => 'bg-green-100 text-green-800',
                'possible' => 'bg-yellow-100 text-yellow-800',
                'national' => 'bg-blue-100 text-blue-800',
                default => 'bg-gray-100 text-gray-800'
            };
        @endphp

        <div class="border {{ $cardClass }} rounded-lg p-4 transition-all duration-200 hover:shadow-md {{ $hasConflicts ? 'ring-2 ring-red-300' : '' }}">
            <div class="flex items-start space-x-3">
                {{-- Checkbox --}}
                <div class="flex-shrink-0 pt-1">
                    <input type="checkbox"
                           name="{{ $checkboxName }}[selected]"
                           value="1"
                           id="referee_{{ $type }}_{{ $referee->id }}"
                           class="h-5 w-5 text-green-600 focus:ring-green-500 border-gray-300 rounded">
                </div>

                {{-- Referee Info --}}
                <div class="flex-grow min-w-0">
                    <label for="referee_{{ $type }}_{{ $referee->id }}" class="block cursor-pointer">
                        <h4 class="font-medium text-gray-900 truncate">{{ $referee->name }}</h4>
                        <div class="mt-1 space-y-1 text-sm text-gray-600">
                            <p><strong>Codice:</strong> {{ $referee->referee->referee_code ?? 'N/A' }}</p>
                            <p><strong>Livello:</strong>
                                <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium {{ $badgeClass }}">
                                    {{ $referee->referee->level_label ?? 'N/A' }}
                                </span>
                            </p>
                            @if($type !== 'national')
                                <p><strong>Zona:</strong> {{ $referee->zone->name ?? 'N/A' }}</p>
                            @endif
                        </div>
                    </label>

                    {{-- Conflicts Warning --}}
                    @if($hasConflicts)
                        <div class="mt-2 p-2 bg-red-100 border border-red-200 rounded text-xs">
                            <p class="font-medium text-red-800">⚠️ Conflitti:</p>
                            @foreach($referee->conflicts as $conflict)
                                <p class="text-red-700">
                                    • {{ $conflict->tournament->name }}
                                    ({{ $conflict->tournament->start_date->format('d/m') }})
                                </p>
                            @endforeach
                        </div>
                    @endif

                    {{-- Assignment Details (shown when selected) --}}
                    <div class="mt-3 space-y-3 referee-details" style="display: none;">
                        {{-- Hidden inputs for form data --}}
                        <input type="hidden" name="{{ $checkboxName }}[user_id]" value="{{ $referee->id }}">

                        {{-- Role Selection --}}
                        <div>
                            <label class="block text-xs font-medium text-gray-700 mb-1">Ruolo</label>
                            <select name="{{ $checkboxName }}[role]"
                                    class="w-full rounded-md border-gray-300 text-xs focus:border-green-500 focus:ring-green-500">
                                <option value="Arbitro">Arbitro</option>
                                <option value="Direttore di Torneo">Direttore di Torneo</option>
                                <option value="Osservatore">Osservatore</option>
                            </select>
                        </div>

                        {{-- Notes --}}
                        <div>
                            <label class="block text-xs font-medium text-gray-700 mb-1">Note</label>
                            <textarea name="{{ $checkboxName }}[notes]"
                                      rows="2"
                                      placeholder="Note opzionali..."
                                      class="w-full rounded-md border-gray-300 text-xs focus:border-green-500 focus:ring-green-500"></textarea>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    @endforeach
</div>

@if($referees->count() === 0)
    <div class="text-center py-8 text-gray-500">
        <p>Nessun arbitro disponibile in questa categoria.</p>
    </div>
@endif

@push('scripts')
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Show/hide referee details when checkbox is toggled
    document.querySelectorAll('input[type="checkbox"][name^="referees["]').forEach(function(checkbox) {
        checkbox.addEventListener('change', function() {
            const detailsDiv = this.closest('.border').querySelector('.referee-details');
            if (this.checked) {
                detailsDiv.style.display = 'block';
                // Focus on role select for quick assignment
                detailsDiv.querySelector('select').focus();
            } else {
                detailsDiv.style.display = 'none';
                // Clear form data
                detailsDiv.querySelectorAll('input, textarea, select').forEach(el => {
                    if (el.tagName === 'SELECT') {
                        el.selectedIndex = 0;
                    } else {
                        el.value = '';
                    }
                });
            }
        });
    });
});
</script>
@endpush
@extends('layouts.admin')
@section('title', 'Report')
@section('content')
<div class="container mx-auto px-4 py-6">
    <h1 class="text-2xl font-bold text-gray-900 mb-6">Report in sviluppo</h1>
    <p class="text-gray-600">Questa funzionalità è in fase di sviluppo.</p>
</div>
@endsection
<?php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\SuperAdmin;
use App\Http\Controllers\Admin;
use App\Http\Controllers\Referee;
use App\Http\Controllers\Reports;
use App\Http\Controllers\Api;
use App\Http\Controllers\DocumentController;
use App\Http\Controllers\Auth\AuthenticatedSessionController;
use App\Http\Controllers\DashboardController;
use App\Http\Controllers\TournamentController;

/*
|--------------------------------------------------------------------------
| Web Routes
|--------------------------------------------------------------------------
*/

// Home redirect
Route::get('/', function () {
    return redirect()->route('login');
});

// Authentication Routes
Route::get('login', [AuthenticatedSessionController::class, 'create'])->name('login');
Route::post('login', [AuthenticatedSessionController::class, 'store']);
Route::post('logout', [AuthenticatedSessionController::class, 'destroy'])->name('logout');

// Authenticated Routes
Route::middleware(['auth'])->group(function () {

    // Dashboard - redirect based on user type
    Route::get('/dashboard', [DashboardController::class, 'index'])->name('dashboard');

    // =================================================================
    // PUBLIC TOURNAMENT ROUTES (visible to all authenticated users)
    // =================================================================
    Route::get('tournaments', [Admin\TournamentController::class, 'publicIndex'])->name('tournaments.index');
    Route::get('tournaments/calendar', [Admin\TournamentController::class, 'publicCalendar'])->name('tournaments.calendar');
    Route::get('tournaments/{tournament}', [Admin\TournamentController::class, 'publicShow'])->name('tournaments.show');

    // =================================================================
    // SUPER ADMIN ROUTES
    // =================================================================
    Route::middleware(['superadmin'])->prefix('super-admin')->name('super-admin.')->group(function () {

        // Dashboard
        Route::get('/', function () {
            return redirect()->route('super-admin.tournament-types.index');
        })->name('dashboard');

        // Tournament Types Management
        Route::resource('tournament-types', SuperAdmin\TournamentTypeController::class);
        Route::post('tournament-types/update-order', [SuperAdmin\TournamentTypeController::class, 'updateOrder'])
            ->name('tournament-types.update-order');
        Route::post('tournament-types/{tournamentType}/toggle-active', [SuperAdmin\TournamentTypeController::class, 'toggleActive'])
            ->name('tournament-types.toggle-active');
        Route::post('tournament-types/{tournamentType}/duplicate', [SuperAdmin\TournamentTypeController::class, 'duplicateCategory'])
            ->name('tournament-types.duplicate');

        // System Settings
        Route::get('settings', [SuperAdmin\SystemSettingsController::class, 'index'])->name('settings.index');
        Route::post('settings', [SuperAdmin\SystemSettingsController::class, 'update'])->name('settings.update');
        Route::post('settings/clear-cache', [SuperAdmin\SystemSettingsController::class, 'clearCache'])->name('settings.clear-cache');
        Route::post('settings/optimize', [SuperAdmin\SystemSettingsController::class, 'optimize'])->name('settings.optimize');

        // User Management (Super Admin exclusive)
        Route::prefix('users')->name('users.')->group(function () {
            Route::get('/', [SuperAdmin\UserController::class, 'index'])->name('index');
            Route::get('/create', [SuperAdmin\UserController::class, 'create'])->name('create');
            Route::post('/', [SuperAdmin\UserController::class, 'store'])->name('store');
            Route::get('/{user}', [SuperAdmin\UserController::class, 'show'])->name('show');
            Route::get('/{user}/edit', [SuperAdmin\UserController::class, 'edit'])->name('edit');
            Route::put('/{user}', [SuperAdmin\UserController::class, 'update'])->name('update');
            Route::delete('/{user}', [SuperAdmin\UserController::class, 'destroy'])->name('destroy');
            Route::post('/{user}/toggle-active', [SuperAdmin\UserController::class, 'toggleActive'])->name('toggle-active');
            Route::post('/{user}/reset-password', [SuperAdmin\UserController::class, 'resetPassword'])->name('reset-password');
        });

        // Zone Management (Super Admin exclusive)
        Route::resource('zones', SuperAdmin\ZoneController::class);
        Route::post('zones/{zone}/toggle-active', [SuperAdmin\ZoneController::class, 'toggleActive'])->name('zones.toggle-active');

        // System Logs and Monitoring
        Route::prefix('system')->name('system.')->group(function () {
            Route::get('logs', [SuperAdmin\SystemController::class, 'logs'])->name('logs');
            Route::get('activity', [SuperAdmin\SystemController::class, 'activity'])->name('activity');
            Route::get('performance', [SuperAdmin\SystemController::class, 'performance'])->name('performance');
            Route::post('maintenance', [SuperAdmin\SystemController::class, 'toggleMaintenance'])->name('maintenance');
        });
    });

    // =================================================================
    // ADMIN ROUTES (Zone Admin & CRC Admin) + Super Admin Access
    // =================================================================
    Route::middleware(['admin_or_superadmin'])->prefix('admin')->name('admin.')->group(function () {

        // Dashboard
        Route::get('/', [Admin\DashboardController::class, 'index'])->name('dashboard');

        // Tournament Management - NOMI CORRETTI per convenzione Laravel
        Route::get('tournaments', [Admin\TournamentController::class, 'adminIndex'])->name('tournaments.index'); // ← FIX
        Route::get('tournaments/calendar', [Admin\TournamentController::class, 'calendar'])->name('tournaments.calendar'); // ← FIX
        Route::get('tournaments/create', [Admin\TournamentController::class, 'create'])->name('tournaments.create');
        Route::post('tournaments', [Admin\TournamentController::class, 'store'])->name('tournaments.store');
        Route::get('tournaments/{tournament}', [Admin\TournamentController::class, 'show'])->name('tournaments.show'); // ← AGGIUNGI
        Route::get('tournaments/{tournament}/edit', [Admin\TournamentController::class, 'edit'])->name('tournaments.edit');
        Route::put('tournaments/{tournament}', [Admin\TournamentController::class, 'update'])->name('tournaments.update');
        Route::delete('tournaments/{tournament}', [Admin\TournamentController::class, 'destroy'])->name('tournaments.destroy');
        Route::post('tournaments/{tournament}/close', [Admin\TournamentController::class, 'close'])->name('tournaments.close');
        Route::post('tournaments/{tournament}/reopen', [Admin\TournamentController::class, 'reopen'])->name('tournaments.reopen');
    // AGGIUNGI QUESTE ROUTE MANCANTI ✅
    Route::get('tournaments/{tournament}/availabilities', [Admin\TournamentController::class, 'availabilities'])
        ->name('tournaments.availabilities');

    // Potresti aver bisogno anche di:
    Route::post('tournaments/{tournament}/update-status', [Admin\TournamentController::class, 'updateStatus'])
        ->name('tournaments.update-status');


        // Referee Management
        Route::resource('referees', Admin\RefereeController::class);
        Route::post('referees/{referee}/toggle-active', [Admin\RefereeController::class, 'toggleActive'])
            ->name('referees.toggle-active');
        Route::post('referees/{referee}/update-level', [Admin\RefereeController::class, 'updateLevel'])
            ->name('referees.update-level');
        Route::get('referees/{referee}/tournaments', [Admin\RefereeController::class, 'tournaments'])
            ->name('referees.tournaments');
        Route::post('referees/import', [Admin\RefereeController::class, 'import'])
            ->name('referees.import');
        Route::get('referees/export', [Admin\RefereeController::class, 'export'])
            ->name('referees.export');

        // Club Management
        Route::resource('clubs', Admin\ClubController::class);
        Route::post('clubs/{club}/toggle-active', [Admin\ClubController::class, 'toggleActive'])
            ->name('clubs.toggle-active');
        Route::get('clubs/{club}/tournaments', [Admin\ClubController::class, 'tournaments'])
            ->name('clubs.tournaments');
        Route::post('clubs/{club}/deactivate', [Admin\ClubController::class, 'deactivate'])
            ->name('clubs.deactivate');

        // Assignment Management
        Route::prefix('assignments')->name('assignments.')->group(function () {
            Route::get('/', [Admin\AssignmentController::class, 'index'])->name('index');
            Route::get('/create', [Admin\AssignmentController::class, 'create'])->name('create');
            Route::post('/', [Admin\AssignmentController::class, 'store'])->name('store');
            Route::get('/calendar', [Admin\AssignmentController::class, 'calendar'])->name('calendar');

            // AGGIUNGI QUESTA ROUTE MANCANTE
            Route::get('/{assignment}', [Admin\AssignmentController::class, 'show'])->name('show');

            // Route per assegnazione flessibile
            Route::get('/{tournament}/assign', [Admin\AssignmentController::class, 'assignReferees'])->name('assign-referees');
            Route::post('/bulk-assign', [Admin\AssignmentController::class, 'bulkAssign'])->name('bulk-assign');

            Route::post('/{assignment}/accept', [Admin\AssignmentController::class, 'accept'])->name('accept');
            Route::post('/{assignment}/reject', [Admin\AssignmentController::class, 'reject'])->name('reject');
            Route::delete('/{assignment}', [Admin\AssignmentController::class, 'destroy'])->name('destroy');
            Route::post('/{assignment}/confirm', [Admin\AssignmentController::class, 'confirm'])->name('confirm');
        });

        // Communication System
        Route::prefix('communications')->name('communications.')->group(function () {
            Route::get('/', [Admin\CommunicationController::class, 'index'])->name('index');
            Route::get('/create', [Admin\CommunicationController::class, 'create'])->name('create');
            Route::post('/', [Admin\CommunicationController::class, 'store'])->name('store');
            Route::get('/{communication}', [Admin\CommunicationController::class, 'show'])->name('show');
            Route::delete('/{communication}', [Admin\CommunicationController::class, 'destroy'])->name('destroy');
        });

        // Document Management
        Route::prefix('documents')->name('documents.')->group(function () {
            Route::get('/', [DocumentController::class, 'index'])->name('index');
            Route::post('/upload', [DocumentController::class, 'upload'])->name('upload');
            Route::get('/{document}/download', [DocumentController::class, 'download'])->name('download');
            Route::delete('/{document}', [DocumentController::class, 'destroy'])->name('destroy');
        });

        // Admin Calendar - Management focus
        Route::get('calendar', [Admin\CalendarController::class, 'index'])->name('calendar.index');
    });
    // =================================================================
    // REFEREE ROUTES + Admin/Super Admin Access
    // =================================================================
    Route::middleware(['referee_or_admin'])->prefix('referee')->name('referee.')->group(function () {

        // Dashboard
        Route::get('/', [Referee\DashboardController::class, 'index'])->name('dashboard');

        // Profile Management
        Route::get('/profile', [Referee\ProfileController::class, 'show'])->name('profile.show');
        // Route::get('/profile/edit', [Referee\ProfileController::class, 'edit'])->name('profile.edit');
        Route::put('/profile', [Referee\ProfileController::class, 'update'])->name('profile.update');
        Route::get('profile', [Referee\ProfileController::class, 'edit'])->name('profile.edit');
        Route::put('profile', [Referee\ProfileController::class, 'update'])->name('profile.update');
        Route::put('profile/password', [Referee\ProfileController::class, 'updatePassword'])->name('profile.update-password');

        // Availability Management - SEZIONE UNIFICATA E CORRETTA
        Route::prefix('availability')->name('availability.')->group(function () {
            // Views
            Route::get('/', [Referee\AvailabilityController::class, 'index'])->name('index');
            Route::get('/calendar', [Referee\AvailabilityController::class, 'calendar'])->name('calendar');

            // Actions
            Route::post('/save', [Referee\AvailabilityController::class, 'save'])->name('save'); // ← AGGIUNTA MANCANTE
            Route::post('/update', [Referee\AvailabilityController::class, 'update'])->name('update');
            Route::post('/bulk-update', [Referee\AvailabilityController::class, 'bulkUpdate'])->name('bulk-update');
            Route::post('/toggle', [Referee\AvailabilityController::class, 'toggle'])->name('toggle');
        });

        // Tournament Applications
        Route::prefix('applications')->name('applications.')->group(function () {
            Route::get('/', [Referee\ApplicationController::class, 'index'])->name('index');
            Route::post('/{tournament}/apply', [Referee\ApplicationController::class, 'apply'])->name('apply');
            Route::delete('/{tournament}/withdraw', [Referee\ApplicationController::class, 'withdraw'])->name('withdraw');
        });

        // Assignment History
        Route::get('/assignments', [Referee\AssignmentController::class, 'index'])->name('assignments.index');
        Route::get('/assignments/{assignment}', [Referee\AssignmentController::class, 'show'])->name('assignments.show');

        // Documents and Certifications
        Route::prefix('documents')->name('documents.')->group(function () {
            Route::get('/', [Referee\DocumentController::class, 'index'])->name('index');
            Route::post('/upload', [Referee\DocumentController::class, 'upload'])->name('upload');
            Route::delete('/{document}', [Referee\DocumentController::class, 'destroy'])->name('destroy');
        });
    });

    // =================================================================
    // REPORTS ROUTES (All authenticated users with proper permissions)
    // =================================================================
    Route::middleware(['admin_or_superadmin'])->prefix('reports')->name('reports.')->group(function () {

        // Dashboard Analytics
        Route::get('/', [Reports\DashboardController::class, 'index'])->name('dashboard');

        // Tournament Reports
        Route::prefix('tournaments')->name('tournament.')->group(function () {
            Route::get('/', [Reports\TournamentReportController::class, 'index'])->name('index');
            Route::get('/{tournament}', [Reports\TournamentReportController::class, 'show'])->name('show');
            Route::get('/by-category', [Reports\TournamentReportController::class, 'byCategory'])->name('by-category');
            Route::get('/by-zone', [Reports\TournamentReportController::class, 'byZone'])->name('by-zone');
            Route::get('/by-period', [Reports\TournamentReportController::class, 'byPeriod'])->name('by-period');
            Route::get('/export', [Reports\TournamentReportController::class, 'export'])->name('export');
        });

        // Referee Reports
        Route::prefix('referees')->name('referee.')->group(function () {
            Route::get('/', [Reports\RefereeReportController::class, 'index'])->name('index');
            Route::get('/{referee}', [Reports\RefereeReportController::class, 'show'])->name('show');
            Route::get('/performance', [Reports\RefereeReportController::class, 'performance'])->name('performance');
            Route::get('/availability', [Reports\RefereeReportController::class, 'availability'])->name('availability');
            Route::get('/workload', [Reports\RefereeReportController::class, 'workload'])->name('workload');
            Route::get('/export', [Reports\RefereeReportController::class, 'export'])->name('export');
        });

        // Category Reports
        Route::prefix('categories')->name('category.')->group(function () {
            Route::get('/', [Reports\CategoryReportController::class, 'index'])->name('index');
            Route::get('/{category}', [Reports\CategoryReportController::class, 'show'])->name('show');
            Route::get('/{category}/tournaments', [Reports\CategoryReportController::class, 'tournaments'])->name('tournaments');
            Route::get('/export', [Reports\CategoryReportController::class, 'export'])->name('export');
        });

        // Zone Reports
        Route::prefix('zones')->name('zone.')->group(function () {
            Route::get('/', [Reports\ZoneReportController::class, 'index'])->name('index');
            Route::get('/{zone}', [Reports\ZoneReportController::class, 'show'])->name('show');
            Route::get('/{zone}/referees', [Reports\ZoneReportController::class, 'referees'])->name('referees');
            Route::get('/{zone}/tournaments', [Reports\ZoneReportController::class, 'tournaments'])->name('tournaments');
            Route::get('/export', [Reports\ZoneReportController::class, 'export'])->name('export');
        });

        // Advanced Analytics
        Route::prefix('analytics')->name('analytics.')->group(function () {
            Route::get('/trends', [Reports\AnalyticsController::class, 'trends'])->name('trends');
            Route::get('/forecasting', [Reports\AnalyticsController::class, 'forecasting'])->name('forecasting');
            Route::get('/efficiency', [Reports\AnalyticsController::class, 'efficiency'])->name('efficiency');
            Route::get('/custom', [Reports\AnalyticsController::class, 'custom'])->name('custom');
        });
    });

    // =================================================================
    // API ROUTES (Internal usage with proper authentication)
    // =================================================================
    Route::prefix('api')->name('api.')->group(function () {

        // Tournament API
        Route::prefix('tournaments')->name('tournaments.')->group(function () {
            Route::get('/', [Api\TournamentController::class, 'index'])->name('index');
            Route::get('/{tournament}', [Api\TournamentController::class, 'show'])->name('show');
            Route::get('/{tournament}/referees', [Api\TournamentController::class, 'referees'])->name('referees');
        });

        // Referee API
        Route::prefix('referees')->name('referees.')->group(function () {
            Route::get('/', [Api\RefereeController::class, 'index'])->name('index');
            Route::get('/{referee}', [Api\RefereeController::class, 'show'])->name('show');
            Route::get('/{referee}/availability', [Api\RefereeController::class, 'availability'])->name('availability');
        });

        // Calendar API
        Route::prefix('calendar')->name('calendar.')->group(function () {
            Route::get('/events', [Api\CalendarController::class, 'events'])->name('events');
            Route::get('/referee/{referee}/events', [Api\CalendarController::class, 'refereeEvents'])->name('referee-events');
        });

        // Statistics API
        Route::prefix('stats')->name('stats.')->group(function () {
            Route::get('/dashboard', [Api\StatsController::class, 'dashboard'])->name('dashboard');
            Route::get('/tournaments', [Api\StatsController::class, 'tournaments'])->name('tournaments');
            Route::get('/referees', [Api\StatsController::class, 'referees'])->name('referees');
        });
        // API Calendar - differentiate by user_type parameter
        Route::get('calendar/events', [Api\CalendarController::class, 'index'])->name('calendar.events');

        // Other API routes...
        Route::get('tournaments/search', [Api\TournamentController::class, 'search'])->name('tournaments.search');
        Route::get('referees/search', [Api\RefereeController::class, 'search'])->name('referees.search');
    });
});

// // =================================================================
// // PUBLIC ROUTES - Tournament Calendar
// // =================================================================
// Route::middleware(['auth'])->group(function () {
//     // PUBLIC TOURNAMENT ROUTES
//     Route::get('tournaments', [TournamentController::class, 'index'])->name('tournaments.index');
//     Route::get('tournaments/{tournament}', [TournamentController::class, 'show'])->name('tournaments.show');

//     // PUBLIC CALENDAR - View Only Focus
//     Route::get('tournaments/calendar', [TournamentController::class, 'calendar'])->name('tournaments.calendar');
// });


// =================================================================
// PUBLIC ROUTES (No authentication required)
// =================================================================

// Health Check
Route::get('/health', function () {
    return response()->json([
        'status' => 'ok',
        'timestamp' => now()->toISOString(),
        'version' => config('app.version', '1.0.0')
    ]);
})->name('health');

// =================================================================
// API ROUTES - Calendar Data (for future AJAX)
// =================================================================
Route::middleware(['auth'])->prefix('api')->name('api.')->group(function () {
    // Calendar Events API (for real-time updates)
    Route::get('calendar/admin', [Api\CalendarController::class, 'adminEvents'])->name('calendar.admin');
    Route::get('calendar/referee', [Api\CalendarController::class, 'refereeEvents'])->name('calendar.referee');
    Route::get('calendar/public', [Api\CalendarController::class, 'publicEvents'])->name('calendar.public');

    // Toggle availability API (for AJAX toggle)
    Route::post('availability/toggle', [Api\AvailabilityController::class, 'toggle'])->name('availability.toggle');
});

// =================================================================
// FALLBACK ROUTE
// =================================================================
Route::fallback(function () {
    return response()->view('errors.404', [], 404);
});
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     * TOURNAMENTS TABLE - Corrected foreign key references
     */
    public function up(): void
    {
        Schema::create('tournaments', function (Blueprint $table) {
            $table->id();

            // ✅ BASIC INFO
            $table->string('name');
            $table->date('start_date');
            $table->date('end_date');
            $table->date('availability_deadline');

            // ✅ CORRECTED FOREIGN KEYS
            $table->foreignId('club_id')->constrained('clubs')->onDelete('restrict');
            $table->foreignId('tournament_type_id')->constrained('tournament_types')->onDelete('restrict'); // ✅ FIXED
            $table->foreignId('zone_id')->constrained('zones')->onDelete('restrict');

            // ✅ CONTENT & STATUS
            $table->text('notes')->nullable();
            $table->enum('status', [
                'draft',
                'open',
                'closed',
                'assigned',
                'completed',
                'cancelled'
            ])->default('draft');

            // ✅ DOCUMENT GENERATION FIELDS
            $table->text('convocation_letter')->nullable();
            $table->text('club_letter')->nullable();
            $table->timestamp('letters_generated_at')->nullable();

            // ✅ FILE PATHS
            $table->string('convocation_file_path')->nullable();
            $table->string('convocation_file_name')->nullable();
            $table->timestamp('convocation_generated_at')->nullable();

            $table->string('club_letter_file_path')->nullable();
            $table->string('club_letter_file_name')->nullable();
            $table->timestamp('club_letter_generated_at')->nullable();

            // ✅ DOCUMENT VERSIONING
            $table->foreignId('documents_last_updated_by')->nullable()->constrained('users')->onDelete('set null');
            $table->integer('document_version')->default(1);

            $table->timestamps();

            // ✅ INDEXES
            $table->index(['zone_id', 'status']);
            $table->index(['start_date', 'status']);
            $table->index(['tournament_type_id', 'status']); // ✅ CORRECTED INDEX
            $table->index(['club_id', 'status']);
            $table->index(['availability_deadline', 'status']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('tournaments');
    }
};
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('tournaments', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->date('start_date');
            $table->date('end_date');
            $table->date('availability_deadline');
            $table->foreignId('club_id')->constrained('clubs');
            $table->foreignId('tournament_category_id')->constrained('tournament_categories');
            $table->foreignId('zone_id')->constrained('zones');
            $table->text('notes')->nullable();
            $table->enum('status', ['draft', 'open', 'closed', 'assigned', 'completed'])->default('draft');

            // Document generation fields
            $table->text('convocation_letter')->nullable();
            $table->text('club_letter')->nullable();
            $table->timestamp('letters_generated_at')->nullable();
            $table->string('convocation_file_path')->nullable();
            $table->string('convocation_file_name')->nullable();
            $table->timestamp('convocation_generated_at')->nullable();
            $table->string('club_letter_file_path')->nullable();
            $table->string('club_letter_file_name')->nullable();
            $table->timestamp('club_letter_generated_at')->nullable();
            $table->foreignId('documents_last_updated_by')->nullable()->constrained('users');
            $table->integer('document_version')->default(1);

            $table->timestamps();

            $table->index(['zone_id', 'status']);
            $table->index(['start_date', 'status']);
            $table->index(['tournament_category_id', 'status']);
            $table->index(['club_id', 'status']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('tournaments');
    }
};
<?php
/**
 * FASE 2: CONSOLIDAMENTO TOURNAMENT TYPES
 *
 * File: database/migrations/2025_07_12_000000_consolidate_tournament_types.php
 *
 * Standardizza su tournament_types table come da handoff document
 */

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // 1. Rinomina tournament_categories → tournament_types
        if (Schema::hasTable('tournament_categories') && !Schema::hasTable('tournament_types')) {
            Schema::rename('tournament_categories', 'tournament_types');
        }

        // 2. Aggiorna foreign key in tournaments table
        if (Schema::hasTable('tournaments')) {
            Schema::table('tournaments', function (Blueprint $table) {
                // Drop existing foreign key
                $table->dropForeign(['tournament_category_id']);

                // Rename column
                $table->renameColumn('tournament_category_id', 'tournament_type_id');
            });

            // Recreate foreign key with new reference
            Schema::table('tournaments', function (Blueprint $table) {
                $table->foreign('tournament_type_id')
                      ->references('id')
                      ->on('tournament_types')
                      ->onDelete('restrict');
            });
        }

        // 3. Aggiorna altri riferimenti se esistono
        $this->updateOtherReferences();

        echo "✅ CONSOLIDAMENTO COMPLETATO: tournament_categories → tournament_types\n";
        echo "✅ FOREIGN KEY AGGIORNATA: tournament_category_id → tournament_type_id\n";
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Processo inverso per rollback
        if (Schema::hasTable('tournaments')) {
            Schema::table('tournaments', function (Blueprint $table) {
                $table->dropForeign(['tournament_type_id']);
                $table->renameColumn('tournament_type_id', 'tournament_category_id');
            });

            Schema::table('tournaments', function (Blueprint $table) {
                $table->foreign('tournament_category_id')
                      ->references('id')
                      ->on('tournament_categories')
                      ->onDelete('restrict');
            });
        }

        if (Schema::hasTable('tournament_types')) {
            Schema::rename('tournament_types', 'tournament_categories');
        }
    }

    /**
     * Update other table references if they exist
     */
    private function updateOtherReferences(): void
    {
        // Letter templates table (se esiste)
        if (Schema::hasTable('letter_templates') && Schema::hasColumn('letter_templates', 'tournament_category_id')) {
            Schema::table('letter_templates', function (Blueprint $table) {
                $table->dropForeign(['tournament_category_id']);
                $table->renameColumn('tournament_category_id', 'tournament_type_id');
                $table->foreign('tournament_type_id')->references('id')->on('tournament_types');
            });
        }

        // Institutional emails table (se esiste)
        if (Schema::hasTable('institutional_emails') && Schema::hasColumn('institutional_emails', 'tournament_category_id')) {
            Schema::table('institutional_emails', function (Blueprint $table) {
                $table->dropForeign(['tournament_category_id']);
                $table->renameColumn('tournament_category_id', 'tournament_type_id');
                $table->foreign('tournament_type_id')->references('id')->on('tournament_types');
            });
        }

        // Altri riferimenti si possono aggiungere qui
    }
};

<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        //
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        //
    }
};
