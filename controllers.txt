cat */*
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Assignment;
use App\Models\Tournament;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;
use Carbon\Carbon;

class AssignmentController extends Controller
{
    /**
     * Display a listing of assignments.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin';

        $query = Assignment::with([
            'user:id,name,email,level',
            'tournament:id,name,start_date,end_date,club_id,tournament_category_id',
            'tournament.club:id,name',
            'tournament.tournamentCategory:id,name',
            'assignedBy:id,name'
        ]);

        // Filter by zone for non-national admins
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->whereHas('tournament', function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        // Apply filters
        if ($request->filled('tournament_id')) {
            $query->where('tournament_id', $request->tournament_id);
        }

        if ($request->filled('user_id')) {
            $query->where('user_id', $request->user_id);
        }

        if ($request->filled('status')) {
            if ($request->status === 'confirmed') {
                $query->where('is_confirmed', true);
            } elseif ($request->status === 'unconfirmed') {
                $query->where('is_confirmed', false);
            }
        }

        $assignments = $query
            ->join('tournaments', 'assignments.tournament_id', '=', 'tournaments.id')
            ->select('assignments.*')  // IMPORTANTE: seleziona solo da assignments
            ->orderBy('tournaments.start_date', 'desc')
            ->orderBy('assignments.created_at', 'desc')
            ->paginate(20);

        // Get data for filters
        $tournaments = Tournament::with('club')
            ->when(!$isNationalAdmin && $user->user_type !== 'super_admin', function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->orderBy('start_date', 'desc')
            ->get();

        $referees = User::where('user_type', 'referee')
            ->where('is_active', true)
            ->when(!$isNationalAdmin && $user->user_type !== 'super_admin', function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->orderBy('name')
            ->get();

        return view('admin.assignments.index', compact(
            'assignments',
            'tournaments',
            'referees',
            'isNationalAdmin'
        ));
    }

    /**
     * Show the form for creating a new assignment.
     */
    public function create(Request $request): View
    {
        $tournamentId = $request->get('tournament_id');
        $tournament = null;

        if ($tournamentId) {
            $tournament = Tournament::findOrFail($tournamentId);
            $this->checkTournamentAccess($tournament);
        }

        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';


        $query = Tournament::with(['club', 'tournamentCategory'])
            ->whereIn('status', ['open', 'closed', 'draft'])
            ->where('start_date', '>=', Carbon::today()->subDays(30));

        // FILTRO ZONA - versione corretta
        if (!$isNationalAdmin) {
            $query->where('zone_id', $user->zone_id);
        }

        $tournaments = $query->orderBy('start_date')->get();

        // ARBITRI SEPARATI PER DISPONIBILITÀ
        $tournamentId = $request->get('tournament_id');

        // Se un torneo è selezionato, separa arbitri per disponibilità
        // Nel metodo create(), modifica le query degli arbitri:
        if ($tournamentId) {
            $tournament = Tournament::with(['assignments.user.referee'])->findOrFail($tournamentId);

            $assignedRefereeIds = $tournament->assignments->pluck('user_id')->toArray();

            // Arbitri che hanno dato disponibilità e NON sono già assegnati
            $availableReferees = User::with(['referee', 'zone'])
                ->whereHas('availabilities', function ($q) use ($tournamentId) {
                    $q->where('tournament_id', $tournamentId);
                })
                ->whereNotIn('id', $assignedRefereeIds) // ESCLUDI già assegnati
                ->where('user_type', 'referee')
                ->where('is_active', true)
                ->orderBy('name')
                ->get();

            // Altri arbitri della zona NON già assegnati
            $otherReferees = User::with(['referee', 'zone'])
                ->where('user_type', 'referee')
                ->where('is_active', true)
                ->where('zone_id', $user->zone_id)
                ->whereDoesntHave('availabilities', function ($q) use ($tournamentId) {
                    $q->where('tournament_id', $tournamentId);
                })
                ->whereNotIn('id', $assignedRefereeIds) // ESCLUDI già assegnati
                ->orderBy('name')
                ->get();
        } else {
            // Se nessun torneo selezionato, tutti gli arbitri della zona
            $availableReferees = collect();
            $otherReferees = User::with(['referee', 'zone'])
                ->where('user_type', 'referee')
                ->where('is_active', true)
                ->where('zone_id', $user->zone_id)
                ->orderBy('name')
                ->get();
        }

        return view('admin.assignments.create', compact(
            'tournament',
            'tournaments',
            'availableReferees',
            'otherReferees'
        ));
    }

    /**
     * Store a newly created assignment.
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'tournament_id' => 'required|exists:tournaments,id',
            'user_id' => 'required|exists:users,id',
            'role' => 'required|in:Arbitro,Direttore di Torneo,Osservatore',
            'notes' => 'nullable|string|max:500',
        ]);

        $tournament = Tournament::findOrFail($request->tournament_id);
        $this->checkTournamentAccess($tournament);

        $referee = User::findOrFail($request->user_id);

        // NUOVO: Controlla se arbitro già assegnato
        if ($tournament->assignments()->where('user_id', $referee->id)->exists()) {
            return redirect()->back()
                ->with('error', "L'arbitro {$referee->name} è già assegnato a questo torneo con un altro ruolo.");
        }

        // Create assignment
        $assignment = Assignment::create([
            'tournament_id' => $tournament->id,
            'user_id' => $referee->id,
            'role' => $request->role,
            'notes' => $request->notes,
            'assigned_at' => now(),
            'assigned_by' => auth()->id(),
            'is_confirmed' => true, // SEMPRE confermato
        ]);

        return redirect()
            ->route('admin.assignments.create', ['tournament_id' => $tournament->id])
            ->with('success', "Arbitro {$referee->name} assegnato con successo come {$request->role}!");
    }

    /**
     * Display the specified assignment.
     */
    public function show(Assignment $assignment): View
    {
        $this->checkAssignmentAccess($assignment);

        $assignment->load([
            'user',
            'tournament.club',
            'tournament.zone',
            'tournament.tournamentCategory',
            'assignedBy'
        ]);

        return view('admin.assignments.show', compact('assignment'));
    }

    /**
     * Update the specified assignment.
     */
    public function update(Request $request, Assignment $assignment): RedirectResponse
    {
        $this->checkAssignmentAccess($assignment);

        $request->validate([
            'role' => 'required|in:Arbitro,Direttore di Torneo,Osservatore',
            'notes' => 'nullable|string|max:500',
        ]);

        $assignment->update([
            'role' => $request->role,
            'notes' => $request->notes,
        ]);

        return redirect()
            ->route('admin.assignments.show', $assignment)
            ->with('success', 'Assegnazione aggiornata con successo.');
    }

    /**
     * Confirm assignment.
     */
    public function confirm(Assignment $assignment): RedirectResponse
    {
        $this->checkAssignmentAccess($assignment);

        $assignment->update(['is_confirmed' => true]);

        return redirect()->back()
            ->with('success', 'Assegnazione confermata con successo.');
    }

/**
 * Update destroy method to redirect back to tournament assignment if coming from there.
 */
public function destroy(Assignment $assignment): RedirectResponse
{
    $this->checkAssignmentAccess($assignment);

    $tournamentId = $assignment->tournament_id;
    $tournamentName = $assignment->tournament->name;
    $refereeName = $assignment->user->name;

    $assignment->delete();

    // Check if we came from tournament assignment page
    $referer = request()->headers->get('referer');
    if ($referer && str_contains($referer, '/assign')) {
        return redirect()
            ->route('admin.assignments.assign-referees', $tournamentId)
            ->with('success', "{$refereeName} rimosso dal comitato di gara di {$tournamentName}.");
    }

    // Default redirect to assignments list
    return redirect()
        ->route('admin.assignments.index')
        ->with('success', "Assegnazione di {$refereeName} al torneo {$tournamentName} rimossa con successo.");
}


    /**
     * Check if user can access the tournament.
     */
    private function checkTournamentAccess(Tournament $tournament): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $tournament->zone_id !== $user->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere a questo torneo.');
        }
    }

    /**
     * Check if user can access the assignment.
     */
    private function checkAssignmentAccess(Assignment $assignment): void
    {
        $this->checkTournamentAccess($assignment->tournament);
    }


    /**
     * Get referees who declared availability for this tournament.
     */
    private function getAvailableReferees(Tournament $tournament)
    {
        return User::with(['referee', 'zone'])
            ->whereHas('availabilities', function ($q) use ($tournament) {
                $q->where('tournament_id', $tournament->id);
            })
            ->where('user_type', 'referee')
            ->where('is_active', true)
            ->orderBy('name')
            ->get();
    }

    /**
     * Get zone referees who haven't declared availability.
     */
    private function getPossibleReferees(Tournament $tournament, $excludeIds)
    {
        return User::with(['referee', 'zone'])
            ->where('user_type', 'referee')
            ->where('is_active', true)
            ->where('zone_id', $tournament->zone_id)
            ->whereNotIn('id', $excludeIds)
            ->whereDoesntHave('availabilities', function ($q) use ($tournament) {
                $q->where('tournament_id', $tournament->id);
            })
            ->orderBy('name')
            ->get();
    }

    /**
     * Get national/international referees (for national tournaments).
     */
    private function getNationalReferees(Tournament $tournament, $excludeIds)
    {
        return User::with(['referee', 'zone'])
            ->where('user_type', 'referee')
            ->where('is_active', true)
            ->whereHas('referee', function ($q) {
                $q->whereIn('level', ['nazionale', 'internazionale']);
            })
            ->whereNotIn('id', $excludeIds)
            ->orderBy('name')
            ->get();
    }

    /**
 * Show assignment interface for a specific tournament.
 */
public function assignReferees(Tournament $tournament): View
{
    $this->checkTournamentAccess($tournament);

    $user = auth()->user();
    $isNationalAdmin = in_array($user->user_type, ['national_admin', 'super_admin']);

    // Load tournament with relations
    $tournament->load(['club', 'zone', 'tournamentCategory']);

    // Get currently assigned referees
    $assignedReferees = $tournament->assignments()->with('user.referee')->get();
    $assignedRefereeIds = $assignedReferees->pluck('user_id')->toArray();

    // Get available referees (have declared availability) - EXCLUDE already assigned
    $availableReferees = User::with(['referee', 'zone'])
        ->whereHas('availabilities', function($q) use ($tournament) {
            $q->where('tournament_id', $tournament->id);
        })
        ->where('user_type', 'referee')
        ->where('is_active', true)
        ->whereNotIn('id', $assignedRefereeIds)
        ->orderBy('name')
        ->get();

    // Get possible referees (zone referees who haven't declared availability) - EXCLUDE already assigned
    $possibleReferees = User::with(['referee', 'zone'])
        ->where('user_type', 'referee')
        ->where('is_active', true)
        ->where('zone_id', $tournament->zone_id)
        ->whereDoesntHave('availabilities', function($q) use ($tournament) {
            $q->where('tournament_id', $tournament->id);
        })
        ->whereNotIn('id', $assignedRefereeIds)
        ->orderBy('name')
        ->get();

    // Get national referees (for national tournaments) - EXCLUDE already assigned
    $nationalReferees = collect();
    if ($tournament->tournamentCategory->is_national) {
        $nationalReferees = User::with(['referee', 'zone'])
            ->where('user_type', 'referee')
            ->where('is_active', true)
            ->whereHas('referee', function($q) {
                $q->whereIn('level', ['nazionale', 'internazionale']);
            })
            ->whereNotIn('id', $assignedRefereeIds)
            ->whereNotIn('id', $availableReferees->pluck('id')->merge($possibleReferees->pluck('id')))
            ->orderBy('name')
            ->get();
    }

    // Check conflicts for all referees
    $this->checkDateConflicts($availableReferees, $tournament);
    $this->checkDateConflicts($possibleReferees, $tournament);
    $this->checkDateConflicts($nationalReferees, $tournament);

    return view('admin.assignments.assign-referees', compact(
        'tournament',
        'availableReferees',
        'possibleReferees',
        'nationalReferees',
        'assignedReferees',
        'isNationalAdmin'
    ));
}

/**
 * Assign multiple referees to tournament.
 */
public function bulkAssign(Request $request): RedirectResponse
{
    $request->validate([
        'tournament_id' => 'required|exists:tournaments,id',
        'referees' => 'required|array|min:1',
        'referees.*.user_id' => 'required|exists:users,id',
        'referees.*.role' => 'required|in:Arbitro,Direttore di Torneo,Osservatore',
        'referees.*.notes' => 'nullable|string|max:500',
    ]);

    $tournament = Tournament::findOrFail($request->tournament_id);
    $this->checkTournamentAccess($tournament);

    $assignedCount = 0;
    $errors = [];

    \DB::beginTransaction();
    try {
        // Process the referees array
        foreach ($request->referees as $key => $refereeData) {
            // Skip if not selected or missing data
            if (!isset($refereeData['selected']) || !isset($refereeData['user_id'])) {
                continue;
            }

            $referee = User::findOrFail($refereeData['user_id']);

            // Check if already assigned
            if ($tournament->assignments()->where('user_id', $referee->id)->exists()) {
                $errors[] = "{$referee->name} è già assegnato a questo torneo";
                continue;
            }

            // Create assignment
            Assignment::create([
                'tournament_id' => $tournament->id,
                'user_id' => $referee->id,
                'role' => $refereeData['role'],
                'notes' => $refereeData['notes'] ?? null,
                'assigned_at' => now(),
                'assigned_by' => auth()->id(),
                'is_confirmed' => true, // Always confirmed
            ]);

            $assignedCount++;
        }

        \DB::commit();

        $message = "{$assignedCount} arbitri assegnati con successo al torneo {$tournament->name}.";
        if (!empty($errors)) {
            $message .= " Errori: " . implode(', ', $errors);
        }

        return redirect()
            ->route('admin.assignments.assign-referees', $tournament)
            ->with('success', $message);

    } catch (\Exception $e) {
        \DB::rollback();

        return redirect()->back()
            ->with('error', 'Errore durante l\'assegnazione degli arbitri. Riprova.');
    }
}

/**
 * Check date conflicts for referees.
 */
private function checkDateConflicts($referees, Tournament $tournament)
{
    foreach ($referees as $referee) {
        $conflicts = Assignment::where('user_id', $referee->id)
            ->whereHas('tournament', function($q) use ($tournament) {
                $q->where('id', '!=', $tournament->id)
                  ->where(function($q2) use ($tournament) {
                      // Tournament dates overlap
                      $q2->whereBetween('start_date', [$tournament->start_date, $tournament->end_date])
                         ->orWhereBetween('end_date', [$tournament->start_date, $tournament->end_date])
                         ->orWhere(function($q3) use ($tournament) {
                             $q3->where('start_date', '<=', $tournament->start_date)
                                ->where('end_date', '>=', $tournament->end_date);
                         });
                  });
            })
            ->with('tournament:id,name,start_date,end_date')
            ->get();

        $referee->conflicts = $conflicts;
        $referee->has_conflicts = $conflicts->count() > 0;
    }
}

}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use App\Models\Zone;
use App\Models\TournamentCategory;
use Illuminate\Http\Request;
use Illuminate\View\View;

class CalendarController extends Controller
{
    /**
     * Admin Calendar - Management focus
     */
    /**
     * Admin Calendar with comprehensive error handling
     */
    public function index(Request $request): View
    {
        try {
            $user = auth()->user();
            $isNationalAdmin = $user->user_type === 'national_admin';

            // Validate user permissions
            if (!in_array($user->user_type, ['admin', 'national_admin', 'super_admin'])) {
                \Log::warning('Unauthorized calendar access attempt', [
                    'user_id' => $user->id,
                    'user_type' => $user->user_type,
                    'ip' => $request->ip()
                ]);

                abort(403, 'Non hai i permessi per accedere al calendario amministrativo.');
            }

            // Validate zone for non-national admins
            if (!$isNationalAdmin && !$user->zone_id) {
                \Log::error('Admin user without zone_id trying to access calendar', [
                    'user_id' => $user->id,
                    'user_type' => $user->user_type
                ]);

                return view('admin.calendar', [
                    'calendarData' => $this->getEmptyCalendarData('error'),
                    'isNationalAdmin' => false,
                    'error' => 'Il tuo account non ha una zona assegnata. Contatta l\'amministratore di sistema.'
                ]);
            }

            // Get tournaments with error handling
            $tournaments = $this->getTournamentsWithErrorHandling($user, $isNationalAdmin);

            // Get filter data with error handling
            $zones = $this->getZonesWithErrorHandling($isNationalAdmin);
            $tournamentTypes = $this->getTournamentTypesWithErrorHandling();

            // Build calendar data
            $calendarData = $this->buildCalendarData($tournaments, $zones, $tournamentTypes, $user);

            // \Log successful access
            \Log::info('Admin calendar accessed successfully', [
                'user_id' => $user->id,
                'tournaments_count' => $tournaments->count(),
                'is_national_admin' => $isNationalAdmin
            ]);

            return view('admin.calendar', compact('calendarData', 'isNationalAdmin'));

        } catch (Exception $e) {
            // \Log the error
            \Log::error('Admin calendar error', [
                'user_id' => auth()->id(),
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            // Return error state
            return view('admin.calendar', [
                'calendarData' => $this->getEmptyCalendarData('error'),
                'isNationalAdmin' => false,
                'error' => 'Si è verificato un errore nel caricamento del calendario. Riprova più tardi.'
            ]);
        }
    }

    /**
     * Get tournaments with comprehensive error handling
     */
    private function getTournamentsWithErrorHandling($user, $isNationalAdmin)
    {
        try {
            $query = Tournament::with(['tournamentCategory', 'zone', 'club', 'assignments', 'availabilities']);

            // Apply zone filter for non-national admins
            if (!$isNationalAdmin) {
                if (!$user->zone_id) {
                    throw new Exception('Admin user missing zone_id');
                }
                $query->where('zone_id', $user->zone_id);
            }

            $tournaments = $query->get();

            // Validate relationships
            foreach ($tournaments as $tournament) {
                if (!$tournament->tournamentCategory) {
                    \Log::warning('Tournament missing category', ['tournament_id' => $tournament->id]);
                }
                if (!$tournament->zone) {
                    \Log::warning('Tournament missing zone', ['tournament_id' => $tournament->id]);
                }
                if (!$tournament->club) {
                    \Log::warning('Tournament missing club', ['tournament_id' => $tournament->id]);
                }
            }

            return $tournaments;

        } catch (Exception $e) {
            \Log::error('Error fetching tournaments for admin calendar', [
                'user_id' => $user->id,
                'error' => $e->getMessage()
            ]);

            // Return empty collection on error
            return collect();
        }
    }

    /**
     * Get zones with error handling
     */
    private function getZonesWithErrorHandling($isNationalAdmin)
    {
        try {
            return $isNationalAdmin ? Zone::orderBy('name')->get() : collect();
        } catch (Exception $e) {
            \Log::error('Error fetching zones for admin calendar', ['error' => $e->getMessage()]);
            return collect();
        }
    }

    /**
     * Get tournament types with error handling
     */
    private function getTournamentTypesWithErrorHandling()
    {
        try {
            return TournamentCategory::orderBy('name')->get();
        } catch (Exception $e) {
            \Log::error('Error fetching tournament types for admin calendar', ['error' => $e->getMessage()]);
            return collect();
        }
    }

    /**
     * Build calendar data with validation
     */
    private function buildCalendarData($tournaments, $zones, $tournamentTypes, $user)
    {
        try {
            return [
                'tournaments' => $tournaments->map(function ($tournament) {
                    return $this->formatTournamentWithValidation($tournament);
                }),
                'userType' => 'admin',
                'userRoles' => [$user->user_type],
                'canModify' => true,
                'zones' => $zones,
                'types' => $tournamentTypes,
                'clubs' => collect(),
                'availabilities' => [],
                'assignments' => [],
                'totalTournaments' => $tournaments->count(),
                'lastUpdated' => now()->toISOString(),
            ];
        } catch (Exception $e) {
            \Log::error('Error building calendar data', ['error' => $e->getMessage()]);
            return $this->getEmptyCalendarData('error');
        }
    }

    /**
     * Format tournament data with validation
     */
    private function formatTournamentWithValidation($tournament)
    {
        try {
            // Validate required fields
            $title = $tournament->name ?: "Torneo #{$tournament->id}";
            $startDate = $tournament->start_date ?: now();
            $endDate = $tournament->end_date ?: $startDate;

            // Safely get related data
            $club = $tournament->club ? $tournament->club->name : 'Club non specificato';
            $zone = $tournament->zone ? $tournament->zone->name : 'Zona non specificata';
            $category = $tournament->tournamentCategory ? $tournament->tournamentCategory->name : 'Categoria non specificata';

            return [
                'id' => $tournament->id,
                'title' => $title,
                'start' => $startDate->format('Y-m-d'),
                'end' => $endDate->addDay()->format('Y-m-d'),
                'color' => $this->getEventColorSafe($tournament),
                'borderColor' => $this->getAdminBorderColorSafe($tournament),
                'extendedProps' => [
                    'club' => $club,
                    'zone' => $zone,
                    'zone_id' => $tournament->zone_id,
                    'category' => $category,
                    'status' => $tournament->status ?: 'unknown',
                    'tournament_url' => route('admin.tournaments.show', $tournament),
                    'deadline' => $tournament->availability_deadline?->format('d/m/Y') ?? 'Non specificata',
                    'days_until_deadline' => $tournament->days_until_deadline ?? 0,
                    'type_id' => $tournament->tournament_category_id,
                    'type' => $tournament->tournamentCategory,
                    'availabilities_count' => $tournament->availabilities()->count(),
                    'assignments_count' => $tournament->assignments()->count(),
                    'required_referees' => $tournament->required_referees ?? 1,
                    'max_referees' => $tournament->max_referees ?? 4,
                    'management_priority' => $this->getManagementPrioritySafe($tournament),
                ],
            ];

        } catch (Exception $e) {
            \Log::error('Error formatting tournament', [
                'tournament_id' => $tournament->id ?? 'unknown',
                'error' => $e->getMessage()
            ]);

            // Return minimal safe tournament data
            return [
                'id' => $tournament->id ?? 0,
                'title' => 'Torneo (errore dati)',
                'start' => now()->format('Y-m-d'),
                'end' => now()->addDay()->format('Y-m-d'),
                'color' => '#6B7280',
                'borderColor' => '#EF4444',
                'extendedProps' => [
                    'club' => 'Errore dati',
                    'zone' => 'Errore dati',
                    'category' => 'Errore dati',
                    'status' => 'error',
                    'error' => 'Dati torneo incompleti'
                ],
            ];
        }
    }

    /**
     * Safe color methods with fallbacks
     */
    private function getEventColorSafe($tournament): string
    {
        try {
            return $this->getEventColor($tournament);
        } catch (Exception $e) {
            return '#6B7280'; // Default gray
        }
    }

    private function getAdminBorderColorSafe($tournament): string
    {
        try {
            return $this->getAdminBorderColor($tournament);
        } catch (Exception $e) {
            return '#EF4444'; // Default red for errors
        }
    }

    private function getManagementPrioritySafe($tournament): string
    {
        try {
            return $this->getManagementPriority($tournament);
        } catch (Exception $e) {
            return 'unknown';
        }
    }

    /**
     * Get empty calendar data for error states
     */
    private function getEmptyCalendarData($reason = 'empty'): array
    {
        return [
            'tournaments' => collect(),
            'userType' => 'admin',
            'userRoles' => ['admin'],
            'canModify' => false,
            'zones' => collect(),
            'types' => collect(),
            'clubs' => collect(),
            'availabilities' => [],
            'assignments' => [],
            'totalTournaments' => 0,
            'lastUpdated' => now()->toISOString(),
            'error_state' => $reason,
        ];
    }


    /**
     * Get event color based on tournament category
     * TODO: Replace with your actual category color logic
     */
    private function getEventColor($tournament): string
    {
        return match($tournament->tournamentCategory->name ?? 'default') {
            'Categoria A' => '#FF6B6B',
            'Categoria B' => '#4ECDC4',
            'Categoria C' => '#45B7D1',
            'Categoria D' => '#96CEB4',
            default => '#3B82F6'
        };
    }

    /**
     * Admin border color - based on tournament status
     */
    private function getAdminBorderColor($tournament): string
    {
        return match($tournament->status) {
            'published' => '#10B981',   // Green
            'draft' => '#F59E0B',       // Amber
            'closed' => '#6B7280',      // Gray
            'cancelled' => '#EF4444',   // Red
            default => '#6B7280'        // Gray default
        };
    }

    /**
     * Calculate management priority for admin focus
     */
    private function getManagementPriority($tournament): string
    {
        $availabilities = $tournament->availabilities()->count();
        $assignments = $tournament->assignments()->count();
        $required = $tournament->required_referees ?? $tournament->tournamentCategory->min_referees ?? 1;
        $daysUntilDeadline = $tournament->days_until_deadline ?? 999;

        // Urgent: Missing referees or overdue deadline
        if ($daysUntilDeadline < 0 || $assignments < $required) {
            return 'urgent';
        }

        // Complete: Fully staffed
        if ($assignments >= $required) {
            return 'complete';
        }

        // In progress: Has some availability/assignments but not complete
        if ($availabilities > 0 || $assignments > 0) {
            return 'in_progress';
        }

        // Open: Ready for availability submissions
        return 'open';
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Club;
use App\Models\Zone;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;
use App\Http\Traits\CrudActions;

class ClubController extends Controller
{
    use CrudActions;

    /**
     * Display a listing of clubs.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        $query = Club::with(['zone']);

        // Filter by zone for non-national admins
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        // Apply search filter
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('code', 'like', "%{$search}%")
                    ->orWhere('city', 'like', "%{$search}%");
            });
        }

        // Apply zone filter
        if ($request->filled('zone_id')) {
            $query->where('zone_id', $request->zone_id);
        }

        // Apply status filter
        if ($request->filled('status')) {
            $query->where('is_active', $request->status === 'active');
        }

        $clubs = $query
            ->withCount('tournaments')
            ->orderBy('is_active', 'desc')
            ->orderBy('name')
            ->paginate(20)
            ->withQueryString();

        // Get zones for filter
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        return view('admin.clubs.index', compact('clubs', 'zones', 'isNationalAdmin'));
    }

    /**
     * Show the form for creating a new club.
     */
    public function create(): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        return view('admin.clubs.create', compact('zones'));
    }

    /**
     * Store a newly created club in storage.
     */
    public function store(Request $request): RedirectResponse
    {
        $user = auth()->user();

        $request->validate([
            'name' => 'required|string|max:255',
            'code' => 'required|string|max:50|unique:clubs,code',
            'zone_id' => 'required|exists:zones,id',
            'city' => 'required|string|max:100',
            'province' => 'nullable|string|max:2',
            'email' => 'nullable|email|max:255',
            'phone' => 'nullable|string|max:20',
            'address' => 'nullable|string|max:255',
            'contact_person' => 'nullable|string|max:255',
            'notes' => 'nullable|string',
            'is_active' => 'boolean',
        ]);

        // Check zone access for non-national admins
        if ($user->user_type === 'admin' && $request->zone_id != $user->zone_id) {
            abort(403, 'Non puoi creare club in zone diverse dalla tua.');
        }

        $club = Club::create($request->all());

        return redirect()
            ->route('admin.clubs.index')
            ->with('success', "Club \"{$club->name}\" creato con successo!");
    }

    /**
     * Display the specified club.
     */
    public function show(Club $club): View
    {
        $this->checkClubAccess($club);

        $club->load(['zone', 'tournaments.tournamentCategory']);

        // Get statistics
        $stats = [
            'total_tournaments' => $club->tournaments()->count(),
            'upcoming_tournaments' => $club->tournaments()->upcoming()->count(),
            'active_tournaments' => $club->tournaments()->active()->count(),
            'completed_tournaments' => $club->tournaments()->where('status', 'completed')->count(),
        ];

        // Get recent tournaments
        $recentTournaments = $club->tournaments()
            ->with(['tournamentCategory', 'zone'])
            ->orderBy('start_date', 'desc')
            ->limit(10)
            ->get();

        return view('admin.clubs.show', compact('club', 'stats', 'recentTournaments'));
    }

    /**
     * Show the form for editing the specified club.
     */
    public function edit(Club $club): View
    {
        $this->checkClubAccess($club);

        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        return view('admin.clubs.edit', compact('club', 'zones'));
    }

    /**
     * Update the specified club in storage.
     */
    public function update(Request $request, Club $club): RedirectResponse
    {
        $this->checkClubAccess($club);

        $user = auth()->user();

        $request->validate([
            'name' => 'required|string|max:255',
            'code' => 'required|string|max:50|unique:clubs,code,' . $club->id,
            'zone_id' => 'required|exists:zones,id',
            'city' => 'required|string|max:100',
            'province' => 'nullable|string|max:2',
            'email' => 'nullable|email|max:255',
            'phone' => 'nullable|string|max:20',
            'address' => 'nullable|string|max:255',
            'contact_person' => 'nullable|string|max:255',
            'notes' => 'nullable|string',
            'is_active' => 'boolean',
        ]);

        // Check zone access for non-national admins
        if ($user->user_type === 'admin' && $request->zone_id != $user->zone_id) {
            abort(403, 'Non puoi spostare club in zone diverse dalla tua.');
        }

        $club->update($request->all());

        return redirect()
            ->route('admin.clubs.show', $club)
            ->with('success', "Club \"{$club->name}\" aggiornato con successo!");
    }

    /**
     * Remove the specified club from storage.
     */
    public function destroy(Club $club): RedirectResponse
    {
        $this->checkClubAccess($club);

        if (!$club->canBeDeleted()) {
            return redirect()
                ->route('admin.clubs.index')
                ->with('error', 'Impossibile eliminare un club con tornei associati.');
        }

        $name = $club->name;
        $club->delete();

        return redirect()
            ->route('admin.clubs.index')
            ->with('success', "Club \"{$name}\" eliminato con successo!");
    }

    /**
     * Toggle club active status.
     */
    public function toggleActive(Club $club): RedirectResponse
    {
        $this->checkClubAccess($club);

        $club->update(['is_active' => !$club->is_active]);

        $status = $club->is_active ? 'attivato' : 'disattivato';

        return redirect()->back()
            ->with('success', "Club \"{$club->name}\" {$status} con successo!");
    }

    /**
     * Get clubs for a specific zone (AJAX).
     */
    public function getClubsByZone(Request $request)
    {
        $request->validate([
            'zone_id' => 'required|exists:zones,id',
        ]);

        $user = auth()->user();

        // Check zone access for non-national admins
        if ($user->user_type === 'admin' && $request->zone_id != $user->zone_id) {
            return response()->json([], 403);
        }

        $clubs = Club::active()
            ->where('zone_id', $request->zone_id)
            ->ordered()
            ->get(['id', 'name', 'code']);

        return response()->json($clubs);
    }
    public function deactivate(Club $club)
    {
        $club->update(['is_active' => false]);

        return redirect()
            ->route('admin.clubs.index')
            ->with('success', 'Club disattivato con successo.');
    }
    /**
     * Check if user can access the club.
     */
    private function checkClubAccess(Club $club): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $club->zone_id !== $user->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere a questo club.');
        }
    }
    protected function getEntityName($model): string
    {
        return 'Club';
    }

    protected function getIndexRoute(): string
    {
        return 'admin.clubs.index';
    }

    protected function getDeleteErrorMessage($model): string
    {
        return 'Impossibile eliminare un club con tornei associati.';
    }

    protected function canBeDeleted($club): bool
    {
        return !$club->tournaments()->exists();
    }

    protected function checkAccess($club): void
    {
        $this->checkClubAccess($club);
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class CommunicationController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use App\Models\User;
use App\Models\Assignment;
use Illuminate\View\View;
use Carbon\Carbon;

class DashboardController extends Controller
{
    /**
     * Display the admin dashboard.
     */
    public function index(): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin';

        // Get statistics based on user access
        $stats = $this->getStatistics($user, $isNationalAdmin);

        // Get alerts (unconfirmed assignments, tournaments needing referees, etc.)
        $alerts = $this->getAlerts($user, $isNationalAdmin);

        // Get tournaments that need referees
        $tournamentsNeedingReferees = $this->getTournamentsNeedingReferees($user, $isNationalAdmin);

        // Get recent assignments
        $recentAssignments = $this->getRecentAssignments($user, $isNationalAdmin);

        return view('admin.dashboard', compact(
            'isNationalAdmin',
            'stats',
            'alerts',
            'tournamentsNeedingReferees',
            'recentAssignments'
        ));
    }

    /**
     * Get statistics for the dashboard.
     */
    private function getStatistics($user, $isNationalAdmin): array
    {
        $query = Tournament::query();

        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        $totalTournaments = $query->count();
        $activeTournaments = (clone $query)->whereIn('status', ['open', 'closed', 'assigned'])->count();
        $completedTournaments = (clone $query)->where('status', 'completed')->count();

        $assignmentQuery = Assignment::query();
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $assignmentQuery->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        $totalAssignments = $assignmentQuery->count();
        $pendingConfirmations = (clone $assignmentQuery)->where('is_confirmed', false)->count();

        $refereeQuery = User::where('user_type', 'referee')->where('is_active', true);
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $refereeQuery->where('zone_id', $user->zone_id);
        }

        $activeReferees = $refereeQuery->count();

        return [
            'total_tournaments' => $totalTournaments,
            'active_tournaments' => $activeTournaments,
            'completed_tournaments' => $completedTournaments,
            'total_assignments' => $totalAssignments,
            'pending_confirmations' => $pendingConfirmations,
            'active_referees' => $activeReferees,
            'zones_count' => $isNationalAdmin ? \App\Models\Zone::count() : 1,
            'upcoming_tournaments' => (clone $query)->where('start_date', '>=', Carbon::today())->count(),
        ];
    }

    /**
     * Get alerts for the dashboard.
     */
    private function getAlerts($user, $isNationalAdmin): array
    {
        $alerts = [];

        // Check for tournaments needing referees
        $tournamentsNeedingReferees = $this->getTournamentsNeedingReferees($user, $isNationalAdmin)->count();
        if ($tournamentsNeedingReferees > 0) {
            $alerts[] = [
                'type' => 'warning',
                'message' => "Ci sono {$tournamentsNeedingReferees} tornei che necessitano di arbitri."
            ];
        }

        // Check for unconfirmed assignments
        $assignmentQuery = Assignment::where('is_confirmed', false);
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $assignmentQuery->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }
        $unconfirmedAssignments = $assignmentQuery->count();

        if ($unconfirmedAssignments > 0) {
            $alerts[] = [
                'type' => 'info',
                'message' => "Ci sono {$unconfirmedAssignments} assegnazioni in attesa di conferma."
            ];
        }

        return $alerts;
    }

    /**
     * Get tournaments that need referees.
     */
    private function getTournamentsNeedingReferees($user, $isNationalAdmin)
    {
        $query = Tournament::with(['club', 'tournamentCategory'])
            ->whereIn('status', ['open', 'closed'])
            ->where('start_date', '>=', Carbon::today());

        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        // Filter tournaments that need more referees
        return $query->get()->filter(function ($tournament) {
            $assignedReferees = $tournament->assignments()->count();
            $requiredReferees = $tournament->tournamentCategory->max_referees ?? 1;
            return $assignedReferees < $requiredReferees;
        })->take(10);
    }

    /**
     * Get recent assignments.
     */
    private function getRecentAssignments($user, $isNationalAdmin)
    {
        $query = Assignment::with(['user', 'tournament.club', 'assignedBy'])
            ->orderBy('created_at', 'desc');

        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        return $query->limit(10)->get();
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class NotificationController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Models\Referee;
use App\Models\Zone;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\View\View;

class RefereeController extends Controller
{
    /**
     * Display a listing of referees.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        $query = User::where('user_type', 'referee')
            ->with(['zone'])
            ->withCount(['assignments', 'availabilities']);

        // Filter by zone for non-national admins
        if (!$isNationalAdmin && $user->user_type !== 'super_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        // Apply search filter
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('email', 'like', "%{$search}%")
                    ->orWhere('referee_code', 'like', "%{$search}%");
            });
        }

        // Apply zone filter
        if ($request->filled('zone_id')) {
            $query->where('zone_id', $request->zone_id);
        }

        // Apply level filter
        if ($request->filled('level')) {
            $query->where('level', $request->level);
        }

        // Apply status filter
        if ($request->filled('status')) {
            $query->where('is_active', $request->status === 'active');
        }

        $referees = $query
            ->orderBy('is_active', 'desc')
            ->orderBy('name')
            ->paginate(20)
            ->withQueryString();

        // Get zones and levels for filters
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

$levels = [
    'aspirante' => 'Aspirante',
    'primo_livello' => 'Primo Livello',
    'regionale' => 'Regionale',
    'nazionale' => 'Nazionale',
            'internazionale' => 'Internazionale',
];

        return view('admin.referees.index', compact('referees', 'zones', 'levels', 'isNationalAdmin'));
}
    /**
     * Show the form for creating a new referee.
     */
    public function create()
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        // Get referee levels from User model
        $levels = User::REFEREE_LEVELS;

        // Get zones based on user permissions
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        return view('admin.referees.create', compact('levels', 'zones'));
    }
    /**
     * Store a newly created referee in storage.
     */
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email',
            'phone' => 'nullable|string|max:20',
            'level' => 'required|string',
            'zone_id' => 'required|exists:zones,id',
            'notes' => 'nullable|string',
            'is_active' => 'boolean'
        ]);

        try {
            \DB::beginTransaction();

            // 1. Crea l'utente
            $user = User::create([
                'name' => $request->name,
                'email' => $request->email,
                'password' => bcrypt('password123'), // Password temporanea
                'user_type' => 'referee',
                'zone_id' => $request->zone_id,
                'phone' => $request->phone,
                'is_active' => $request->boolean('is_active', true),
                'email_verified_at' => now(),
            ]);

            // 2. Genera codice arbitro automaticamente
            $refereeCode = 'REF' . str_pad($user->id, 4, '0', STR_PAD_LEFT);

            // 3. Crea il referee collegato
            $referee = Referee::create([
                'user_id' => $user->id,
                'zone_id' => $request->zone_id,
                'referee_code' => $refereeCode,
                'level' => $request->level,
                'category' => 'misto', // Default
                'certified_date' => now(),
                'bio' => 'Nuovo arbitro creato dall\'amministrazione',
                'experience_years' => 0,
                'specializations' => json_encode(['stroke_play']),
                'languages' => json_encode(['it']),
                'notes' => $request->notes,
                'profile_completed_at' => now(), // Forza completamento
                'created_at' => now(),
                'updated_at' => now(),
            ]);

            \DB::commit();

            return redirect()
                ->route('admin.referees.index')
                ->with('success', "Arbitro {$user->name} creato con successo! Codice: {$refereeCode}");
        } catch (\Exception $e) {
            \DB::rollback();

            return redirect()
                ->back()
                ->withInput()
                ->with('error', 'Errore durante la creazione dell\'arbitro: ' . $e->getMessage());
        }
    }
    /**
     * Display the specified referee.
     */
    public function show(User $referee): View
    {
        if (!$referee->isReferee()) {
            abort(404, 'Arbitro non trovato.');
        }

        $this->checkRefereeAccess($referee);

        $referee->load([
            'zone',
            'assignments.tournament.club',
            'availabilities.tournament.club'
        ]);

        // Get statistics
        $stats = [
            'total_assignments' => $referee->assignments()->count(),
            'confirmed_assignments' => $referee->assignments()->where('is_confirmed', true)->count(),
            'current_year_assignments' => $referee->assignments()->whereYear('created_at', now()->year)->count(),
            'total_availabilities' => $referee->availabilities()->count(),
            'upcoming_assignments' => $referee->assignments()->upcoming()->count(),
        ];

        // Get recent assignments and availabilities
        $recentAssignments = $referee->assignments()
            ->with(['tournament.club'])
            ->orderBy('created_at', 'desc')
            ->limit(10)
            ->get();

        $recentAvailabilities = $referee->availabilities()
            ->with(['tournament.club'])
            ->orderBy('created_at', 'desc')
            ->limit(10)
            ->get();

        return view('admin.referees.show', compact('referee', 'stats', 'recentAssignments', 'recentAvailabilities'));
    }

    /**
     * Show the form for editing the specified referee.
     */
public function edit($id)
{
    // $id è l'ID dell'User, non del Referee
    $user = User::where('user_type', 'referee')->findOrFail($id);
    $referee = $user->referee;

    // Se l'user non ha un referee collegato, crealo
    if (!$referee) {
        $referee = Referee::create([
            'user_id' => $user->id,
            'zone_id' => $user->zone_id,
            'referee_code' => 'REF' . str_pad($user->id, 4, '0', STR_PAD_LEFT),
            'level' => $user->level ?: 'primo_livello',
            'category' => 'misto',
            'certified_date' => now(),
        ]);
    }

    $levels = [
        'aspirante' => 'Aspirante',
        'primo_livello' => 'Primo Livello',
        'regionale' => 'Regionale',
        'nazionale' => 'Nazionale',
        'internazionale' => 'Internazionale'
    ];

    $zones = Zone::all();

    return view('admin.referees.edit', compact('referee', 'levels', 'zones'));
}

    /**
     * Update the specified referee.
     */

public function update(Request $request, User $referee): RedirectResponse
{
    if (!$referee->isReferee()) {
        abort(404, 'Arbitro non trovato.');
    }

    $this->checkRefereeAccess($referee);

    $user = auth()->user();

    $request->validate([
        'name' => 'required|string|max:255',
        'email' => 'required|email|max:255|unique:users,email,' . $referee->id,
        'phone' => 'nullable|string|max:20',
        'city' => 'nullable|string|max:100',
        'zone_id' => 'required|exists:zones,id',
        'level' => 'required|in:aspirante,primo_livello,regionale,nazionale,internazionale',
        'referee_code' => 'nullable|string|max:20', // ✅ CAMBIATO da required
        'is_active' => 'boolean',
    ]);

    // Check zone access for non-national admins
    if ($user->user_type === 'admin' && $request->zone_id != $user->zone_id) {
        abort(403, 'Non puoi spostare arbitri in zone diverse dalla tua.');
    }

    // ✅ AGGIORNA SOLO I CAMPI SPECIFICI invece di $request->all()
    $referee->update([
        'name' => $request->name,
        'email' => $request->email,
        'phone' => $request->phone,
        'city' => $request->city,
        'zone_id' => $request->zone_id,
        'level' => $request->level,
        'referee_code' => $request->referee_code ?: $referee->referee_code,
        'is_active' => $request->boolean('is_active', true),
    ]);

    return redirect()
        ->route('admin.referees.show', $referee)
        ->with('success', "Arbitro \"{$referee->name}\" aggiornato con successo!");
}

    /**
     * Toggle referee active status.
     */
    public function toggleActive(User $referee): RedirectResponse
    {
        if (!$referee->isReferee()) {
            abort(404, 'Arbitro non trovato.');
        }

        $this->checkRefereeAccess($referee);

        $referee->update(['is_active' => !$referee->is_active]);

        $status = $referee->is_active ? 'attivato' : 'disattivato';

        return redirect()->back()
            ->with('success', "Arbitro \"{$referee->name}\" {$status} con successo!");
    }

    /**
     * Remove the specified referee.
     */
    public function destroy(User $referee): RedirectResponse
    {
        if (!$referee->isReferee()) {
            abort(404, 'Arbitro non trovato.');
        }

        $this->checkRefereeAccess($referee);

        // Check if referee has active assignments
        if ($referee->assignments()->whereHas('tournament', function ($q) {
            $q->whereIn('status', ['open', 'closed', 'assigned']);
        })->exists()) {
            return redirect()
                ->route('admin.referees.index')
                ->with('error', 'Impossibile eliminare un arbitro con assegnazioni attive.');
        }

        $name = $referee->name;
        $referee->delete();

        return redirect()
            ->route('admin.referees.index')
            ->with('success', "Arbitro \"{$name}\" eliminato con successo!");
    }

    /**
     * Check if user can access the referee.
     */
    private function checkRefereeAccess(User $referee): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $referee->zone_id !== $user->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere a questo arbitro.');
        }
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Http\Requests\TournamentRequest;
use App\Models\Tournament;
use App\Models\TournamentCategory;
use App\Models\club;
use App\Models\Zone;
use Carbon\Carbon;
use Illuminate\Http\Request;
use App\Http\Traits\CrudActions;

class TournamentController extends Controller
{
    use CrudActions;

    /**
     * Display a listing of tournaments.
     */
    public function index(Request $request)
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        // Base query
        $query = Tournament::with(['tournamentCategory', 'zone', 'club', 'assignments']);

        // Filter by zone for zone admins
        if (!$isNationalAdmin && !in_array($user->user_type, ['super_admin'])) {
            $query->where('zone_id', $user->zone_id);
        }

        // Apply filters
        if ($request->has('status') && $request->status !== '') {
            $query->where('status', $request->status);
        }

        if ($request->has('zone_id') && $request->zone_id !== '') {
            $query->where('zone_id', $request->zone_id);
        }

        if ($request->has('category_id') && $request->category_id !== '') {
            $query->where('tournament_category_id', $request->category_id);
        }

        if ($request->has('month') && $request->month !== '') {
            $startOfMonth = Carbon::parse($request->month)->startOfMonth();
            $endOfMonth = Carbon::parse($request->month)->endOfMonth();
            $query->where(function ($q) use ($startOfMonth, $endOfMonth) {
                $q->whereBetween('start_date', [$startOfMonth, $endOfMonth])
                    ->orWhereBetween('end_date', [$startOfMonth, $endOfMonth]);
            });
        }

        // Search
        if ($request->has('search') && $request->search !== '') {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhereHas('club', function ($q2) use ($search) {
                        $q2->where('name', 'like', "%{$search}%");
                    });
            });
        }

        // Order by start date descending
        $tournaments = $query->orderBy('start_date', 'desc')->paginate(20);

        // Get data for filters
        $zones = $isNationalAdmin ? Zone::orderBy('name')->get() : collect();
        $categories = TournamentCategory::active()->ordered()->get();
        $statuses = Tournament::STATUSES;

        return view('admin.tournaments.index', compact(
            'tournaments',
            'zones',
            'categories',
            'statuses',
            'isNationalAdmin'
        ));
    }
    /**
     * Show tournaments calendar view
     */
    public function calendar(Request $request)
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin' || $user->user_type === 'admin';

        // ✅ CONTROLLO SEMPLICE PRIMA:
        $tournamentCount = Tournament::count();

        // Get tournaments for calendar
        $tournaments = Tournament::with(['tournamentCategory', 'zone', 'club', 'assignments.user'])
            ->when(!$isNationalAdmin && !in_array($user->user_type, ['super_admin']), function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->get();

        // Get zones for filter
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        // Get clubs for filter
        $clubs = \App\Models\Club::active()
            ->when(!$isNationalAdmin && !in_array($user->user_type, ['super_admin']), function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->orderBy('name')
            ->get();

        // Get tournament types
        $types = TournamentCategory::active()->ordered()->get();

        // User roles for permissions
        $userRoles = ['Admin'];
        if ($user->user_type === 'super_admin') {
            $userRoles[] = 'SuperAdmin';
        } elseif ($user->user_type === 'national_admin') {
            $userRoles[] = 'NationalAdmin';
        }

        // Format tournaments for calendar
        $calendarTournaments = $tournaments->map(function ($tournament) {
            return [
                'id' => $tournament->id,
                'title' => $tournament->name,                              // ← AGGIUNGI title
                'start' => $tournament->start_date->format('Y-m-d'),       // ← CORRETTO
                'end' => $tournament->end_date->addDay()->format('Y-m-d'), // ← CORRETTO + 1 giorno
                'color' => '#3b82f6', // Default color
                'borderColor' => '#1e40af',
                'extendedProps' => [
                    'club' => $tournament->club->name ?? 'N/A',
                    'zone' => $tournament->zone->name ?? 'N/A',
                    'zone_id' => $tournament->zone_id,
                    'category' => $tournament->tournamentCategory->name ?? 'N/A',
                    'status' => $tournament->status,
                    'tournament_url' => route('admin.tournaments.show', $tournament),
                    'deadline' => $tournament->availability_deadline?->format('d/m/Y') ?? 'N/A',
                    'type_id' => $tournament->tournament_category_id,
                    'availabilities_count' => $tournament->availabilities()->count(),
                    'assignments_count' => $tournament->assignments()->count(),
                    'required_referees' => $tournament->required_referees ?? 1,
                    'max_referees' => $tournament->max_referees ?? 4,
                    'management_priority' => 'open',
                ],
            ];
        });
        // Prepare data for React component
        $calendarData = [
            'tournaments' => $calendarTournaments,
            'zones' => $zones->map(function ($zone) {
                return [
                    'id' => $zone->id,
                    'name' => $zone->name,
                ];
            }),
            'clubs' => $clubs->map(function ($club) {
                return [
                    'id' => $club->id,
                    'name' => $club->name,
                    'zone_id' => $club->zone_id,
                ];
            }),
            'types' => $types->map(function ($type) {
                return [
                    'id' => $type->id,
                    'name' => $type->name,
                    'code' => $type->code,
                    'is_national' => $type->is_national,
                ];
            }),
            'userRoles' => $userRoles,
            'userType' => 'admin', // ← AGGIUNGI QUESTA RIGA
            'canModify' => true,   // ← AGGIUNGI QUESTA RIGA
        ];

        return view('admin.tournaments.calendar', compact('calendarData'));
    }

    /**
     * Show the form for creating a new tournament.
     */
    public function create()
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        // Get categories available for user's zone
        $categories = TournamentCategory::active()
            ->when(!$isNationalAdmin, function ($q) use ($user) {
                $q->where(function ($q2) use ($user) {
                    $q2->where('is_national', false)
                        ->whereJsonContains('settings->visibility_zones', $user->zone_id);
                })->orWhere('is_national', true);
            })
            ->ordered()
            ->get();

        // Get zones
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        // Get clubs for the selected zone
        $clubs = club::active()
            ->when(!$isNationalAdmin, function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->ordered()
            ->get();

        return view('admin.tournaments.create', compact('categories', 'zones', 'clubs'));
    }

    /**
     * Store a newly created tournament in storage.
     */
    public function store(TournamentRequest $request)
    {
        $data = $request->validated();

        // Set zone_id from club if not national admin
        if (auth()->user()->user_type !== 'national_admin') {
            $club = club::findOrFail($data['club_id']);
            $data['zone_id'] = $club->zone_id;
        }

        // Create tournament
        $tournament = Tournament::create($data);

        return redirect()
            ->route('tournaments.show', $tournament)
            ->with('success', 'Torneo creato con successo!');
    }

    /**
     * Display the specified tournament for admin view
     */
    public function show(Tournament $tournament)
    {
        $user = auth()->user();

        // Check permissions (zone admin can only see their zone tournaments)
        if ($user->user_type === 'admin' && $user->zone_id !== $tournament->zone_id) {
            abort(403, 'Non hai i permessi per visualizzare questo torneo.');
        }

        // Load relationships
        $tournament->load([
            'tournamentCategory',
            'zone',
            'club',
            'assignments.referee',
            'availabilities.referee'
        ]);

        // Get statistics
        $stats = [
            'total_referees' => $tournament->availabilities()->count(),
            'assigned_referees' => $tournament->assignments()->count(),
            'required_referees' => $tournament->required_referees ?? $tournament->tournamentCategory->min_referees ?? 1,
            'max_referees' => $tournament->max_referees ?? $tournament->tournamentCategory->max_referees ?? 4,
            'days_until_deadline' => $tournament->days_until_deadline,
            'is_editable' => method_exists($tournament, 'isEditable') ? $tournament->isEditable() : true,
        ];

        return view('admin.tournaments.show', compact('tournament', 'stats'));
    }

    /**
     * Show the form for editing the specified tournament.
     */
    public function edit(Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Check if editable
        if (!$tournament->isEditable()) {
            return redirect()
                ->route('tournaments.show', $tournament)
                ->with('error', 'Questo torneo non può essere modificato nel suo stato attuale.');
        }

        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin' || $user->user_type === 'super_admin';

        // Get categories
        $categories = TournamentCategory::active()
            ->when(!$isNationalAdmin, function ($q) use ($user) {
                $q->where(function ($q2) use ($user) {
                    $q2->where('is_national', false)
                        ->whereJsonContains('settings->visibility_zones', $user->zone_id);
                })->orWhere('is_national', true);
            })
            ->ordered()
            ->get();

        // Get zones
        $zones = $isNationalAdmin
            ? Zone::orderBy('name')->get()
            : Zone::where('id', $user->zone_id)->get();

        // Get clubs
        $clubs = club::active()
            ->where('zone_id', $tournament->zone_id)
            ->ordered()
            ->get();

        return view('admin.tournaments.edit', compact('tournament', 'categories', 'zones', 'clubs'));
    }

    /**
     * Update the specified tournament in storage.
     */
    public function update(TournamentRequest $request, Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Check if editable
        if (!$tournament->isEditable()) {
            return redirect()
                ->route('tournaments.show', $tournament)
                ->with('error', 'Questo torneo non può essere modificato nel suo stato attuale.');
        }

        $data = $request->validated();

        // Update zone_id from club if changed
        if (isset($data['club_id']) && $data['club_id'] != $tournament->club_id) {
            $club = club::findOrFail($data['club_id']);
            $data['zone_id'] = $club->zone_id;
        }

        $tournament->update($data);

        return redirect()
            ->route('tournaments.show', $tournament)
            ->with('success', 'Torneo aggiornato con successo!');
    }

    /**
     * Remove the specified tournament from storage.
     */
    public function destroy(Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Check if can be deleted
        if ($tournament->assignments()->exists()) {
            return redirect()
                ->route('admin.tournaments.index')
                ->with('error', 'Impossibile eliminare un torneo con assegnazioni.');
        }

        if ($tournament->status !== 'draft') {
            return redirect()
                ->route('admin.tournaments.index')
                ->with('error', 'Solo i tornei in bozza possono essere eliminati.');
        }

        $tournament->delete();

        return redirect()
            ->route('admin.tournaments.index')
            ->with('success', 'Torneo eliminato con successo!');
    }

    /**
     * Update tournament status.
     */
    public function updateStatus(Request $request, Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        $request->validate([
            'status' => ['required', 'in:' . implode(',', array_keys(Tournament::STATUSES))],
        ]);

        $newStatus = $request->status;
        $currentStatus = $tournament->status;

        // Validate status transition
        $validTransitions = [
            'draft' => ['open'],
            'open' => ['closed'],
            'closed' => ['open', 'assigned'],
            'assigned' => ['completed'],
            'completed' => [],
        ];

        if (!in_array($newStatus, $validTransitions[$currentStatus] ?? [])) {
            return response()->json([
                'success' => false,
                'message' => 'Transizione di stato non valida.'
            ], 400);
        }

        // Additional checks
        if ($newStatus === 'assigned' && $tournament->assignments()->count() < $tournament->required_referees) {
            return response()->json([
                'success' => false,
                'message' => 'Non ci sono abbastanza arbitri assegnati.'
            ], 400);
        }

        $tournament->update(['status' => $newStatus]);

        return response()->json([
            'success' => true,
            'message' => 'Stato aggiornato con successo.',
            'new_status' => $newStatus,
            'new_status_label' => Tournament::STATUSES[$newStatus],
            'new_status_color' => $tournament->status_color,
        ]);
    }

    /**
     * Show availabilities for a tournament.
     */
    public function availabilities(Tournament $tournament)
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Get available referees with their level and zone
        $availabilities = $tournament->availabilities()
            ->with(['user' => function ($query) {
                $query->with('zone');
            }])
            ->get()
            ->sortBy('user.name');

        // Get all eligible referees who haven't declared availability
        $eligibleReferees = \App\Models\User::where('user_type', 'referee')
            ->where('is_active', true)
            ->when($tournament->tournamentCategory->is_national, function ($q) {
                $q->whereIn('level', ['nazionale', 'internazionale']);
            }, function ($q) use ($tournament) {
                $q->where('zone_id', $tournament->zone_id);
            })
            ->whereNotIn('id', $tournament->availabilities()->pluck('user_id'))
            ->whereNotIn('id', $tournament->assignments()->pluck('user_id'))
            ->orderBy('name')
            ->get();

        return view('admin.tournaments.availabilities', compact(
            'tournament',
            'availabilities',
            'eligibleReferees'
        ));
    }

    /**
     * Check if user can access tournament.
     */
    private function checkTournamentAccess(Tournament $tournament)
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $tournament->zone_id !== $user->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere a questo torneo.');
        }
    }

    /**
     * Get clubs for a specific zone (AJAX).
     */
    public function getclubsByZone(Request $request)
    {
        $request->validate([
            'zone_id' => 'required|exists:zones,id',
        ]);

        $clubs = club::active()
            ->where('zone_id', $request->zone_id)
            ->ordered()
            ->get(['id', 'name', 'code']);

        return response()->json($clubs);
    }

    /**
     * Configurazione per il trait
     */
    protected function getEntityName($model): string
    {
        return 'Torneo';
    }

    protected function getIndexRoute(): string
    {
        return 'admin.tournaments.index';
    }

    protected function getDeleteErrorMessage($model): string
    {
        return 'Impossibile eliminare un torneo con assegnazioni.';
    }

    protected function canBeDeleted($tournament): bool
    {
        return !$tournament->assignments()->exists() && $tournament->status === 'draft';
    }

    protected function checkAccess($tournament): void
    {
        $this->checkTournamentAccess($tournament);
    }

    /**
     * Display a listing of tournaments for admin management
     */


    /**
     * Display a public listing of tournaments (for all authenticated users including referees)
     */
    public function publicIndex(Request $request)
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level ?? '', ['nazionale', 'internazionale']);

        // Get tournaments visible to this user
        $query = Tournament::with(['tournamentCategory', 'zone', 'club'])
            ->where('status', '!=', 'draft'); // Hide drafts from public view

        // Zone filtering logic
        if (!$isNationalReferee && $user->zone_id) {
            $query->where('zone_id', $user->zone_id);
        }

        // Simple search
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhereHas('club', function ($q2) use ($search) {
                        $q2->where('name', 'like', "%{$search}%");
                    });
            });
        }

        $tournaments = $query->orderBy('start_date', 'desc')->paginate(20);

        return view('tournaments.index', compact('tournaments'));
    }

    /**
     * Display public calendar view
     */
    public function publicCalendar(Request $request)
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level ?? '', ['nazionale', 'internazionale']);

        // Get tournaments for calendar
        $tournaments = Tournament::with(['tournamentCategory', 'zone', 'club'])
            ->where('status', '!=', 'draft')
            ->when(!$isNationalReferee, function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->get();

        // Get user's availabilities and assignments if referee
        $userAvailabilities = [];
        $userAssignments = [];

        if ($user->user_type === 'referee') {
            $userAvailabilities = $user->availabilities()->pluck('tournament_id')->toArray();
            $userAssignments = $user->assignments()->pluck('tournament_id')->toArray();
        }

        // Format for calendar
        $calendarData = [
            'tournaments' => $tournaments->map(function ($tournament) use ($userAvailabilities, $userAssignments) {
                return [
                    'id' => $tournament->id,
                    'title' => $tournament->name,
                    'start' => $tournament->start_date->format('Y-m-d'),
                    'end' => $tournament->end_date->addDay()->format('Y-m-d'),
                    'color' => $tournament->tournamentCategory->calendar_color ?? '#3b82f6',
                    'extendedProps' => [
                        'club' => $tournament->club->name,
                        'zone' => $tournament->zone->name,
                        'category' => $tournament->tournamentCategory->name,
                        'status' => $tournament->status,
                        'available' => in_array($tournament->id, $userAvailabilities),
                        'assigned' => in_array($tournament->id, $userAssignments),
                    ],
                ];
            }),
        ];

        return view('tournaments.calendar', compact('calendarData'));
    }

    /**
     * Display public tournament details
     */
    public function publicShow(Tournament $tournament)
    {
        $user = auth()->user();

        // Check access - hide drafts from public
        if ($tournament->status === 'draft') {
            abort(404);
        }

        // Check zone access for zone-specific users
        if (
            !in_array($user->level ?? '', ['nazionale', 'internazionale']) &&
            $user->zone_id && $tournament->zone_id !== $user->zone_id
        ) {
            abort(403, 'Non hai accesso a questo torneo.');
        }

        $tournament->load([
            'tournamentCategory',
            'zone',
            'club',
            'assignments.user',
            'availabilities.user'
        ]);

        // Check if user has applied/is assigned (for referees)
        $userAvailability = null;
        $userAssignment = null;

        if ($user->user_type === 'referee') {
            $userAvailability = $tournament->availabilities()->where('user_id', $user->id)->first();
            $userAssignment = $tournament->assignments()->where('user_id', $user->id)->first();
        }

        return view('tournaments.show', compact('tournament', 'userAvailability', 'userAssignment'));
    }

    /**
     * ADMIN METHODS - Solo per admin/super admin
     */

    /**
     * Display admin listing of tournaments with full management features
     */
    public function adminIndex(Request $request)
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin';

        // Base query
        $query = Tournament::with(['tournamentCategory', 'zone', 'club', 'assignments']);

        // Filter by zone for zone admins
        if (!$isNationalAdmin && !in_array($user->user_type, ['super_admin'])) {
            $query->where('zone_id', $user->zone_id);
        }

        // Apply filters
        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('zone_id')) {
            $query->where('zone_id', $request->zone_id);
        }

        if ($request->filled('category_id')) {
            $query->where('tournament_category_id', $request->category_id);
        }

        if ($request->filled('month')) {
            $startOfMonth = \Carbon\Carbon::parse($request->month)->startOfMonth();
            $endOfMonth = \Carbon\Carbon::parse($request->month)->endOfMonth();
            $query->where(function ($q) use ($startOfMonth, $endOfMonth) {
                $q->whereBetween('start_date', [$startOfMonth, $endOfMonth])
                    ->orWhereBetween('end_date', [$startOfMonth, $endOfMonth]);
            });
        }

        // Search
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhereHas('club', function ($q2) use ($search) {
                        $q2->where('name', 'like', "%{$search}%");
                    });
            });
        }

        $tournaments = $query->orderBy('start_date', 'desc')->paginate(15);

        // Get data for filters
        $zones = $isNationalAdmin ? \App\Models\Zone::orderBy('name')->get() : collect();
        $categories = \App\Models\TournamentCategory::where('is_active', true)->orderBy('name')->get();

        // Define statuses
        $statuses = [
            'draft' => 'Bozza',
            'open' => 'Aperto',
            'closed' => 'Chiuso',
            'assigned' => 'Assegnato',
            'completed' => 'Completato'
        ];

        return view('admin.tournaments.index', compact(
            'tournaments',
            'zones',
            'categories',
            'statuses',
            'isNationalAdmin'
        ));
    }

    /**
     * Display admin calendar with management features
     */
    public function adminCalendar(Request $request)
    {
        $user = auth()->user();
        $isNationalAdmin = $user->user_type === 'national_admin';

        // Get tournaments for calendar
        $tournaments = Tournament::with(['tournamentCategory', 'zone', 'club', 'assignments', 'availabilities'])
            ->when(!$isNationalAdmin && !in_array($user->user_type, ['super_admin']), function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            })
            ->get();

        // Format for calendar with admin data
        $calendarData = [
            'tournaments' => $tournaments->map(function ($tournament) {
                return [
                    'id' => $tournament->id,
                    'title' => $tournament->name,
                    'start' => $tournament->start_date->format('Y-m-d'),
                    'end' => $tournament->end_date->addDay()->format('Y-m-d'),
                    'color' => $tournament->tournamentCategory->calendar_color ?? '#3b82f6',
                    'extendedProps' => [
                        'club' => $tournament->club->name,
                        'zone' => $tournament->zone->name,
                        'category' => $tournament->tournamentCategory->name,
                        'status' => $tournament->status,
                        'assignments_count' => $tournament->assignments()->count(),
                        'availabilities_count' => $tournament->availabilities()->count(),
                        'required_referees' => $tournament->required_referees ?? 1,
                        'can_edit' => true, // Admin can always edit
                    ],
                ];
            }),
        ];

        return view('admin.tournaments.calendar', compact('calendarData'));
    }
}
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class ZoneController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        //
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     */
    public function show(string $id)
    {
        //
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(string $id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, string $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(string $id)
    {
        //
    }
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class AvailabilityController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     */
    public function show(string $id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, string $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(string $id)
    {
        //
    }
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class CalendarController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     */
    public function show(string $id)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, string $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(string $id)
    {
        //
    }
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class RefereeController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class StatsController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class TournamentController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Http\Requests\Auth\LoginRequest;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\View\View;

class AuthenticatedSessionController extends Controller
{
    /**
     * Display the login view.
     */
    public function create(): View
    {
        return view('auth.login');
    }

    /**
     * Handle an incoming authentication request.
     */
    public function store(LoginRequest $request): RedirectResponse
    {
        $request->authenticate();

        $request->session()->regenerate();

        return redirect()->intended(route('dashboard', absolute: false));
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        Auth::guard('web')->logout();

        $request->session()->invalidate();

        $request->session()->regenerateToken();

        return redirect('/');
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Validation\ValidationException;
use Illuminate\View\View;

class ConfirmablePasswordController extends Controller
{
    /**
     * Show the confirm password view.
     */
    public function show(): View
    {
        return view('auth.confirm-password');
    }

    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard', absolute: false));
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\View\View;

class EmailVerificationPromptController extends Controller
{
    /**
     * Display the email verification prompt.
     */
    public function __invoke(Request $request): RedirectResponse|View
    {
        return $request->user()->hasVerifiedEmail()
                    ? redirect()->intended(route('dashboard', absolute: false))
                    : view('auth.verify-email');
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
use Illuminate\Validation\Rules;
use Illuminate\View\View;

class NewPasswordController extends Controller
{
    /**
     * Display the password reset view.
     */
    public function create(Request $request): View
    {
        return view('auth.reset-password', ['request' => $request]);
    }

    /**
     * Handle an incoming new password request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => ['required'],
            'email' => ['required', 'email'],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function (User $user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        return $status == Password::PASSWORD_RESET
                    ? redirect()->route('login')->with('status', __($status))
                    : back()->withInput($request->only('email'))
                        ->withErrors(['email' => __($status)]);
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules\Password;

class PasswordController extends Controller
{
    /**
     * Update the user's password.
     */
    public function update(Request $request): RedirectResponse
    {
        $validated = $request->validateWithBag('updatePassword', [
            'current_password' => ['required', 'current_password'],
            'password' => ['required', Password::defaults(), 'confirmed'],
        ]);

        $request->user()->update([
            'password' => Hash::make($validated['password']),
        ]);

        return back()->with('status', 'password-updated');
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
use Illuminate\View\View;

class PasswordResetLinkController extends Controller
{
    /**
     * Display the password reset link request view.
     */
    public function create(): View
    {
        return view('auth.forgot-password');
    }

    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        // We will send the password reset link to this user. Once we have attempted
        // to send the link, we will examine the response then see the message we
        // need to show to the user. Finally, we'll send out a proper response.
        $status = Password::sendResetLink(
            $request->only('email')
        );

        return $status == Password::RESET_LINK_SENT
                    ? back()->with('status', __($status))
                    : back()->withInput($request->only('email'))
                        ->withErrors(['email' => __($status)]);
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Auth\Events\Registered;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use Illuminate\View\View;

class RegisteredUserController extends Controller
{
    /**
     * Display the registration view.
     */
    public function create(): View
    {
        return view('auth.register');
    }

    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255'],
            'email' => ['required', 'string', 'lowercase', 'email', 'max:255', 'unique:'.User::class],
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user));

        Auth::login($user);

        return redirect(route('dashboard', absolute: false));
    }
}
<?php

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\Verified;
use Illuminate\Foundation\Auth\EmailVerificationRequest;
use Illuminate\Http\RedirectResponse;

class VerifyEmailController extends Controller
{
    /**
     * Mark the authenticated user's email address as verified.
     */
    public function __invoke(EmailVerificationRequest $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false).'?verified=1');
        }

        if ($request->user()->markEmailAsVerified()) {
            event(new Verified($request->user()));
        }

        return redirect()->intended(route('dashboard', absolute: false).'?verified=1');
    }
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class ApplicationController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use App\Models\Assignment;
use Illuminate\Http\Request;
use Illuminate\View\View;

class AssignmentController extends Controller
{
    /**
     * Display the referee's assignments.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();

        // Anno di default: corrente
        $year = $request->get('year', now()->year);

        // Query base per le assegnazioni dell'arbitro
        $query = Assignment::where('user_id', $user->id)
            ->with(['tournament.club', 'tournament.zone'])
            ->whereHas('tournament', function($q) use ($year) {
                $q->whereYear('start_date', $year);
            });

        // Filtro per stato
        if ($request->filled('status')) {
            $status = $request->status;
            if ($status === 'upcoming') {
                $query->whereHas('tournament', function($q) {
                    $q->where('start_date', '>=', now());
                });
            } elseif ($status === 'completed') {
                $query->whereHas('tournament', function($q) {
                    $q->where('end_date', '<', now());
                });
            } elseif ($status === 'confirmed') {
                $query->where('is_confirmed', true);
            } elseif ($status === 'pending') {
                $query->where('is_confirmed', false);
            }
        }

        // Ordina per data torneo
        $assignments = $query->orderBy(function($query) {
                return $query->select('start_date')
                    ->from('tournaments')
                    ->whereColumn('tournaments.id', 'assignments.tournament_id');
            }, 'desc')
            ->paginate(15)
            ->withQueryString();

        // Statistiche per l'anno corrente
        $stats = [
            'total' => Assignment::where('user_id', $user->id)
                ->whereHas('tournament', function($q) use ($year) {
                    $q->whereYear('start_date', $year);
                })->count(),

            'confirmed' => Assignment::where('user_id', $user->id)
                ->where('is_confirmed', true)
                ->whereHas('tournament', function($q) use ($year) {
                    $q->whereYear('start_date', $year);
                })->count(),

            'upcoming' => Assignment::where('user_id', $user->id)
                ->whereHas('tournament', function($q) use ($year) {
                    $q->where('start_date', '>=', now())
                     ->whereYear('start_date', $year);
                })->count(),

            'completed' => Assignment::where('user_id', $user->id)
                ->whereHas('tournament', function($q) use ($year) {
                    $q->where('end_date', '<', now())
                     ->whereYear('start_date', $year);
                })->count(),
        ];

        // Anni disponibili per il filtro
        $availableYears = Assignment::where('user_id', $user->id)
            ->join('tournaments', 'assignments.tournament_id', '=', 'tournaments.id')
            ->selectRaw('YEAR(tournaments.start_date) as year')
            ->distinct()
            ->orderBy('year', 'desc')
            ->pluck('year');

        return view('referee.assignments.index', compact(
            'assignments',
            'stats',
            'year',
            'availableYears'
        ));
    }

    /**
     * Show assignment details.
     */
    public function show(Assignment $assignment): View
    {
        // Verifica che l'assegnazione appartenga all'arbitro loggato
        if ($assignment->user_id !== auth()->id()) {
            abort(403, 'Non autorizzato a visualizzare questa assegnazione.');
        }

        $assignment->load([
            'tournament.club',
            'tournament.zone',
            'tournament.assignments.user', // Altri arbitri del torneo
        ]);

        return view('referee.assignments.show', compact('assignment'));
    }
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use App\Models\Availability;
use App\Models\Zone;
use Illuminate\Http\Request;
use Carbon\Carbon;
use Illuminate\View\View;


class AvailabilityController extends Controller
{
    /**
     * Display the availability summary page - SENZA AVAILABILITY_DEADLINE
     */
    public function index(Request $request)
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);

        // Get filter parameters - SOLO PER ARBITRI NAZIONALI
        $zoneId = $isNationalReferee ? $request->get('zone_id') : null;
        $categoryId = $isNationalReferee ? $request->get('category_id') : null;
        $month = $isNationalReferee ? $request->get('month') : null;

        // Base query - SENZA AVAILABILITY_DEADLINE
        $query = Tournament::with(['tournamentCategory', 'zone', 'club'])
            ->where(function ($q) use ($user) {
                $q->where(function ($q2) {
                    // Tornei futuri (status aperto o altro)
                    $q2->where('start_date', '>=', Carbon::today());
                })->orWhere(function ($q2) use ($user) {
                    // Oppure tornei dove l'arbitro ha già dato disponibilità
                    $q2->whereHas('availabilities', function ($q3) use ($user) {
                        $q3->where('user_id', $user->id);
                    });
                });
            });

        // Apply zone filter logic
        if ($isNationalReferee) {
            // Arbitri nazionali: zona propria + gare nazionali
            $query->where(function ($q) use ($user, $zoneId) {
                if ($zoneId) {
                    // Se filtro zona specificato, mostra solo quella zona
                    $q->where('zone_id', $zoneId);
                } else {
                    // Altrimenti: zona propria + gare nazionali ovunque
                    $q->where('zone_id', $user->zone_id)
                        ->orWhereHas('tournamentCategory', function ($q2) {
                            $q2->where('is_national', true);
                        });
                }
            });
        } else {
            // Arbitri aspiranti/primo_livello/regionali: SOLO zona propria
            $query->where('zone_id', $user->zone_id);
        }

        // Apply category filter SOLO SE SPECIFICATO E ARBITRO NAZIONALE
        if ($categoryId && $isNationalReferee) {
            $query->where('tournament_category_id', $categoryId);
        }

        // Apply month filter SOLO SE SPECIFICATO E ARBITRO NAZIONALE
        if ($month && $isNationalReferee) {
            $startOfMonth = Carbon::parse($month)->startOfMonth();
            $endOfMonth = Carbon::parse($month)->endOfMonth();
            $query->where(function ($q) use ($startOfMonth, $endOfMonth) {
                $q->whereBetween('start_date', [$startOfMonth, $endOfMonth])
                    ->orWhereBetween('end_date', [$startOfMonth, $endOfMonth])
                    ->orWhere(function ($q2) use ($startOfMonth, $endOfMonth) {
                        $q2->where('start_date', '<=', $startOfMonth)
                            ->where('end_date', '>=', $endOfMonth);
                    });
            });
        }

        // Order by start date
        $tournaments = $query->orderBy('start_date')->get();

        // Get user's current availabilities
        $userAvailabilities = $user->availabilities()
            ->pluck('tournament_id')
            ->toArray();

        // Get zones for filter (only for national referees)
        $zones = $isNationalReferee ? Zone::orderBy('name')->get() : collect();

        // Get categories visible to user (only for national referees)
        $categories = $isNationalReferee ? \App\Models\TournamentCategory::active()
            ->when(!$isNationalReferee, function ($q) use ($user) {
                $q->where(function ($q2) use ($user) {
                    $q2->where('is_national', false)
                        ->whereJsonContains('settings->visibility_zones', $user->zone_id);
                })->orWhere('is_national', true);
            })
            ->ordered()
            ->get() : collect();

        // Group tournaments by month for display
        $tournamentsByMonth = $tournaments->groupBy(function ($tournament) {
            return $tournament->start_date->format('Y-m');
        });

        return view('referee.availability.index', compact(
            'tournamentsByMonth',
            'userAvailabilities',
            'zones',
            'categories',
            'zoneId',
            'categoryId',
            'month',
            'isNationalReferee'
        ));
    }

    /**
     * Save referee availabilities - SENZA AVAILABILITY_DEADLINE
     */
    public function save(Request $request)
    {
        $request->validate([
            'availabilities' => 'array',
            'availabilities.*' => 'exists:tournaments,id',
            'notes' => 'array',
            'notes.*' => 'nullable|string|max:500',
        ]);

        $user = auth()->user();
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);
        $selectedTournaments = $request->input('availabilities', []);
        $notes = $request->input('notes', []);

        // Get tournaments user can access - SOLO TORNEI FUTURI
        $accessibleQuery = Tournament::where('start_date', '>=', Carbon::today());

        if ($isNationalReferee) {
            // Arbitri nazionali: zona propria + gare nazionali
            $accessibleQuery->where(function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id)
                    ->orWhereHas('tournamentCategory', function ($q2) {
                        $q2->where('is_national', true);
                    });
            });
        } else {
            // Arbitri aspiranti/primo_livello/regionali: solo zona propria
            $accessibleQuery->where('zone_id', $user->zone_id);
        }

        $accessibleTournaments = $accessibleQuery->pluck('id')->toArray();

        // Filter only accessible tournaments
        $selectedTournaments = array_intersect($selectedTournaments, $accessibleTournaments);

        // Start transaction
        \DB::beginTransaction();

        try {
            // Remove old availabilities for accessible tournaments
            Availability::where('user_id', $user->id)
                ->whereIn('tournament_id', $accessibleTournaments)
                ->delete();

            // Add new availabilities
            foreach ($selectedTournaments as $tournamentId) {
                Availability::create([
                    'user_id' => $user->id,
                    'tournament_id' => $tournamentId,
                    'notes' => $notes[$tournamentId] ?? null,
                    'submitted_at' => Carbon::now(),
                ]);
            }

            \DB::commit();

            return redirect()->route('referee.availability.index')
                ->with('success', 'Disponibilità aggiornate con successo!');
        } catch (\Exception $e) {
            \DB::rollback();

            return redirect()->route('referee.availability.index')
                ->with('error', 'Errore durante il salvataggio delle disponibilità. Riprova.');
        }
    }

    /**
     * Toggle single availability via AJAX - ORIGINALE
     */
    public function toggle(Request $request)
    {
        $request->validate([
            'tournament_id' => 'required|exists:tournaments,id',
            'available' => 'required|boolean',
            'notes' => 'nullable|string|max:500',
        ]);

        $user = auth()->user();
        $tournament = Tournament::findOrFail($request->tournament_id);
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);

        // Check if user can access this tournament
        $canAccess = false;
        if ($isNationalReferee) {
            // Arbitri nazionali: zona propria + gare nazionali
            $canAccess = $tournament->zone_id == $user->zone_id ||
                $tournament->tournamentCategory->is_national;
        } else {
            // Arbitri non nazionali: solo zona propria
            $canAccess = $tournament->zone_id == $user->zone_id;
        }

        if (!$canAccess) {
            return response()->json(['error' => 'Non autorizzato'], 403);
        }

        // Check if tournament allows availability changes - SENZA DEADLINE
        if ($tournament->start_date <= Carbon::today()) {
            return response()->json(['error' => 'Torneo già iniziato'], 400);
        }

        if ($request->available) {
            // Add availability
            Availability::updateOrCreate(
                [
                    'user_id' => $user->id,
                    'tournament_id' => $tournament->id,
                ],
                [
                    'notes' => $request->notes,
                    'submitted_at' => Carbon::now(),
                ]
            );

            return response()->json([
                'success' => true,
                'message' => 'Disponibilità confermata',
            ]);
        } else {
            // Remove availability
            Availability::where('user_id', $user->id)
                ->where('tournament_id', $tournament->id)
                ->delete();

            return response()->json([
                'success' => true,
                'message' => 'Disponibilità rimossa',
            ]);
        }
    }

    /**
     * Referee Calendar - Personal focus - SOLO GARE DI COMPETENZA
     */
    public function calendar(Request $request)
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level ?? '', ['nazionale', 'internazionale']);

        // Get tournaments for calendar - LOGICA AGGIORNATA
        $tournamentsQuery = Tournament::with(['tournamentCategory', 'zone', 'club'])
            ->whereIn('status', ['draft', 'open', 'closed', 'assigned']);

        if ($isNationalReferee) {
            // Arbitri nazionali: zona propria + gare nazionali ovunque
            $tournamentsQuery->where(function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id)
                    ->orWhereHas('tournamentCategory', function ($q2) {
                        $q2->where('is_national', true);
                    });
            });
        } else {
            // Arbitri aspiranti/primo_livello/regionali: solo zona propria (incluse gare nazionali nella loro zona)
            $tournamentsQuery->where('zone_id', $user->zone_id);
        }

        $tournaments = $tournamentsQuery->get();

        // Get user's availabilities and assignments
        $userAvailabilities = $user->availabilities()->pluck('tournament_id')->toArray();
        $userAssignments = $user->assignments()->pluck('tournament_id')->toArray();

        // Format tournaments for calendar - CON CODICE CIRCOLO NEL TITOLO
        $calendarTournaments = $tournaments->map(function ($tournament) use ($userAvailabilities, $userAssignments) {
            $isAvailable = in_array($tournament->id, $userAvailabilities);
            $isAssigned = in_array($tournament->id, $userAssignments);

            return [
                'id' => $tournament->id,
                'title' => $tournament->name . ($tournament->club->code ? ' (' . $tournament->club->code . ')' : ''),
                'start' => $tournament->start_date->format('Y-m-d'),
                'end' => $tournament->end_date->addDay()->format('Y-m-d'),
                'color' => $isAssigned ? '#10B981' : ($isAvailable ? '#3B82F6' : '#E5E7EB'),
                'borderColor' => $isAssigned ? '#10B981' : ($isAvailable ? '#F59E0B' : '#9CA3AF'),
                'textColor' => $isAssigned ? '#FFFFFF' : ($isAvailable ? '#FFFFFF' : '#374151'), // Testo nero per eventi non selezionati
                'extendedProps' => [
                    'club' => $tournament->club->name ?? 'N/A',
                    'club_code' => $tournament->club->code ?? '',
                    'zone' => $tournament->zone->name ?? 'N/A',
                    'category' => $tournament->tournamentCategory->name ?? 'N/A',
                    'status' => $tournament->status,
                    'deadline' => $tournament->availability_deadline?->format('d/m/Y') ?? 'N/A',
                    'days_until_deadline' => $tournament->availability_deadline
                        ? Carbon::today()->diffInDays($tournament->availability_deadline, false)
                        : null,
                    'is_available' => $isAvailable,
                    'is_assigned' => $isAssigned,
                    'can_apply' => $tournament->start_date > Carbon::today() &&
                        ($tournament->availability_deadline ? $tournament->availability_deadline >= Carbon::today() : true),
                    'personal_status' => $isAssigned ? 'assigned' : ($isAvailable ? 'available' : 'can_apply'),
                    'tournament_url' => route('tournaments.show', $tournament),
                    'is_national' => $tournament->tournamentCategory->is_national ?? false,
                ],
            ];
        });

        // STRUTTURA DATI per RefereeCalendar.jsx
        $calendarData = [
            'tournaments' => $calendarTournaments,
            'userType' => 'referee',
            'userRoles' => ['referee'],
            'canModify' => true,
            'zones' => collect(),
            'types' => collect(),
            'clubs' => collect(),
            'availabilities' => $userAvailabilities,
            'assignments' => $userAssignments,
            'totalTournaments' => $tournaments->count(),
            'lastUpdated' => now()->toISOString(),
            'userLevel' => $user->level,
            'isNationalReferee' => $isNationalReferee,
        ];

        return view('referee.availability.calendar', compact('calendarData'));
    }


    /**
     * NUOVO METODO: Check if user can apply to tournament
     */
    private function userCanApplyToTournament($user, $tournament): bool
    {
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);

        // National referees: own zone + national tournaments
        if ($isNationalReferee) {
            return $tournament->zone_id == $user->zone_id
                || $tournament->tournamentCategory->is_national;
        }

        // Zone referees: only own zone (including national tournaments in own zone)
        return $tournament->zone_id == $user->zone_id;
    }

    /**
     * Get event color based on tournament category (same as admin) - PRESERVATO
     */
    private function getEventColor($tournament, $userAvailabilities, $userAssignments): string
    {
        if (in_array($tournament->id, $userAssignments)) {
            return '#10B981'; // Green - Assigned
        }

        if (in_array($tournament->id, $userAvailabilities)) {
            return '#3B82F6'; // Blue - Available
        }

        if ($tournament->isOpenForAvailability()) {
            return '#F59E0B'; // Amber - Open
        }

        return '#6B7280'; // Gray - Closed/Other
    }

    /**
     * Referee border color - based on personal status - PRESERVATO
     */
    private function getRefereeBorderColor($isAvailable, $isAssigned): string
    {
        if ($isAssigned) {
            return '#10B981'; // Green - Assigned
        }

        if ($isAvailable) {
            return '#F59E0B'; // Amber - Available but not assigned
        }

        return '#6B7280'; // Gray - Not available
    }

    /**
     * Get personal status for referee
     */
    private function getPersonalStatus($isAvailable, $isAssigned, $tournament): string
    {
        if ($isAssigned) {
            return 'assigned';
        }

        if ($isAvailable) {
            return 'available';
        }

        // Can apply if tournament is open for availability
        return 'can_apply';
    }
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;

class DashboardController extends Controller
{
    /**
     * Display the referee dashboard.
     */
    public function index()
    {
        $user = auth()->user();
        $isNationalReferee = in_array($user->level, ['nazionale', 'internazionale']);

        // Get referee statistics (usando un try-catch per evitare errori)
        try {
            $stats = $user->referee_statistics;
        } catch (\Exception $e) {
            // Se il metodo non esiste, creiamo delle statistiche base
            $stats = (object) [
                'total_assignments' => $user->assignments()->count(),
                'assignments_this_year' => $user->assignments()
                    ->whereHas('tournament', function($q) {
                        $q->whereYear('start_date', now()->year);
                    })
                    ->count(),
                'confirmed_assignments' => $user->assignments()->where('is_confirmed', true)->count(),
                'pending_assignments' => $user->assignments()->where('is_confirmed', false)->count(),
            ];
        }

        // Upcoming assignments
        $upcomingAssignments = $user->assignments()
            ->with(['tournament.club', 'tournament.zone', 'tournament.tournamentCategory'])
            ->whereHas('tournament', function ($q) {
                $q->where('start_date', '>=', Carbon::today());
            })
            ->limit(5)
            ->get();

        // Recent assignments (last 3 months)
        $recentAssignments = $user->assignments()
            ->with(['tournament.club', 'tournament.zone'])
            ->whereHas('tournament', function ($q) {
                $q->where('end_date', '>=', Carbon::now()->subMonths(3))
                  ->where('end_date', '<', Carbon::today());
            })
            ->limit(5)
            ->get();

        // Tournaments open for availability
        $openTournamentsQuery = Tournament::with(['club', 'zone', 'tournamentCategory'])
            ->where('status', 'open')
            ->where('availability_deadline', '>=', Carbon::today());

        // Filter by zone for non-national referees
        if (!$isNationalReferee) {
            $openTournamentsQuery->where('zone_id', $user->zone_id);
        } else {
            // National referees see national tournaments from all zones
            $openTournamentsQuery->where(function ($q) use ($user) {
                $q->where('zone_id', $user->zone_id)
                  ->orWhereHas('tournamentCategory', function ($q2) {
                      $q2->where('is_national', true);
                  });
            });
        }

        $openTournaments = $openTournamentsQuery
            ->orderBy('availability_deadline')
            ->limit(10)
            ->get();

        // Get availabilities that haven't been assigned yet
        $pendingAvailabilities = $user->availabilities()
            ->with(['tournament.club', 'tournament.zone'])
            ->whereDoesntHave('tournament.assignments', function ($q) use ($user) {
                $q->where('user_id', $user->id);
            })
            ->whereHas('tournament', function ($q) {
                $q->whereIn('status', ['open', 'closed'])
                  ->where('start_date', '>=', Carbon::today());
            })
            ->limit(5)
            ->get();

        // Monthly statistics (last 12 months) - semplificato
        $monthlyStats = [];
        for ($i = 11; $i >= 0; $i--) {
            $month = Carbon::now()->subMonths($i)->format('Y-m');
            $count = $user->assignments()
                ->whereHas('tournament', function($q) use ($month) {
                    $q->where('start_date', 'like', $month . '%');
                })
                ->count();
            $monthlyStats[$month] = $count;
        }

        // Assignments by tournament category - semplificato
        $assignmentsByCategory = $user->assignments()
            ->join('tournaments', 'assignments.tournament_id', '=', 'tournaments.id')
            ->join('tournament_categories', 'tournaments.tournament_category_id', '=', 'tournament_categories.id')
            ->select('tournament_categories.name', DB::raw('count(*) as total'))
            ->whereYear('assignments.created_at', Carbon::now()->year)
            ->groupBy('tournament_categories.name')
            ->pluck('total', 'name')
            ->toArray();

        // Calendar events for the next 3 months - semplificato
        $calendarEvents = [];
        $calendarAssignments = $user->assignments()
            ->with(['tournament.club', 'tournament.tournamentCategory'])
            ->whereHas('tournament', function ($q) {
                $q->whereBetween('start_date', [Carbon::today(), Carbon::today()->addMonths(3)]);
            })
            ->get();

        foreach ($calendarAssignments as $assignment) {
            $calendarEvents[] = [
                'id' => 'assignment-' . $assignment->id,
                'title' => $assignment->tournament->name,
                'start' => $assignment->tournament->start_date->format('Y-m-d'),
                'end' => $assignment->tournament->end_date ? $assignment->tournament->end_date->addDay()->format('Y-m-d') : $assignment->tournament->start_date->format('Y-m-d'),
                'color' => $assignment->is_confirmed ? '#10b981' : '#f59e0b',
                'textColor' => '#ffffff'
            ];
        }

        return view('referee.dashboard', compact(
            'user',
            'stats',
            'upcomingAssignments',
            'recentAssignments',
            'openTournaments',
            'pendingAvailabilities',
            'monthlyStats',
            'assignmentsByCategory',
            'calendarEvents'
        ));
    }
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class DocumentController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Referee;

use App\Http\Controllers\Controller;
use App\Models\Referee;
use App\Models\Zone;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Hash;

class ProfileController extends Controller
{
    public function edit()
    {
        $user = auth()->user();
        $referee = $user->referee;

        // Se non esiste il referee, crealo
        if (!$referee) {
            $referee = Referee::create([
                'user_id' => $user->id,
                'zone_id' => $user->zone_id,
                'referee_code' => 'REF' . str_pad($user->id, 4, '0', STR_PAD_LEFT),
                'level' => 'primo_livello',
                'category' => 'misto',
                'certified_date' => now(),
            ]);
        }

        $zones = Zone::orderBy('name')->get();

        $levels = [
            'primo_livello' => 'Primo Livello',
            'secondo_livello' => 'Secondo Livello',
            'terzo_livello' => 'Terzo Livello',
            'nazionale' => 'Nazionale',
            'internazionale' => 'Internazionale'
        ];

        return view('referee.profile.edit', compact('referee', 'zones', 'levels'));
    }

    public function update(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|email|unique:users,email,' . auth()->id(),
            'phone' => 'nullable|string|max:20',
            'level' => 'required|string',
            'zone_id' => 'required|exists:zones,id',
            'category' => 'required|string',
            'bio' => 'nullable|string|max:1000',
            'experience_years' => 'nullable|integer|min:0',
            'specializations' => 'nullable|array',
            'languages' => 'nullable|array',
        ]);

        try {
            DB::beginTransaction();

            $user = auth()->user();
            $referee = $user->referee;

            // Aggiorna User
            $user->update([
                'name' => $request->name,
                'email' => $request->email,
                'phone' => $request->phone,
                'zone_id' => $request->zone_id,
            ]);

            // Aggiorna Referee
            $referee->update([
                'level' => $request->level,
                'zone_id' => $request->zone_id,
                'category' => $request->category,
                'bio' => $request->bio ?: 'Profilo arbitro completato',
                'experience_years' => $request->experience_years ?: 0,
                'specializations' => json_encode($request->specializations ?: ['stroke_play']),
                'languages' => json_encode($request->languages ?: ['it']),
                'profile_completed_at' => now(), // ✅ IMPORTANTE: Marca come completato
            ]);

            DB::commit();

            return redirect()
                ->route('referee.dashboard')
                ->with('success', 'Profilo aggiornato con successo!');

        } catch (\Exception $e) {
            DB::rollback();

            return redirect()
                ->back()
                ->withInput()
                ->with('error', 'Errore durante l\'aggiornamento: ' . $e->getMessage());
        }
    }

    public function updatePassword(Request $request)
    {
        $request->validate([
            'current_password' => 'required',
            'password' => 'required|min:8|confirmed',
        ]);

        if (!Hash::check($request->current_password, auth()->user()->password)) {
            return back()->withErrors(['current_password' => 'Password attuale non corretta']);
        }

        auth()->user()->update([
            'password' => Hash::make($request->password)
        ]);

        return back()->with('success', 'Password aggiornata con successo!');
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class AnalyticsController extends Controller
{
    //
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\Assignment;
use App\Models\Zone;
use App\Models\TournamentCategory;
use Illuminate\Http\Request;
use Illuminate\View\View;
use Carbon\Carbon;

class AssignmentReportController extends Controller
{
    /**
     * Display assignments report.
     */
    public function index(Request $request): View
    {
        $user = auth()->user();

        $query = Assignment::with([
            'user:id,name,referee_code,level',
            'tournament:id,name,start_date,end_date,zone_id,club_id,tournament_category_id',
            'tournament.club:id,name',
            'tournament.zone:id,name',
            'tournament.tournamentCategory:id,name',
            'assignedBy:id,name'
        ]);

        // Apply access restrictions
        if ($user->user_type === 'admin' && !in_array($user->user_type, ['super_admin', 'national_admin'])) {
            $query->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        // Apply filters
        if ($request->filled('zone_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('zone_id', $request->zone_id);
            });
        }

        if ($request->filled('status')) {
            if ($request->status === 'confirmed') {
                $query->where('is_confirmed', true);
            } elseif ($request->status === 'unconfirmed') {
                $query->where('is_confirmed', false);
            }
        }

        if ($request->filled('date_from')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('start_date', '>=', $request->date_from);
            });
        }

        if ($request->filled('date_to')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('start_date', '<=', $request->date_to);
            });
        }

        if ($request->filled('category_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('tournament_category_id', $request->category_id);
            });
        }

        $assignments = $query
            ->orderBy('created_at', 'desc')
            ->paginate(20)
            ->withQueryString();

        // Get filter options
        $zones = $this->getAccessibleZones($user);
        $categories = TournamentCategory::active()->ordered()->get();

        // Get statistics
        $stats = $this->getAssignmentStats($user, $request);

        return view('reports.assignments.index', compact(
            'assignments',
            'zones',
            'categories',
            'stats'
        ));
    }

    /**
     * Get assignment statistics.
     */
    private function getAssignmentStats($user, $request): array
    {
        $query = Assignment::query();

        // Apply same access restrictions as main query
        if ($user->user_type === 'admin' && !in_array($user->user_type, ['super_admin', 'national_admin'])) {
            $query->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        // Apply same filters as main query
        if ($request->filled('zone_id')) {
            $query->whereHas('tournament', function($q) use ($request) {
                $q->where('zone_id', $request->zone_id);
            });
        }

        if ($request->filled('date_from') || $request->filled('date_to')) {
            $query->whereHas('tournament', function($q) use ($request) {
                if ($request->filled('date_from')) {
                    $q->where('start_date', '>=', $request->date_from);
                }
                if ($request->filled('date_to')) {
                    $q->where('start_date', '<=', $request->date_to);
                }
            });
        }

        return [
            'total' => $query->count(),
            'confirmed' => $query->where('is_confirmed', true)->count(),
            'unconfirmed' => $query->where('is_confirmed', false)->count(),
            'current_year' => $query->whereYear('created_at', now()->year)->count(),
            'this_month' => $query->whereMonth('created_at', now()->month)
                                 ->whereYear('created_at', now()->year)->count(),
        ];
    }

    /**
     * Get zones accessible to the user.
     */
    private function getAccessibleZones($user)
    {
        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return Zone::orderBy('name')->get();
        }

        return Zone::where('id', $user->zone_id)->get();
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\TournamentCategory;
use Illuminate\Http\Request;
use Illuminate\View\View;

class CategoryReportController extends Controller
{
    /**
     * Display category reports listing.
     */
    public function index(): View
    {
        $categories = TournamentCategory::withCount('tournaments')
            ->ordered()
            ->get();

        return view('reports.categories.index', compact('categories'));
    }

    /**
     * Show specific category report.
     */
    public function show(TournamentCategory $category): View
    {
        return view('reports.categories.show', compact('category'));
    }

    /**
     * Export category report.
     */
    public function export(TournamentCategory $category)
    {
        return response()->json(['message' => 'Export in sviluppo']);
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Models\Zone;
use App\Models\Tournament;
use App\Models\TournamentCategory;
use App\Models\Club;
use App\Models\TournamentAssignment;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Carbon\Carbon;

class DashboardController extends Controller
{
    /**
     * Display the reports dashboard.
     */
    public function index(Request $request)
    {
        $period = $request->get('period', '30'); // days
        $startDate = Carbon::now()->subDays($period);

        // Basic statistics
        $stats = $this->getBasicStats();

        // Growth statistics
        $growth = $this->getGrowthStats($startDate);

        // Activity trends
        $trends = $this->getActivityTrends($startDate);

        // Zone performance
        $zonePerformance = $this->getZonePerformance();

        // Category usage
        $categoryUsage = $this->getCategoryUsage();

        // Recent activity
        $recentActivity = $this->getRecentActivity();

        // System health indicators
        $systemHealth = $this->getSystemHealth();

        return view('reports.dashboard.index', compact(
            'stats',
            'growth',
            'trends',
            'zonePerformance',
            'categoryUsage',
            'recentActivity',
            'systemHealth',
            'period'
        ));
    }

    /**
     * Get basic system statistics.
     */
    private function getBasicStats()
    {
        return [
            'total_users' => User::count(),
            'active_users' => User::where('is_active', true)->count(),
            'total_referees' => User::where('user_type', 'referee')->count(),
            'active_referees' => User::where('user_type', 'referee')->where('is_active', true)->count(),
            'total_zones' => Zone::count(),
            'active_zones' => Zone::where('is_active', true)->count(),
            'total_clubs' => Club::count(),
            'active_clubs' => Club::where('is_active', true)->count(),
            'total_tournaments' => Tournament::count(),
            'active_tournaments' => Tournament::whereIn('status', ['open', 'closed', 'assigned'])->count(),
            'completed_tournaments' => Tournament::where('status', 'completed')->count(),
            'total_categories' => TournamentCategory::count(),
            'active_categories' => TournamentCategory::where('is_active', true)->count(),
            'total_assignments' => TournamentAssignment::count(),
            'pending_assignments' => TournamentAssignment::where('status', 'pending')->count(),
            'accepted_assignments' => TournamentAssignment::where('status', 'accepted')->count(),
        ];
    }

    /**
     * Get growth statistics over a period.
     */
    private function getGrowthStats($startDate)
    {
        $previousPeriodStart = $startDate->copy()->subDays($startDate->diffInDays(Carbon::now()));

        // Current period counts
        $currentUsers = User::where('created_at', '>=', $startDate)->count();
        $currentTournaments = Tournament::where('created_at', '>=', $startDate)->count();
        $currentClubs = Club::where('created_at', '>=', $startDate)->count();
        $currentAssignments = TournamentAssignment::where('created_at', '>=', $startDate)->count();

        // Previous period counts
        $previousUsers = User::whereBetween('created_at', [$previousPeriodStart, $startDate])->count();
        $previousTournaments = Tournament::whereBetween('created_at', [$previousPeriodStart, $startDate])->count();
        $previousClubs = Club::whereBetween('created_at', [$previousPeriodStart, $startDate])->count();
        $previousAssignments = TournamentAssignment::whereBetween('created_at', [$previousPeriodStart, $startDate])->count();

        return [
            'users' => [
                'current' => $currentUsers,
                'previous' => $previousUsers,
                'growth' => $previousUsers > 0 ? (($currentUsers - $previousUsers) / $previousUsers) * 100 : 0
            ],
            'tournaments' => [
                'current' => $currentTournaments,
                'previous' => $previousTournaments,
                'growth' => $previousTournaments > 0 ? (($currentTournaments - $previousTournaments) / $previousTournaments) * 100 : 0
            ],
            'clubs' => [
                'current' => $currentClubs,
                'previous' => $previousClubs,
                'growth' => $previousClubs > 0 ? (($currentClubs - $previousClubs) / $previousClubs) * 100 : 0
            ],
            'assignments' => [
                'current' => $currentAssignments,
                'previous' => $previousAssignments,
                'growth' => $previousAssignments > 0 ? (($currentAssignments - $previousAssignments) / $previousAssignments) * 100 : 0
            ],
        ];
    }

    /**
     * Get activity trends over time.
     */
    private function getActivityTrends($startDate)
    {
        $userTrends = User::select(
            DB::raw('DATE(created_at) as date'),
            DB::raw('COUNT(*) as count')
        )
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get()
            ->keyBy('date')
            ->pluck('count');

        $tournamentTrends = Tournament::select(
            DB::raw('DATE(created_at) as date'),
            DB::raw('COUNT(*) as count')
        )
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get()
            ->keyBy('date')
            ->pluck('count');

        $assignmentTrends = TournamentAssignment::select(
            DB::raw('DATE(created_at) as date'),
            DB::raw('COUNT(*) as count')
        )
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get()
            ->keyBy('date')
            ->pluck('count');

        // Fill missing dates with 0
        $dates = [];
        $current = $startDate->copy();
        while ($current <= Carbon::now()) {
            $dateStr = $current->format('Y-m-d');
            $dates[] = [
                'date' => $dateStr,
                'users' => $userTrends->get($dateStr, 0),
                'tournaments' => $tournamentTrends->get($dateStr, 0),
                'assignments' => $assignmentTrends->get($dateStr, 0),
            ];
            $current->addDay();
        }

        return $dates;
    }

    /**
     * Get zone performance statistics.
     */
    private function getZonePerformance()
    {
        return Zone::withCount(['users', 'tournaments', 'clubs'])
            ->orderBy('tournaments_count', 'desc')
            ->limit(10)
            ->get()
            ->map(function ($zone) {
                return [
                    'id' => $zone->id,
                    'name' => $zone->name,
                    'region' => $zone->region,
                    'users_count' => $zone->users_count,
                    'tournaments_count' => $zone->tournaments_count,
                    'clubs_count' => $zone->clubs_count,
                    'is_active' => $zone->is_active,
                ];
            });
    }

    /**
     * Get tournament category usage statistics.
     */
    private function getCategoryUsage()
    {
        return TournamentCategory::withCount('tournaments')
            ->orderBy('tournaments_count', 'desc')
            ->get()
            ->map(function ($category) {
                return [
                    'id' => $category->id,
                    'name' => $category->name,
                    'code' => $category->code,
                    'tournaments_count' => $category->tournaments_count,
                    'is_national' => $category->is_national,
                    'is_active' => $category->is_active,
                ];
            });
    }

    /**
     * Get recent system activity.
     */
    private function getRecentActivity()
    {
        $activities = [];

        // Recent users
        $recentUsers = User::latest()->limit(5)->get();
        foreach ($recentUsers as $user) {
            $activities[] = [
                'type' => 'user_registered',
                'title' => 'Nuovo utente registrato',
                'description' => "{$user->name} si è registrato come {$user->user_type}",
                'created_at' => $user->created_at,
                'icon' => 'user-plus',
                'color' => 'blue',
            ];
        }

        // Recent tournaments
        $recentTournaments = Tournament::with(['category', 'zone'])->latest()->limit(5)->get();
        foreach ($recentTournaments as $tournament) {
            $activities[] = [
                'type' => 'tournament_created',
                'title' => 'Nuovo torneo creato',
                'description' => $tournament->name . ' (' . ($tournament->tournamentCategory->name ?? 'N/A') . ') - ' . ($tournament->zone->name ?? 'N/A'),
                'created_at' => $tournament->created_at,
                'icon' => 'calendar',
                'color' => 'green',
            ];
        }

        // Recent assignments
        $recentAssignments = TournamentAssignment::with(['tournament', 'referee'])
            ->where('status', 'accepted')
            ->latest()
            ->limit(5)
            ->get();
        foreach ($recentAssignments as $assignment) {
            $activities[] = [
                'type' => 'assignment_accepted',
                'title' => 'Assegnazione accettata',
                'description' => "{$assignment->referee->name} ha accettato {$assignment->tournament->name}",
                'created_at' => $assignment->updated_at,
                'icon' => 'check-circle',
                'color' => 'green',
            ];
        }

        // Sort by creation date
        return collect($activities)->sortByDesc('created_at')->take(15)->values();
    }

    /**
     * Get system health indicators.
     */
    private function getSystemHealth()
    {
        $health = [
            'database' => $this->checkDatabaseHealth(),
            'user_activity' => $this->checkUserActivity(),
            'tournament_activity' => $this->checkTournamentActivity(),
            'assignment_rate' => $this->checkAssignmentRate(),
            'system_errors' => $this->checkSystemErrors(),
        ];

        // Calculate overall health score
        $scores = array_column($health, 'score');
        $overallScore = count($scores) > 0 ? array_sum($scores) / count($scores) : 0;

        $health['overall'] = [
            'score' => $overallScore,
            'status' => $this->getHealthStatus($overallScore),
            'message' => $this->getHealthMessage($overallScore),
        ];

        return $health;
    }

    /**
     * Check database health.
     */
    private function checkDatabaseHealth()
    {
        try {
            DB::connection()->getPdo();
            $tableCount = count(DB::select('SHOW TABLES'));

            return [
                'score' => 100,
                'status' => 'healthy',
                'message' => "Database connesso ({$tableCount} tabelle)",
                'details' => ['tables' => $tableCount]
            ];
        } catch (\Exception $e) {
            return [
                'score' => 0,
                'status' => 'error',
                'message' => 'Errore connessione database',
                'details' => ['error' => $e->getMessage()]
            ];
        }
    }

    /**
     * Check user activity.
     */
    private function checkUserActivity()
    {
        $totalUsers = User::count();
        $activeUsers = User::where('last_login_at', '>=', Carbon::now()->subDays(30))->count();

        if ($totalUsers == 0) {
            $activityRate = 0;
        } else {
            $activityRate = ($activeUsers / $totalUsers) * 100;
        }

        return [
            'score' => min($activityRate, 100),
            'status' => $activityRate >= 70 ? 'healthy' : ($activityRate >= 40 ? 'warning' : 'error'),
            'message' => "{$activeUsers}/{$totalUsers} utenti attivi (ultimi 30 giorni)",
            'details' => [
                'total' => $totalUsers,
                'active' => $activeUsers,
                'rate' => round($activityRate, 1)
            ]
        ];
    }

    /**
     * Check tournament activity.
     */
    private function checkTournamentActivity()
    {
        $recentTournaments = Tournament::where('created_at', '>=', Carbon::now()->subDays(30))->count();
        $activeTournaments = Tournament::whereIn('status', ['open', 'closed', 'assigned'])->count();

        $score = min(($recentTournaments * 10) + ($activeTournaments * 5), 100);

        return [
            'score' => $score,
            'status' => $score >= 70 ? 'healthy' : ($score >= 40 ? 'warning' : 'error'),
            'message' => "{$recentTournaments} tornei creati, {$activeTournaments} attivi",
            'details' => [
                'recent' => $recentTournaments,
                'active' => $activeTournaments
            ]
        ];
    }

    /**
     * Check assignment rate.
     */
    private function checkAssignmentRate()
    {
        $totalAssignments = TournamentAssignment::count();
        $acceptedAssignments = TournamentAssignment::where('status', 'accepted')->count();

        if ($totalAssignments == 0) {
            $acceptanceRate = 100; // No assignments yet, assume healthy
        } else {
            $acceptanceRate = ($acceptedAssignments / $totalAssignments) * 100;
        }

        return [
            'score' => $acceptanceRate,
            'status' => $acceptanceRate >= 80 ? 'healthy' : ($acceptanceRate >= 60 ? 'warning' : 'error'),
            'message' => "{$acceptedAssignments}/{$totalAssignments} assegnazioni accettate",
            'details' => [
                'total' => $totalAssignments,
                'accepted' => $acceptedAssignments,
                'rate' => round($acceptanceRate, 1)
            ]
        ];
    }

    /**
     * Check for system errors.
     */
    private function checkSystemErrors()
    {
        // This is a simplified check - in a real app you'd check log files
        $inactiveZones = Zone::where('is_active', false)->count();
        $inactiveUsers = User::where('is_active', false)->count();

        $issues = $inactiveZones + $inactiveUsers;
        $score = max(100 - ($issues * 5), 0);

        return [
            'score' => $score,
            'status' => $score >= 90 ? 'healthy' : ($score >= 70 ? 'warning' : 'error'),
            'message' => $issues == 0 ? 'Nessun problema rilevato' : "{$issues} elementi disattivati",
            'details' => [
                'inactive_zones' => $inactiveZones,
                'inactive_users' => $inactiveUsers
            ]
        ];
    }

    /**
     * Get health status based on score.
     */
    private function getHealthStatus($score)
    {
        if ($score >= 80) return 'healthy';
        if ($score >= 60) return 'warning';
        return 'error';
    }

    /**
     * Get health message based on score.
     */
    private function getHealthMessage($score)
    {
        if ($score >= 90) return 'Sistema in ottima salute';
        if ($score >= 80) return 'Sistema in buona salute';
        if ($score >= 60) return 'Sistema con alcuni problemi';
        if ($score >= 40) return 'Sistema con problemi significativi';
        return 'Sistema con gravi problemi';
    }

    /**
     * Export dashboard data.
     */
    public function export(Request $request)
    {
        $period = $request->get('period', '30');
        $format = $request->get('format', 'csv');

        $stats = $this->getBasicStats();
        $growth = $this->getGrowthStats(Carbon::now()->subDays($period));

        $data = array_merge($stats, [
            'export_date' => Carbon::now()->format('Y-m-d H:i:s'),
            'period_days' => $period,
        ]);

        if ($format === 'json') {
            return response()->json($data);
        }

        // CSV Export
        $filename = 'dashboard_report_' . Carbon::now()->format('Y-m-d_H-i-s') . '.csv';

        $headers = [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ];

        $callback = function () use ($data) {
            $file = fopen('php://output', 'w');

            // CSV headers
            fputcsv($file, ['Metrica', 'Valore']);

            foreach ($data as $key => $value) {
                if (is_numeric($value)) {
                    fputcsv($file, [ucfirst(str_replace('_', ' ', $key)), $value]);
                }
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\View\View;

class RefereeReportController extends Controller
{
    /**
     * Display referee report.
     */
    public function show(User $referee): View
    {
        // Check that user is actually a referee
        if (!$referee->isReferee()) {
            abort(404, 'Utente non trovato.');
        }

        // Check access
        $this->checkRefereeAccess($referee);

        // Load relationships and statistics
        $referee->load([
            'zone',
            'assignments.tournament.club',
            'availabilities.tournament.club'
        ]);

        // Get statistics
        $stats = [
            'total_assignments' => $referee->assignments()->count(),
            'confirmed_assignments' => $referee->assignments()->where('is_confirmed', true)->count(),
            'current_year_assignments' => $referee->assignments()->whereYear('created_at', now()->year)->count(),
            'total_availabilities' => $referee->availabilities()->count(),
            'current_year_availabilities' => $referee->availabilities()->whereYear('created_at', now()->year)->count(),
            'upcoming_assignments' => $referee->assignments()->upcoming()->count(),
        ];

        // Get recent assignments
        $recentAssignments = $referee->assignments()
            ->with(['tournament.club', 'tournament.zone'])
            ->orderBy('created_at', 'desc')
            ->limit(10)
            ->get();

        return view('reports.referee.show', compact('referee', 'stats', 'recentAssignments'));
    }

    /**
     * Export referee report.
     */
    public function export(User $referee)
    {
        $this->checkRefereeAccess($referee);

        // TODO: Implement export functionality
        return response()->json([
            'message' => 'Export functionality coming soon'
        ]);
    }

    /**
     * Check if user can access referee reports.
     */
    private function checkRefereeAccess(User $referee): void
    {
        $user = auth()->user();

        // Super admin and national admin can access all
        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        // Zone admin can access referees in their zone
        if ($user->user_type === 'admin' && $user->zone_id === $referee->zone_id) {
            return;
        }

        // Referees can only access their own reports
        if ($user->isReferee() && $user->id === $referee->id) {
            return;
        }

        abort(403, 'Non sei autorizzato ad accedere a questo report.');
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\Zone;
use App\Models\Tournament;
use App\Models\User;
use App\Models\Assignment;
use Illuminate\Http\Request;
use Illuminate\View\View;

class ReportController extends Controller
{
    /**
     * Display reports dashboard.
     */
    public function index(): View
    {
        $user = auth()->user();

        // Get user's accessible zones
        $zones = $this->getAccessibleZones($user);

        // Get recent tournaments
        $recentTournaments = $this->getAccessibleTournaments($user)
            ->with(['club', 'zone', 'tournamentCategory'])
            ->orderBy('start_date', 'desc')
            ->limit(10)
            ->get();

        // Get statistics based on user access
        $stats = $this->getAccessibleStats($user);

        return view('reports.index', compact('zones', 'recentTournaments', 'stats'));
    }

    /**
     * Get zones accessible to the user.
     */
    private function getAccessibleZones($user)
    {
        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return Zone::orderBy('name')->get();
        }

        return Zone::where('id', $user->zone_id)->get();
    }

    /**
     * Get tournaments accessible to the user.
     */
    private function getAccessibleTournaments($user)
    {
        $query = Tournament::query();

        if ($user->user_type === 'admin' && $user->user_type !== 'super_admin' && $user->user_type !== 'national_admin') {
            $query->where('zone_id', $user->zone_id);
        }

        return $query;
    }

    /**
     * Get statistics based on user access.
     */
    private function getAccessibleStats($user): array
    {
        $tournamentsQuery = $this->getAccessibleTournaments($user);
        $assignmentsQuery = Assignment::query();

        if ($user->user_type === 'admin' && $user->user_type !== 'super_admin' && $user->user_type !== 'national_admin') {
            $assignmentsQuery->whereHas('tournament', function($q) use ($user) {
                $q->where('zone_id', $user->zone_id);
            });
        }

        return [
            'total_tournaments' => $tournamentsQuery->count(),
            'upcoming_tournaments' => $tournamentsQuery->upcoming()->count(),
            'active_tournaments' => $tournamentsQuery->active()->count(),
            'total_assignments' => $assignmentsQuery->count(),
            'confirmed_assignments' => $assignmentsQuery->where('is_confirmed', true)->count(),
            'current_year_assignments' => $assignmentsQuery->whereYear('created_at', now()->year)->count(),
        ];
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\Tournament;
use Illuminate\View\View;

class TournamentReportController extends Controller
{
    /**
     * Display tournament report.
     */
    public function show(Tournament $tournament): View
    {
        // Check access
        $this->checkTournamentAccess($tournament);

        // Load relationships
        $tournament->load([
            'club',
            'zone',
            'tournamentCategory',
            'availabilities.user',
            'assignments.user',
            'assignments.assignedBy'
        ]);

        // Get statistics
        $stats = [
            'total_availabilities' => $tournament->availabilities()->count(),
            'total_assignments' => $tournament->assignments()->count(),
            'confirmed_assignments' => $tournament->assignments()->where('is_confirmed', true)->count(),
            'required_referees' => $tournament->required_referees,
            'max_referees' => $tournament->max_referees,
            'days_until_start' => $tournament->start_date ? now()->diffInDays($tournament->start_date, false) : null,
        ];

        return view('reports.tournament.show', compact('tournament', 'stats'));
    }

    /**
     * Export tournament report.
     */
    public function export(Tournament $tournament)
    {
        $this->checkTournamentAccess($tournament);

        // TODO: Implement export functionality
        return response()->json([
            'message' => 'Export functionality coming soon'
        ]);
    }

    /**
     * Check if user can access tournament reports.
     */
    private function checkTournamentAccess(Tournament $tournament): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $user->zone_id !== $tournament->zone_id) {
            abort(403, 'Non sei autorizzato ad accedere ai report di questo torneo.');
        }
    }
}
<?php

namespace App\Http\Controllers\Reports;

use App\Http\Controllers\Controller;
use App\Models\Zone;
use App\Models\User;
use App\Models\Tournament;
use App\Models\Assignment;
use Illuminate\Http\Request;
use Illuminate\View\View;
use Carbon\Carbon;

class ZoneReportController extends Controller
{
    /**
     * Display zone overview report.
     */
    public function show(Zone $zone): View
    {
        // Check access
        $this->checkZoneAccess($zone);

        // Get statistics
        $stats = [
            'total_referees' => $zone->referees()->count(),
            'active_referees' => $zone->referees()->where('is_active', true)->count(),
            'total_clubs' => $zone->clubs()->count(),
            'active_clubs' => $zone->clubs()->where('is_active', true)->count(),
            'total_tournaments' => $zone->tournaments()->count(),
            'upcoming_tournaments' => $zone->tournaments()->upcoming()->count(),
            'active_tournaments' => $zone->tournaments()->active()->count(),
            'completed_tournaments' => $zone->tournaments()->where('status', 'completed')->count(),
        ];

        // Get referees by level
        $refereesByLevel = $zone->referees()
            ->where('is_active', true)
            ->selectRaw('level, COUNT(*) as total')
            ->groupBy('level')
            ->get()
            ->pluck('total', 'level')
            ->toArray();

        // Get recent tournaments
        $recentTournaments = $zone->tournaments()
            ->with(['club', 'tournamentCategory'])
            ->orderBy('start_date', 'desc')
            ->limit(10)
            ->get();

        // Get assignment statistics
        $assignmentStats = [
            'total_assignments' => Assignment::whereHas('tournament', function($q) use ($zone) {
                $q->where('zone_id', $zone->id);
            })->count(),
            'confirmed_assignments' => Assignment::whereHas('tournament', function($q) use ($zone) {
                $q->where('zone_id', $zone->id);
            })->where('is_confirmed', true)->count(),
            'current_year' => Assignment::whereHas('tournament', function($q) use ($zone) {
                $q->where('zone_id', $zone->id);
            })->whereYear('created_at', now()->year)->count(),
        ];

        return view('reports.zone.show', compact(
            'zone',
            'stats',
            'refereesByLevel',
            'recentTournaments',
            'assignmentStats'
        ));
    }

    /**
     * Display zone referees report.
     */
    public function referees(Zone $zone): View
    {
        $this->checkZoneAccess($zone);

        $referees = $zone->referees()
            ->with(['assignments' => function($q) {
                $q->whereYear('created_at', now()->year);
            }])
            ->withCount([
                'assignments',
                'assignments as current_year_assignments' => function($q) {
                    $q->whereYear('created_at', now()->year);
                },
                'availabilities'
            ])
            ->orderBy('is_active', 'desc')
            ->orderBy('level')
            ->orderBy('name')
            ->paginate(20);

        return view('reports.zone.referees', compact('zone', 'referees'));
    }

    /**
     * Display zone tournaments report.
     */
    public function tournaments(Zone $zone): View
    {
        $this->checkZoneAccess($zone);

        $tournaments = $zone->tournaments()
            ->with(['club', 'tournamentCategory'])
            ->withCount(['assignments', 'availabilities'])
            ->orderBy('start_date', 'desc')
            ->paginate(20);

        return view('reports.zone.tournaments', compact('zone', 'tournaments'));
    }

    /**
     * Export zone report.
     */
    public function export(Zone $zone)
    {
        $this->checkZoneAccess($zone);

        // TODO: Implement export functionality
        return response()->json([
            'message' => 'Export functionality coming soon'
        ]);
    }

    /**
     * Check if user can access zone reports.
     */
    private function checkZoneAccess(Zone $zone): void
    {
        $user = auth()->user();

        if ($user->user_type === 'super_admin' || $user->user_type === 'national_admin') {
            return;
        }

        if ($user->user_type === 'admin' && $user->zone_id !== $zone->id) {
            abort(403, 'Non sei autorizzato ad accedere ai report di questa zona.');
        }
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;

class SystemController extends Controller
{
    /**
     * Display system logs.
     */
    public function logs(Request $request)
    {
        $logFile = $request->get('file', 'laravel.log');
        $logPath = storage_path("logs/{$logFile}");

        $logs = [];
        $availableFiles = [];

        // Get available log files
        $logFiles = File::files(storage_path('logs'));
        foreach ($logFiles as $file) {
            if (pathinfo($file, PATHINFO_EXTENSION) === 'log') {
                $availableFiles[] = $file->getFilename();
            }
        }

        // Read log file if exists
        if (File::exists($logPath)) {
            $content = File::get($logPath);
            $lines = array_reverse(explode("\n", $content));

            foreach ($lines as $line) {
                if (trim($line) && preg_match('/^\[(.*?)\].*?(ERROR|WARNING|INFO|DEBUG).*?: (.*)/', $line, $matches)) {
                    $logs[] = [
                        'timestamp' => $matches[1],
                        'level' => $matches[2],
                        'message' => $matches[3],
                        'full_line' => $line
                    ];
                }

                // Limit to 1000 entries for performance
                if (count($logs) >= 1000) {
                    break;
                }
            }
        }

        return view('super-admin.system.logs', compact('logs', 'availableFiles', 'logFile'));
    }

    /**
     * Display system activity.
     */
    public function activity(Request $request)
    {
        $period = $request->get('period', '7'); // days
        $startDate = now()->subDays($period);

        // User activity
        $userActivity = DB::table('users')
            ->select(DB::raw('DATE(updated_at) as date'), DB::raw('count(*) as count'))
            ->where('updated_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        // Tournament activity
        $tournamentActivity = DB::table('tournaments')
            ->select(DB::raw('DATE(created_at) as date'), DB::raw('count(*) as count'))
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        // Assignment activity
        $assignmentActivity = DB::table('tournament_assignments')
            ->select(DB::raw('DATE(created_at) as date'), DB::raw('count(*) as count'))
            ->where('created_at', '>=', $startDate)
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        // Active users
        $activeUsers = DB::table('users')
            ->where('last_login_at', '>=', now()->subDays(1))
            ->count();

        // System stats
        $systemStats = [
            'total_users' => DB::table('users')->count(),
            'active_users_24h' => $activeUsers,
            'total_tournaments' => DB::table('tournaments')->count(),
            'active_tournaments' => DB::table('tournaments')->whereIn('status', ['open', 'closed', 'assigned'])->count(),
            'total_assignments' => DB::table('tournament_assignments')->count(),
            'pending_assignments' => DB::table('tournament_assignments')->where('status', 'pending')->count(),
        ];

        return view('super-admin.system.activity', compact(
            'userActivity',
            'tournamentActivity',
            'assignmentActivity',
            'systemStats',
            'period'
        ));
    }

    /**
     * Display system performance metrics.
     */
    public function performance(Request $request)
    {
        $metrics = $this->getPerformanceMetrics();
        $dbStats = $this->getDatabaseStats();
        $cacheStats = $this->getCacheStats();

        return view('super-admin.system.performance', compact('metrics', 'dbStats', 'cacheStats'));
    }

    /**
     * Toggle maintenance mode.
     */
    public function toggleMaintenance(Request $request)
    {
        try {
            if (app()->isDownForMaintenance()) {
                Artisan::call('up');
                $message = 'Modalità manutenzione disattivata.';
                $status = false;
            } else {
                $secret = $request->get('secret', \Str::random(8));
                Artisan::call('down', [
                    '--secret' => $secret,
                    '--render' => 'errors.503'
                ]);
                $message = 'Modalità manutenzione attivata.';
                $status = true;
            }

            return response()->json([
                'success' => true,
                'message' => $message,
                'maintenance_mode' => $status
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Errore: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * Clear specific cache types.
     */
    public function clearCache(Request $request)
    {
        $type = $request->get('type', 'all');

        try {
            switch ($type) {
                case 'config':
                    Artisan::call('config:clear');
                    $message = 'Cache configurazione svuotata.';
                    break;

                case 'view':
                    Artisan::call('view:clear');
                    $message = 'Cache viste svuotata.';
                    break;

                case 'route':
                    Artisan::call('route:clear');
                    $message = 'Cache rotte svuotata.';
                    break;

                case 'application':
                    Cache::flush();
                    $message = 'Cache applicazione svuotata.';
                    break;

                default:
                    Artisan::call('cache:clear');
                    Artisan::call('config:clear');
                    Artisan::call('view:clear');
                    Artisan::call('route:clear');
                    Cache::flush();
                    $message = 'Tutte le cache svuotate.';
            }

            return response()->json([
                'success' => true,
                'message' => $message
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Errore: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * Optimize system performance.
     */
    public function optimize(Request $request)
    {
        try {
            Artisan::call('config:cache');
            Artisan::call('route:cache');
            Artisan::call('view:cache');

            if (app()->environment('production')) {
                Artisan::call('optimize');
            }

            return response()->json([
                'success' => true,
                'message' => 'Sistema ottimizzato con successo.'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Errore: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * Run system diagnostics.
     */
    public function diagnostics()
    {
        $diagnostics = [
            'php_version' => [
                'value' => PHP_VERSION,
                'status' => version_compare(PHP_VERSION, '8.1.0', '>=') ? 'success' : 'warning',
                'message' => version_compare(PHP_VERSION, '8.1.0', '>=') ? 'OK' : 'Aggiornamento consigliato'
            ],
            'laravel_version' => [
                'value' => app()->version(),
                'status' => 'success',
                'message' => 'OK'
            ],
            'database_connection' => [
                'value' => $this->testDatabaseConnection(),
                'status' => $this->testDatabaseConnection() ? 'success' : 'error',
                'message' => $this->testDatabaseConnection() ? 'Connessa' : 'Errore connessione'
            ],
            'cache_working' => [
                'value' => $this->testCache(),
                'status' => $this->testCache() ? 'success' : 'warning',
                'message' => $this->testCache() ? 'Funzionante' : 'Problemi rilevati'
            ],
            'storage_writable' => [
                'value' => is_writable(storage_path()),
                'status' => is_writable(storage_path()) ? 'success' : 'error',
                'message' => is_writable(storage_path()) ? 'Scrivibile' : 'Non scrivibile'
            ],
            'disk_space' => [
                'value' => $this->getAvailableDiskSpace(),
                'status' => $this->getAvailableDiskSpace() > 1000 ? 'success' : 'warning',
                'message' => $this->formatBytes($this->getAvailableDiskSpace()) . ' disponibili'
            ],
            'memory_usage' => [
                'value' => memory_get_usage(true),
                'status' => memory_get_usage(true) < 128 * 1024 * 1024 ? 'success' : 'warning',
                'message' => $this->formatBytes(memory_get_usage(true)) . ' in uso'
            ]
        ];

        return response()->json($diagnostics);
    }

    /**
     * Get performance metrics.
     */
    private function getPerformanceMetrics()
    {
        return [
            'memory_usage' => [
                'current' => memory_get_usage(true),
                'peak' => memory_get_peak_usage(true),
                'limit' => $this->parseSize(ini_get('memory_limit'))
            ],
            'execution_time' => [
                'max' => ini_get('max_execution_time'),
                'current' => microtime(true) - LARAVEL_START
            ],
            'upload_limits' => [
                'max_filesize' => $this->parseSize(ini_get('upload_max_filesize')),
                'post_max_size' => $this->parseSize(ini_get('post_max_size'))
            ]
        ];
    }

    /**
     * Get database statistics.
     */
    private function getDatabaseStats()
    {
        try {
            $stats = [
                'connection' => DB::connection()->getDatabaseName(),
                'tables_count' => count(DB::select('SHOW TABLES')),
                'size' => $this->getDatabaseSize(),
            ];

            // Table sizes
            $tables = DB::select("
                SELECT table_name as 'table',
                       ROUND(((data_length + index_length) / 1024 / 1024), 2) as 'size_mb'
                FROM information_schema.TABLES
                WHERE table_schema = DATABASE()
                ORDER BY (data_length + index_length) DESC
                LIMIT 10
            ");

            $stats['largest_tables'] = $tables;

            return $stats;
        } catch (\Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Get cache statistics.
     */
    private function getCacheStats()
    {
        try {
            return [
                'driver' => config('cache.default'),
                'working' => $this->testCache(),
                'keys_count' => $this->getCacheKeysCount()
            ];
        } catch (\Exception $e) {
            return ['error' => $e->getMessage()];
        }
    }

    /**
     * Test database connection.
     */
    private function testDatabaseConnection()
    {
        try {
            DB::connection()->getPdo();
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Test cache functionality.
     */
    private function testCache()
    {
        try {
            $key = 'test_cache_key_' . time();
            Cache::put($key, 'test_value', 60);
            $value = Cache::get($key);
            Cache::forget($key);
            return $value === 'test_value';
        } catch (\Exception $e) {
            return false;
        }
    }

    /**
     * Get available disk space in bytes.
     */
    private function getAvailableDiskSpace()
    {
        return disk_free_space(storage_path());
    }

    /**
     * Get database size.
     */
    private function getDatabaseSize()
    {
        try {
            $result = DB::select("
                SELECT ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) as size_mb
                FROM information_schema.TABLES
                WHERE table_schema = DATABASE()
            ");

            return $result[0]->size_mb ?? 0;
        } catch (\Exception $e) {
            return 0;
        }
    }

    /**
     * Get cache keys count (approximation).
     */
    private function getCacheKeysCount()
    {
        try {
            // This is a simplified approach - actual implementation depends on cache driver
            return 'N/A';
        } catch (\Exception $e) {
            return 'Error';
        }
    }

    /**
     * Parse size string to bytes.
     */
    private function parseSize($size)
    {
        $unit = preg_replace('/[^bkmgtpezy]/i', '', $size);
        $size = preg_replace('/[^0-9\.]/', '', $size);

        if ($unit) {
            return round($size * pow(1024, stripos('bkmgtpezy', $unit[0])));
        }

        return round($size);
    }

    /**
     * Format bytes to human readable.
     */
    private function formatBytes($size, $precision = 2)
    {
        $base = log($size, 1024);
        $suffixes = array('B', 'KB', 'MB', 'GB', 'TB');

        return round(pow(1024, $base - floor($base)), $precision) . ' ' . $suffixes[floor($base)];
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Cache;
use App\Models\Setting;

class SystemSettingsController extends Controller
{
    /**
     * Display the system settings.
     */
    public function index()
    {
        $settings = $this->getCurrentSettings();
        $systemInfo = $this->getSystemInfo();

        return view('super-admin.settings.index', compact('settings', 'systemInfo'));
    }

    /**
     * Update the system settings.
     */
    public function update(Request $request)
    {
        $request->validate([
            'app_name' => 'required|string|max:255',
            'app_timezone' => 'required|string',
            'app_locale' => 'required|string',
            'mail_driver' => 'required|string',
            'mail_host' => 'nullable|string',
            'mail_port' => 'nullable|integer',
            'mail_username' => 'nullable|string',
            'mail_password' => 'nullable|string',
            'mail_encryption' => 'nullable|string',
            'mail_from_address' => 'required|email',
            'mail_from_name' => 'required|string',
            'system_maintenance' => 'boolean',
            'system_debug' => 'boolean',
            'cache_driver' => 'required|string',
            'session_lifetime' => 'required|integer|min:1|max:1440',
            'max_upload_size' => 'required|integer|min:1|max:100',
            'backup_enabled' => 'boolean',
            'backup_frequency' => 'required|string',
            'log_level' => 'required|string',
            'api_rate_limit' => 'required|integer|min:1|max:10000',
        ]);

        try {
            // Update database settings
            $this->updateSettings($request->all());

            // Clear cache
            Cache::flush();

            // Update .env file for critical settings
            $this->updateEnvFile([
                'APP_NAME' => $request->app_name,
                'APP_TIMEZONE' => $request->app_timezone,
                'APP_LOCALE' => $request->app_locale,
                'APP_DEBUG' => $request->system_debug ? 'true' : 'false',
                'MAIL_MAILER' => $request->mail_driver,
                'MAIL_HOST' => $request->mail_host,
                'MAIL_PORT' => $request->mail_port,
                'MAIL_USERNAME' => $request->mail_username,
                'MAIL_FROM_ADDRESS' => $request->mail_from_address,
                'MAIL_FROM_NAME' => $request->mail_from_name,
                'SESSION_LIFETIME' => $request->session_lifetime,
            ]);

            return redirect()->route('super-admin.settings.index')
                ->with('success', 'Impostazioni aggiornate con successo.');

        } catch (\Exception $e) {
            return redirect()->route('super-admin.settings.index')
                ->with('error', 'Errore durante l\'aggiornamento: ' . $e->getMessage());
        }
    }

    /**
     * Clear system cache
     */
    public function clearCache()
    {
        try {
            Artisan::call('cache:clear');
            Artisan::call('config:clear');
            Artisan::call('view:clear');
            Artisan::call('route:clear');

            return response()->json(['success' => true, 'message' => 'Cache svuotata con successo']);
        } catch (\Exception $e) {
            return response()->json(['success' => false, 'message' => 'Errore: ' . $e->getMessage()]);
        }
    }

    /**
     * Optimize system
     */
    public function optimize()
    {
        try {
            Artisan::call('config:cache');
            Artisan::call('route:cache');
            Artisan::call('view:cache');

            return response()->json(['success' => true, 'message' => 'Sistema ottimizzato con successo']);
        } catch (\Exception $e) {
            return response()->json(['success' => false, 'message' => 'Errore: ' . $e->getMessage()]);
        }
    }

    /**
     * Get current settings
     */
    private function getCurrentSettings()
    {
        return [
            'app_name' => config('app.name'),
            'app_timezone' => config('app.timezone'),
            'app_locale' => config('app.locale'),
            'mail_driver' => config('mail.default'),
            'mail_host' => config('mail.mailers.smtp.host'),
            'mail_port' => config('mail.mailers.smtp.port'),
            'mail_username' => config('mail.mailers.smtp.username'),
            'mail_encryption' => config('mail.mailers.smtp.encryption'),
            'mail_from_address' => config('mail.from.address'),
            'mail_from_name' => config('mail.from.name'),
            'system_maintenance' => app()->isDownForMaintenance(),
            'system_debug' => config('app.debug'),
            'cache_driver' => config('cache.default'),
            'session_lifetime' => config('session.lifetime'),
            'max_upload_size' => ini_get('upload_max_filesize'),
            'backup_enabled' => $this->getSetting('backup_enabled', false),
            'backup_frequency' => $this->getSetting('backup_frequency', 'daily'),
            'log_level' => config('logging.level'),
            'api_rate_limit' => $this->getSetting('api_rate_limit', 1000),
        ];
    }

    /**
     * Get system information
     */
    private function getSystemInfo()
    {
        return [
            'php_version' => PHP_VERSION,
            'laravel_version' => app()->version(),
            'server_software' => $_SERVER['SERVER_SOFTWARE'] ?? 'Unknown',
            'database_size' => $this->getDatabaseSize(),
            'storage_used' => $this->getStorageUsed(),
            'log_size' => $this->getLogSize(),
            'uptime' => $this->getSystemUptime(),
            'memory_usage' => $this->getMemoryUsage(),
        ];
    }

    /**
     * Update settings in database
     */
    private function updateSettings(array $settings)
    {
        foreach ($settings as $key => $value) {
            Setting::updateOrCreate(
                ['key' => $key],
                ['value' => $value]
            );
        }
    }

    /**
     * Get setting value
     */
    private function getSetting($key, $default = null)
    {
        $setting = Setting::where('key', $key)->first();
        return $setting ? $setting->value : $default;
    }

    /**
     * Update .env file
     */
    private function updateEnvFile(array $data)
    {
        $envFile = base_path('.env');

        if (!File::exists($envFile)) {
            return;
        }

        $envContent = File::get($envFile);

        foreach ($data as $key => $value) {
            if ($value === null) continue;

            $pattern = "/^{$key}=.*/m";
            $replacement = "{$key}=\"{$value}\"";

            if (preg_match($pattern, $envContent)) {
                $envContent = preg_replace($pattern, $replacement, $envContent);
            } else {
                $envContent .= "\n{$replacement}";
            }
        }

        File::put($envFile, $envContent);
    }

    /**
     * Helper methods for system info
     */
    private function getDatabaseSize()
    {
        try {
            $size = \DB::selectOne("SELECT pg_size_pretty(pg_database_size(current_database())) as size");
            return $size->size ?? 'N/A';
        } catch (\Exception $e) {
            return 'N/A';
        }
    }

    private function getStorageUsed()
    {
        $bytes = disk_total_space(storage_path()) - disk_free_space(storage_path());
        return $this->formatBytes($bytes);
    }

    private function getLogSize()
    {
        $logPath = storage_path('logs');
        $size = 0;

        if (is_dir($logPath)) {
            foreach (new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($logPath)) as $file) {
                $size += $file->getSize();
            }
        }

        return $this->formatBytes($size);
    }

    private function getSystemUptime()
    {
        if (function_exists('sys_getloadavg')) {
            $uptime = shell_exec('uptime');
            return $uptime ? trim($uptime) : 'N/A';
        }
        return 'N/A';
    }

    private function getMemoryUsage()
    {
        $memory = memory_get_usage(true);
        return $this->formatBytes($memory);
    }

    private function formatBytes($bytes, $precision = 2)
    {
        $units = array('B', 'KB', 'MB', 'GB', 'TB');

        for ($i = 0; $bytes > 1024 && $i < count($units) - 1; $i++) {
            $bytes /= 1024;
        }

        return round($bytes, $precision) . ' ' . $units[$i];
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use App\Http\Requests\TournamentCategoryRequest;
use App\Models\TournamentCategory;
use App\Models\Zone;
use Illuminate\Http\Request;

class TournamentCategoryController extends Controller
{
    /**
     * Display a listing of the tournament categories.
     */
    public function index()
    {
        $categories = TournamentCategory::withCount('tournaments')
            ->ordered()
            ->get();

        return view('super-admin.tournament-categories.index', compact('categories'));
    }

    /**
     * Show the form for creating a new tournament category.
     */
    public function create()
    {
        $zones = Zone::where('is_national', false)->orderBy('name')->get();
        $refereeLevels = TournamentCategory::REFEREE_LEVELS;
        $categoryLevels = TournamentCategory::CATEGORY_LEVELS;

        return view('super-admin.tournament-categories.create', compact(
            'zones',
            'refereeLevels',
            'categoryLevels'
        ));
    }

    /**
     * Store a newly created tournament category in storage.
     */
    public function store(TournamentCategoryRequest $request)
    {
        $data = $request->validated();

        // Prepara le impostazioni per il campo JSON
        $settings = [
            'required_referee_level' => $data['required_referee_level'] ?? 'aspirante',
            'min_referees' => $data['min_referees'] ?? 1,
            'max_referees' => $data['max_referees'] ?? $data['min_referees'] ?? 1,
            'special_requirements' => $data['special_requirements'] ?? null,
            'notification_templates' => $data['notification_templates'] ?? [],
        ];

        // Gestione visibility_zones
        if ($data['is_national'] ?? false) {
            $settings['visibility_zones'] = 'all';
        } else {
            $settings['visibility_zones'] = $data['visibility_zones'] ?? [];
        }

        // Crea la categoria con entrambi i sistemi (colonne fisiche + JSON)
        $category = TournamentCategory::create([
            'name' => $data['name'],
            'code' => strtoupper($data['code']),
            'description' => $data['description'] ?? null,
            'is_national' => $data['is_national'] ?? false,
            'level' => $data['level'] ?? 'zonale',
            'required_level' => $data['required_referee_level'] ?? 'aspirante',
            'sort_order' => $data['sort_order'] ?? 0,
            'is_active' => $data['is_active'] ?? true,

            // Colonne fisiche
            'min_referees' => $data['min_referees'] ?? 1,
            'max_referees' => $data['max_referees'] ?? $data['min_referees'] ?? 1,

            // Campo JSON (sincronizzato automaticamente dal modello)
            'settings' => $settings,
        ]);

        return redirect()
            ->route('super-admin.tournament-categories.index')
            ->with('success', 'Categoria torneo creata con successo!');
    }

    /**
     * Display the specified tournament category.
     */
    public function show(TournamentCategory $tournamentCategory)
    {
        $tournamentCategory->loadCount('tournaments');
        $recentTournaments = $tournamentCategory->tournaments()
            ->with(['club', 'zone'])
            ->latest()
            ->limit(10)
            ->get();

        return view('super-admin.tournament-categories.show', compact(
            'tournamentCategory',
            'recentTournaments'
        ));
    }

    /**
     * Show the form for editing the specified tournament category.
     */
    public function edit(TournamentCategory $tournamentCategory)
    {
        $zones = Zone::where('is_national', false)->orderBy('name')->get();
        $refereeLevels = TournamentCategory::REFEREE_LEVELS;
        $categoryLevels = TournamentCategory::CATEGORY_LEVELS;

        return view('super-admin.tournament-categories.edit', compact(
            'tournamentCategory',
            'zones',
            'refereeLevels',
            'categoryLevels'
        ));
    }

    /**
     * Update the specified tournament category in storage.
     */
    public function update(TournamentCategoryRequest $request, TournamentCategory $tournamentCategory)
    {
        $data = $request->validated();

        // Prepara le impostazioni per il campo JSON
        $settings = [
            'required_referee_level' => $data['required_referee_level'] ?? 'aspirante',
            'min_referees' => $data['min_referees'] ?? 1,
            'max_referees' => $data['max_referees'] ?? $data['min_referees'] ?? 1,
            'special_requirements' => $data['special_requirements'] ?? null,
            'notification_templates' => $data['notification_templates'] ?? [],
        ];

        // Gestione visibility_zones
        if ($data['is_national'] ?? false) {
            $settings['visibility_zones'] = 'all';
        } else {
            $settings['visibility_zones'] = $data['visibility_zones'] ?? [];
        }

        // Aggiorna la categoria con entrambi i sistemi
        $tournamentCategory->update([
            'name' => $data['name'],
            'code' => strtoupper($data['code']),
            'description' => $data['description'] ?? null,
            'is_national' => $data['is_national'] ?? false,
            'level' => $data['level'] ?? 'zonale',
            'required_level' => $data['required_referee_level'] ?? 'aspirante',
            'sort_order' => $data['sort_order'] ?? 0,
            'is_active' => $data['is_active'] ?? true,

            // Colonne fisiche
            'min_referees' => $data['min_referees'] ?? 1,
            'max_referees' => $data['max_referees'] ?? $data['min_referees'] ?? 1,

            // Campo JSON (sincronizzato automaticamente dal modello)
            'settings' => $settings,
        ]);

        return redirect()
            ->route('super-admin.tournament-categories.show', $tournamentCategory)
            ->with('success', 'Categoria torneo aggiornata con successo!');
    }

    /**
     * Remove the specified tournament category from storage.
     */
    public function destroy(TournamentCategory $tournamentCategory)
    {
        if (!$tournamentCategory->canBeDeleted()) {
            return redirect()
                ->route('super-admin.tournament-categories.index')
                ->with('error', 'Impossibile eliminare una categoria con tornei associati.');
        }

        $name = $tournamentCategory->name;
        $tournamentCategory->delete();

        return redirect()
            ->route('super-admin.tournament-categories.index')
            ->with('success', "Categoria torneo \"{$name}\" eliminata con successo!");
    }

    /**
     * Toggle active status.
     */
    public function toggleActive(TournamentCategory $tournamentCategory)
    {
        $tournamentCategory->update([
            'is_active' => !$tournamentCategory->is_active
        ]);

        $status = $tournamentCategory->is_active ? 'attivata' : 'disattivata';

        return redirect()->back()
            ->with('success', "Categoria \"{$tournamentCategory->name}\" {$status} con successo!");
    }

    /**
     * Update display order.
     */
    public function updateOrder(Request $request)
    {
        $request->validate([
            'categories' => 'required|array',
            'categories.*.id' => 'required|exists:tournament_categories,id',
            'categories.*.sort_order' => 'required|integer|min:0',
        ]);

        foreach ($request->categories as $categoryData) {
            TournamentCategory::where('id', $categoryData['id'])
                ->update(['sort_order' => $categoryData['sort_order']]);
        }

        return response()->json(['success' => true]);
    }

    /**
     * Duplicate a tournament category.
     */
    public function duplicateCategory(TournamentCategory $tournamentCategory)
    {
        $newCategory = $tournamentCategory->replicate();
        $newCategory->name = $tournamentCategory->name . ' (Copia)';
        $newCategory->code = $tournamentCategory->code . '_COPY';
        $newCategory->sort_order = TournamentCategory::max('sort_order') + 10;
        $newCategory->is_active = false;
        $newCategory->save();

        return redirect()
            ->route('super-admin.tournament-categories.edit', $newCategory)
            ->with('success', "Categoria duplicata con successo! Modifica i dettagli e attivala quando pronta.");
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Models\Zone;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Validation\Rule;

class UserController extends Controller
{
    /**
     * Display a listing of users.
     */
    public function index(Request $request)
    {
        $query = User::with(['zone', 'tournaments', 'assignments']);

        // Search filters
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                  ->orWhere('email', 'like', "%{$search}%")
                  ->orWhere('codice_tessera', 'like', "%{$search}%");
            });
        }

        if ($request->filled('user_type')) {
            $query->where('user_type', $request->user_type);
        }

        if ($request->filled('zone_id')) {
            $query->where('zone_id', $request->zone_id);
        }

        if ($request->filled('is_active')) {
            $query->where('is_active', $request->is_active);
        }

        $users = $query->orderBy('created_at', 'desc')->paginate(20);
        $zones = Zone::orderBy('name')->get();

        return view('super-admin.users.index', compact('users', 'zones'));
    }

    /**
     * Show the form for creating a new user.
     */
    public function create()
    {
        $zones = Zone::where('is_active', true)->orderBy('name')->get();
        $userTypes = [
            'super_admin' => 'Super Admin',
            'national_admin' => 'Admin Nazionale (CRC)',
            'zone_admin' => 'Admin Zona',
            'referee' => 'Arbitro'
        ];
        $refereeLevels = config('referee.referee_levels');

        return view('super-admin.users.create', compact('zones', 'userTypes', 'refereeLevels'));
    }

    /**
     * Store a newly created user.
     */
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8|confirmed',
            'user_type' => 'required|string|in:super_admin,national_admin,zone_admin,referee',
            'zone_id' => 'nullable|exists:zones,id',
            'codice_tessera' => 'nullable|string|max:50|unique:users',
            'telefono' => 'nullable|string|max:20',
            'data_nascita' => 'nullable|date',
            'indirizzo' => 'nullable|string|max:255',
            'citta' => 'nullable|string|max:100',
            'cap' => 'nullable|string|max:10',
            'livello_arbitro' => 'nullable|string|in:aspirante,1_livello,regionale,nazionale,internazionale',
            'is_active' => 'boolean',
            'profile_photo' => 'nullable|image|max:2048',
        ]);

        $userData = $request->except(['password', 'password_confirmation', 'profile_photo']);
        $userData['password'] = Hash::make($request->password);
        $userData['email_verified_at'] = now();

        // Handle profile photo upload
        if ($request->hasFile('profile_photo')) {
            $path = $request->file('profile_photo')->store('profile-photos', 'public');
            $userData['profile_photo_path'] = $path;
        }

        $user = User::create($userData);

        return redirect()->route('super-admin.users.index')
            ->with('success', 'Utente creato con successo.');
    }

    /**
     * Display the specified user.
     */
    public function show(User $user)
    {
        $user->load(['zone', 'tournaments', 'assignments.tournament']);

        $stats = [
            'tournaments_count' => $user->tournaments()->count(),
            'assignments_count' => $user->assignments()->count(),
            'pending_assignments' => $user->assignments()->where('status', 'pending')->count(),
            'completed_assignments' => $user->assignments()->where('status', 'accepted')->count(),
        ];

        return view('super-admin.users.show', compact('user', 'stats'));
    }

    /**
     * Show the form for editing the user.
     */
    public function edit(User $user)
    {
        $zones = Zone::where('is_active', true)->orderBy('name')->get();
        $userTypes = [
            'super_admin' => 'Super Admin',
            'national_admin' => 'Admin Nazionale (CRC)',
            'zone_admin' => 'Admin Zona',
            'referee' => 'Arbitro'
        ];
        $refereeLevels = config('referee.referee_levels');

        return view('super-admin.users.edit', compact('user', 'zones', 'userTypes', 'refereeLevels'));
    }

    /**
     * Update the specified user.
     */
    public function update(Request $request, User $user)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => ['required', 'string', 'email', 'max:255', Rule::unique('users')->ignore($user->id)],
            'password' => 'nullable|string|min:8|confirmed',
            'user_type' => 'required|string|in:super_admin,national_admin,zone_admin,referee',
            'zone_id' => 'nullable|exists:zones,id',
            'codice_tessera' => ['nullable', 'string', 'max:50', Rule::unique('users')->ignore($user->id)],
            'telefono' => 'nullable|string|max:20',
            'data_nascita' => 'nullable|date',
            'indirizzo' => 'nullable|string|max:255',
            'citta' => 'nullable|string|max:100',
            'cap' => 'nullable|string|max:10',
            'livello_arbitro' => 'nullable|string|in:aspirante,1_livello,regionale,nazionale,internazionale',
            'is_active' => 'boolean',
            'profile_photo' => 'nullable|image|max:2048',
        ]);

        $userData = $request->except(['password', 'password_confirmation', 'profile_photo']);

        // Update password only if provided
        if ($request->filled('password')) {
            $userData['password'] = Hash::make($request->password);
        }

        // Handle profile photo upload
        if ($request->hasFile('profile_photo')) {
            // Delete old photo if exists
            if ($user->profile_photo_path) {
                \Storage::disk('public')->delete($user->profile_photo_path);
            }

            $path = $request->file('profile_photo')->store('profile-photos', 'public');
            $userData['profile_photo_path'] = $path;
        }

        $user->update($userData);

        return redirect()->route('super-admin.users.show', $user)
            ->with('success', 'Utente aggiornato con successo.');
    }

    /**
     * Remove the specified user.
     */
    public function destroy(User $user)
    {
        // Prevent deleting current user
        if ($user->id === auth()->id()) {
            return redirect()->route('super-admin.users.index')
                ->with('error', 'Non puoi eliminare il tuo account.');
        }

        // Check if user has active assignments
        if ($user->assignments()->where('status', 'accepted')->exists()) {
            return redirect()->route('super-admin.users.index')
                ->with('error', 'Impossibile eliminare utente con assegnazioni attive.');
        }

        // Delete profile photo if exists
        if ($user->profile_photo_path) {
            \Storage::disk('public')->delete($user->profile_photo_path);
        }

        $user->delete();

        return redirect()->route('super-admin.users.index')
            ->with('success', 'Utente eliminato con successo.');
    }

    /**
     * Toggle user active status.
     */
    public function toggleActive(User $user)
    {
        // Prevent deactivating current user
        if ($user->id === auth()->id()) {
            return response()->json([
                'success' => false,
                'message' => 'Non puoi disattivare il tuo account.'
            ]);
        }

        $user->update(['is_active' => !$user->is_active]);

        return response()->json([
            'success' => true,
            'message' => $user->is_active ? 'Utente attivato.' : 'Utente disattivato.',
            'is_active' => $user->is_active
        ]);
    }

    /**
     * Reset user password.
     */
    public function resetPassword(User $user)
    {
        // Generate temporary password
        $tempPassword = \Str::random(12);

        $user->update([
            'password' => Hash::make($tempPassword),
            'email_verified_at' => null, // Force email verification
        ]);

        // Send password reset email
        try {
            // Here you would send an email with the temporary password
            // or a password reset link

            return response()->json([
                'success' => true,
                'message' => 'Password reimpostata. L\'utente riceverà le istruzioni via email.',
                'temp_password' => $tempPassword // Remove this in production
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Errore durante l\'invio dell\'email: ' . $e->getMessage()
            ]);
        }
    }

    /**
     * Bulk actions on users.
     */
    public function bulkAction(Request $request)
    {
        $request->validate([
            'action' => 'required|in:activate,deactivate,delete',
            'user_ids' => 'required|array|min:1',
            'user_ids.*' => 'exists:users,id'
        ]);

        $userIds = array_filter($request->user_ids, function($id) {
            return $id != auth()->id(); // Exclude current user
        });

        $users = User::whereIn('id', $userIds);

        switch ($request->action) {
            case 'activate':
                $users->update(['is_active' => true]);
                $message = 'Utenti attivati con successo.';
                break;

            case 'deactivate':
                $users->update(['is_active' => false]);
                $message = 'Utenti disattivati con successo.';
                break;

            case 'delete':
                // Check for active assignments
                $hasActiveAssignments = $users->whereHas('assignments', function($q) {
                    $q->where('status', 'accepted');
                })->exists();

                if ($hasActiveAssignments) {
                    return redirect()->route('super-admin.users.index')
                        ->with('error', 'Impossibile eliminare utenti con assegnazioni attive.');
                }

                $users->delete();
                $message = 'Utenti eliminati con successo.';
                break;
        }

        return redirect()->route('super-admin.users.index')
            ->with('success', $message);
    }
}
<?php

namespace App\Http\Controllers\SuperAdmin;

use App\Http\Controllers\Controller;
use App\Models\Zone;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Validation\Rule;

class ZoneController extends Controller
{
    /**
     * Display a listing of zones.
     */
    public function index(Request $request)
    {
        $query = Zone::withCount(['users', 'tournaments', 'clubs']);

        // Search filters
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                  ->orWhere('code', 'like', "%{$search}%")
                  ->orWhere('description', 'like', "%{$search}%");
            });
        }

        if ($request->filled('is_active')) {
            $query->where('is_active', $request->is_active);
        }

        $zones = $query->orderBy('sort_order')->orderBy('name')->paginate(15);

        // Statistics
        $stats = [
            'total_zones' => Zone::count(),
            'active_zones' => Zone::where('is_active', true)->count(),
            'total_users' => User::whereIn('zone_id', Zone::pluck('id'))->count(),
            'total_tournaments' => \DB::table('tournaments')->whereIn('zone_id', Zone::pluck('id'))->count(),
        ];

        return view('super-admin.zones.index', compact('zones', 'stats'));
    }

    /**
     * Show the form for creating a new zone.
     */
    public function create()
    {
        $admins = User::where('user_type', 'zone_admin')
                     ->whereNull('zone_id')
                     ->orWhere('zone_id', '')
                     ->orderBy('name')
                     ->get();

        return view('super-admin.zones.create', compact('admins'));
    }

    /**
     * Store a newly created zone.
     */
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255|unique:zones',
            'code' => 'required|string|max:10|unique:zones',
            'description' => 'nullable|string',
            'region' => 'required|string|max:100',
            'contact_email' => 'nullable|email|max:255',
            'contact_phone' => 'nullable|string|max:20',
            'address' => 'nullable|string|max:255',
            'city' => 'nullable|string|max:100',
            'postal_code' => 'nullable|string|max:10',
            'website' => 'nullable|url|max:255',
            'admin_id' => 'nullable|exists:users,id',
            'sort_order' => 'nullable|integer|min:0',
            'is_active' => 'boolean',
            'settings' => 'nullable|array',
            'coordinates' => 'nullable|string',
        ]);

        $zoneData = $request->all();
        $zoneData['settings'] = $request->settings ?? [];

        // Set sort order if not provided
        if (!$request->filled('sort_order')) {
            $zoneData['sort_order'] = Zone::max('sort_order') + 10;
        }

        $zone = Zone::create($zoneData);

        // Assign admin to zone if provided
        if ($request->filled('admin_id')) {
            User::where('id', $request->admin_id)->update(['zone_id' => $zone->id]);
        }

        return redirect()->route('super-admin.zones.index')
            ->with('success', 'Zona creata con successo.');
    }

    /**
     * Display the specified zone.
     */
    public function show(Zone $zone)
    {
        $zone->load(['users', 'tournaments.category', 'clubs']);

        $stats = [
            'total_users' => $zone->users()->count(),
            'active_users' => $zone->users()->where('is_active', true)->count(),
            'referees_count' => $zone->users()->where('user_type', 'referee')->count(),
            'admins_count' => $zone->users()->where('user_type', 'zone_admin')->count(),
            'tournaments_count' => $zone->tournaments()->count(),
            'active_tournaments' => $zone->tournaments()->whereIn('status', ['open', 'closed', 'assigned'])->count(),
            'clubs_count' => $zone->clubs()->count(),
            'active_clubs' => $zone->clubs()->where('is_active', true)->count(),
        ];

        // Recent activity
        $recentTournaments = $zone->tournaments()
                                  ->with('category')
                                  ->orderBy('created_at', 'desc')
                                  ->limit(10)
                                  ->get();

        $recentUsers = $zone->users()
                            ->orderBy('created_at', 'desc')
                            ->limit(10)
                            ->get();

        return view('super-admin.zones.show', compact('zone', 'stats', 'recentTournaments', 'recentUsers'));
    }

    /**
     * Show the form for editing the zone.
     */
    public function edit(Zone $zone)
    {
        $admins = User::where('user_type', 'zone_admin')
                     ->where(function($q) use ($zone) {
                         $q->whereNull('zone_id')
                           ->orWhere('zone_id', '')
                           ->orWhere('zone_id', $zone->id);
                     })
                     ->orderBy('name')
                     ->get();

        $currentAdmin = $zone->users()->where('user_type', 'zone_admin')->first();

        return view('super-admin.zones.edit', compact('zone', 'admins', 'currentAdmin'));
    }

    /**
     * Update the specified zone.
     */
    public function update(Request $request, Zone $zone)
    {
        $request->validate([
            'name' => ['required', 'string', 'max:255', Rule::unique('zones')->ignore($zone->id)],
            'code' => ['required', 'string', 'max:10', Rule::unique('zones')->ignore($zone->id)],
            'description' => 'nullable|string',
            'region' => 'required|string|max:100',
            'contact_email' => 'nullable|email|max:255',
            'contact_phone' => 'nullable|string|max:20',
            'address' => 'nullable|string|max:255',
            'city' => 'nullable|string|max:100',
            'postal_code' => 'nullable|string|max:10',
            'website' => 'nullable|url|max:255',
            'admin_id' => 'nullable|exists:users,id',
            'sort_order' => 'nullable|integer|min:0',
            'is_active' => 'boolean',
            'settings' => 'nullable|array',
            'coordinates' => 'nullable|string',
        ]);

        $zoneData = $request->all();
        $zoneData['settings'] = $request->settings ?? [];

        $zone->update($zoneData);

        // Update admin assignment
        $currentAdmin = $zone->users()->where('user_type', 'zone_admin')->first();

        if ($currentAdmin && $currentAdmin->id != $request->admin_id) {
            // Remove current admin
            $currentAdmin->update(['zone_id' => null]);
        }

        if ($request->filled('admin_id') && (!$currentAdmin || $currentAdmin->id != $request->admin_id)) {
            // Assign new admin
            User::where('id', $request->admin_id)->update(['zone_id' => $zone->id]);
        }

        return redirect()->route('super-admin.zones.show', $zone)
            ->with('success', 'Zona aggiornata con successo.');
    }

    /**
     * Remove the specified zone.
     */
    public function destroy(Zone $zone)
    {
        // Check if zone has users
        if ($zone->users()->exists()) {
            return redirect()->route('super-admin.zones.index')
                ->with('error', 'Impossibile eliminare una zona con utenti associati.');
        }

        // Check if zone has tournaments
        if ($zone->tournaments()->exists()) {
            return redirect()->route('super-admin.zones.index')
                ->with('error', 'Impossibile eliminare una zona con tornei associati.');
        }

        // Check if zone has clubs
        if ($zone->clubs()->exists()) {
            return redirect()->route('super-admin.zones.index')
                ->with('error', 'Impossibile eliminare una zona con circoli associati.');
        }

        $zone->delete();

        return redirect()->route('super-admin.zones.index')
            ->with('success', 'Zona eliminata con successo.');
    }

    /**
     * Toggle zone active status.
     */
    public function toggleActive(Zone $zone)
    {
        $zone->update(['is_active' => !$zone->is_active]);

        return response()->json([
            'success' => true,
            'message' => $zone->is_active ? 'Zona attivata.' : 'Zona disattivata.',
            'is_active' => $zone->is_active
        ]);
    }

    /**
     * Update zones sort order.
     */
    public function updateOrder(Request $request)
    {
        $request->validate([
            'zones' => 'required|array',
            'zones.*.id' => 'required|exists:zones,id',
            'zones.*.sort_order' => 'required|integer|min:0',
        ]);

        foreach ($request->zones as $zoneData) {
            Zone::where('id', $zoneData['id'])
                ->update(['sort_order' => $zoneData['sort_order']]);
        }

        return response()->json(['success' => true]);
    }

    /**
     * Duplicate a zone.
     */
    public function duplicate(Zone $zone)
    {
        $newZone = $zone->replicate();
        $newZone->name = $zone->name . ' (Copia)';
        $newZone->code = $zone->code . '_COPY';
        $newZone->sort_order = Zone::max('sort_order') + 10;
        $newZone->save();

        return redirect()->route('super-admin.zones.edit', $newZone)
            ->with('success', 'Zona duplicata con successo. Modifica i dettagli necessari.');
    }

    /**
     * Export zones data.
     */
    public function export(Request $request)
    {
        $zones = Zone::withCount(['users', 'tournaments', 'clubs'])->get();

        $filename = 'zones_export_' . now()->format('Y-m-d_H-i-s') . '.csv';

        $headers = [
            'Content-Type' => 'text/csv',
            'Content-Disposition' => "attachment; filename=\"{$filename}\"",
        ];

        $callback = function() use ($zones) {
            $file = fopen('php://output', 'w');

            // CSV headers
            fputcsv($file, [
                'ID',
                'Nome',
                'Codice',
                'Regione',
                'Città',
                'Email Contatto',
                'Telefono',
                'Utenti',
                'Tornei',
                'Circoli',
                'Stato',
                'Data Creazione'
            ]);

            foreach ($zones as $zone) {
                fputcsv($file, [
                    $zone->id,
                    $zone->name,
                    $zone->code,
                    $zone->region,
                    $zone->city,
                    $zone->contact_email,
                    $zone->contact_phone,
                    $zone->users_count,
                    $zone->tournaments_count,
                    $zone->clubs_count,
                    $zone->is_active ? 'Attiva' : 'Non Attiva',
                    $zone->created_at->format('d/m/Y H:i')
                ]);
            }

            fclose($file);
        };

        return response()->stream($callback, 200, $headers);
    }

    /**
     * Get zone statistics for dashboard.
     */
    public function getStats()
    {
        $stats = [
            'zones_by_region' => Zone::selectRaw('region, count(*) as count')
                                    ->groupBy('region')
                                    ->pluck('count', 'region'),

            'users_by_zone' => Zone::withCount('users')
                                  ->orderBy('users_count', 'desc')
                                  ->limit(10)
                                  ->pluck('users_count', 'name'),

            'tournaments_by_zone' => Zone::withCount('tournaments')
                                        ->orderBy('tournaments_count', 'desc')
                                        ->limit(10)
                                        ->pluck('tournaments_count', 'name'),

            'active_vs_inactive' => [
                'active' => Zone::where('is_active', true)->count(),
                'inactive' => Zone::where('is_active', false)->count(),
            ]
        ];

        return response()->json($stats);
    }
}
